"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=require("@keystonehq/bc-ur-registry"),a=require("uuid"),s=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,r=require("ethereumjs-util");const{RegistryType:i}=e.extend,n={ETH_SIGN_REQUEST:new i("eth-sign-request",401),ETH_SIGNATAURE:new i("eth-signature",402)},{decodeToDataItem:d,RegistryTypes:o}=e.extend;var h,u;!function(t){t[t.requestId=1]="requestId",t[t.signData=2]="signData",t[t.dataType=3]="dataType",t[t.chainId=4]="chainId",t[t.derivationPath=5]="derivationPath",t[t.address=6]="address"}(h||(h={})),(u=exports.DataType||(exports.DataType={}))[u.transaction=1]="transaction",u[u.typedData=2]="typedData",u[u.personalMessage=3]="personalMessage",u[u.typedTransaction=4]="typedTransaction";class g extends e.RegistryItem{constructor(t){super(),this.getRegistryType=()=>n.ETH_SIGN_REQUEST,this.setupData=t=>{this.requestId=t.requestId,this.signData=t.signData,this.dataType=t.dataType,this.chainId=t.chainId,this.derivationPath=t.derivationPath,this.address=t.address},this.getRequestId=()=>this.requestId,this.getSignData=()=>this.signData,this.getDataType=()=>this.dataType,this.getChainId=()=>this.chainId,this.getDerivationPath=()=>this.derivationPath.getPath(),this.getSignRequestAddress=()=>this.address,this.toDataItem=()=>{const t={};this.requestId&&(t[h.requestId]=new e.DataItem(this.requestId,o.UUID.getTag())),this.address&&(t[h.address]=this.address),this.chainId&&(t[h.chainId]=this.chainId),t[h.signData]=this.signData,t[h.dataType]=this.dataType;const a=this.derivationPath.toDataItem();return a.setTag(this.derivationPath.getRegistryType().getTag()),t[h.derivationPath]=a,new e.DataItem(t)},this.setupData(t)}static constructETHRequest(t,s,r,i,n,d,o){const h=r.replace(/[m|M]\//,"").split("/"),u=new e.CryptoKeypath(h.map(t=>{const a=parseInt(t.replace("'",""));let s=!1;return t.endsWith("'")&&(s=!0),new e.PathComponent({index:a,hardened:s})}),Buffer.from(i,"hex"));return new g({requestId:n?Buffer.from(a.parse(n)):void 0,signData:t,dataType:s,derivationPath:u,chainId:d,address:o?Buffer.from(o.replace("0x",""),"hex"):void 0})}}g.fromDataItem=t=>{const a=t.getData(),s=a[h.signData],r=a[h.dataType],i=e.CryptoKeypath.fromDataItem(a[h.derivationPath]),n=a[h.chainId]?a[h.chainId]:void 0,d=a[h.address]?a[h.address]:void 0,o=a[h.requestId]?a[h.requestId].getData():void 0;return new g({requestId:o,signData:s,dataType:r,chainId:n,derivationPath:i,address:d})},g.fromCBOR=t=>{const e=d(t);return g.fromDataItem(e)};const{RegistryTypes:c,decodeToDataItem:I}=e.extend;var p;!function(t){t[t.requestId=1]="requestId",t[t.signature=2]="signature"}(p||(p={}));class y extends e.RegistryItem{constructor(t,a){super(),this.getRegistryType=()=>n.ETH_SIGNATAURE,this.getRequestId=()=>this.requestId,this.getSignature=()=>this.signature,this.toDataItem=()=>{const t={};return this.requestId&&(t[p.requestId]=new e.DataItem(this.requestId,c.UUID.getTag())),t[p.signature]=this.signature,new e.DataItem(t)},this.signature=t,this.requestId=a}}y.fromDataItem=t=>{const e=t.getData(),a=e[p.signature],s=e[p.requestId]?e[p.requestId].getData():void 0;return new y(a,s)},y.fromCBOR=t=>{const e=I(t);return y.fromDataItem(e)};const T=(t,e)=>{const a=s.fromExtendedKey(t).derive(e),i="0x"+r.publicToAddress(a.publicKey,!0).toString("hex");return r.toChecksumAddress(i)},{cbor:D}=e.extend;D.patchTags(Object.values(n).filter(t=>!!t.getTag()).map(t=>t.getTag())),Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.ETHSignature=y,exports.EthSignRequest=g,exports.findHDpatfromAddress=(t,e,a,s)=>{for(let r=0;r<a;r++){let a=T(e,"M/0/"+r);if(t.toLowerCase()==a.toLowerCase())return`${s}/0/${r}`}return null},exports.generateAddressfromXpub=T;
//# sourceMappingURL=bc-ur-registry-eth.cjs.production.min.js.map
