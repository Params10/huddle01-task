{"version":3,"file":"bc-ur-registry-eth.cjs.production.min.js","sources":["../src/RegistryType.ts","../src/EthSignRequest.ts","../src/EthSignature.ts","../src/utlis.ts","../src/index.ts"],"sourcesContent":["import {extend} from '@keystonehq/bc-ur-registry'\nconst {RegistryType} = extend;\n\nexport const ExtendedRegistryTypes = {\n    ETH_SIGN_REQUEST: new RegistryType('eth-sign-request', 401),\n    ETH_SIGNATAURE: new RegistryType('eth-signature', 402)\n}","import { CryptoKeypath, extend, DataItem, PathComponent, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nimport * as uuid from 'uuid';\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nenum Keys {\n    requestId = 1,\n    signData,\n    dataType,\n    chainId,\n    derivationPath,\n    address,\n}\n\nexport enum DataType {\n    transaction = 1,\n    typedData = 2,\n    personalMessage = 3,\n    typedTransaction = 4,\n}\n\ntype signRequestProps = {\n    requestId?: Buffer;\n    signData: Buffer;\n    dataType: DataType;\n    chainId?: number;\n    derivationPath: CryptoKeypath;\n    address?: Buffer;\n};\n\nexport class EthSignRequest extends RegistryItem {\n    private requestId: Buffer;\n    private signData: Buffer;\n    private dataType: DataType;\n    private chainId: number;\n    private derivationPath: CryptoKeypath;\n    private address: Buffer;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n    constructor(args: signRequestProps) {\n        super();\n        this.setupData(args);\n    }\n\n    private setupData = (args: signRequestProps) => {\n        this.requestId = args.requestId;\n        this.signData = args.signData;\n        this.dataType = args.dataType;\n        this.chainId = args.chainId;\n        this.derivationPath = args.derivationPath;\n        this.address = args.address;\n    };\n\n    public getRequestId = () => this.requestId;\n    public getSignData = () => this.signData;\n    public getDataType = () => this.dataType;\n    public getChainId = () => this.chainId;\n    public getDerivationPath = () => this.derivationPath.getPath();\n    public getSignRequestAddress = () => this.address;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        if (this.address) {\n            map[Keys.address] = this.address;\n        }\n        if (this.chainId) {\n            map[Keys.chainId] = this.chainId;\n        }\n\n        map[Keys.signData] = this.signData;\n        map[Keys.dataType] = this.dataType;\n\n        const keyPath = this.derivationPath.toDataItem();\n        keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n        map[Keys.derivationPath] = keyPath;\n\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signData = map[Keys.signData];\n        const dataType = map[Keys.dataType];\n        const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n        const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n        const address = map[Keys.address] ? map[Keys.address] : undefined;\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n\n        return new EthSignRequest({\n            requestId,\n            signData,\n            dataType,\n            chainId,\n            derivationPath,\n            address,\n        });\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return EthSignRequest.fromDataItem(dataItem);\n    };\n\n    public static constructETHRequest(\n        signData: Buffer,\n        signDataType: DataType,\n        hdPath: string,\n        xfp: string,\n        uuidString?: string,\n        chainId?: number,\n        address?: string,\n    ) {\n        const paths = hdPath.replace(/[m|M]\\//, '').split('/');\n        const hdpathObject = new CryptoKeypath(\n            paths.map((path) => {\n                const index = parseInt(path.replace(\"'\", ''));\n                let isHardened = false;\n                if (path.endsWith(\"'\")) {\n                    isHardened = true;\n                }\n                return new PathComponent({ index, hardened: isHardened });\n            }),\n            Buffer.from(xfp, 'hex'),\n        );\n\n        return new EthSignRequest({\n            requestId: uuidString ? Buffer.from(uuid.parse(uuidString) as Uint8Array) : undefined,\n            signData,\n            dataType: signDataType,\n            derivationPath: hdpathObject,\n            chainId,\n            address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,\n        });\n    }\n}\n","import { extend, DataItem, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n    requestId = 1,\n    signature,\n}\n\nexport class ETHSignature extends RegistryItem {\n    private requestId: Buffer;\n    private signature: Buffer;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n    constructor(signature: Buffer, requestId?: Buffer) {\n        super();\n        this.signature = signature;\n        this.requestId = requestId;\n    }\n\n    public getRequestId = () => this.requestId;\n    public getSignature = () => this.signature;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        map[Keys.signature] = this.signature;\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signature = map[Keys.signature];\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n\n        return new ETHSignature(signature, requestId);\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return ETHSignature.fromDataItem(dataItem);\n    };\n}\n","// @ts-ignore\nimport HDKey from 'hdkey'\nimport { toChecksumAddress, publicToAddress } from 'ethereumjs-util';\n\nexport const generateAddressfromXpub = (xpub: string, derivePath: string) => {\n    // @ts-ignore\n    const node = HDKey.fromExtendedKey(xpub)\n    const publicKey = node.derive(derivePath)\n    const address = '0x' + publicToAddress(publicKey.publicKey, true).toString('hex');\n    return toChecksumAddress(address);\n}\n\n\nexport const findHDpatfromAddress = (address: string, xpub: string, numberLimit: number, rootPath: string) => {\n    for (let i = 0; i < numberLimit; i++) {\n        let path = `M/0/${i}`\n        let caculateAddress = generateAddressfromXpub(xpub, path)\n        if (address.toLowerCase() == caculateAddress.toLowerCase()) {\n            return `${rootPath}/0/${i}`\n        }\n    }\n    return null\n}","export * from '@keystonehq/bc-ur-registry';\nimport { extend } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nconst { cbor } = extend;\ncbor.patchTags(\n    Object.values(ExtendedRegistryTypes)\n        .filter((rt) => !!rt.getTag())\n        .map((rt) => rt.getTag()),\n);\n\nexport { EthSignRequest, DataType } from './EthSignRequest';\nexport { ETHSignature } from './EthSignature';\n\nexport { generateAddressfromXpub, findHDpatfromAddress } from './utlis'"],"names":["RegistryType","extend","ExtendedRegistryTypes","ETH_SIGN_REQUEST","ETH_SIGNATAURE","decodeToDataItem","RegistryTypes","Keys","DataType","EthSignRequest","RegistryItem","constructor","args","requestId","signData","dataType","chainId","derivationPath","address","this","getPath","map","DataItem","UUID","getTag","keyPath","toDataItem","setTag","getRegistryType","setupData","signDataType","hdPath","xfp","uuidString","paths","replace","split","hdpathObject","CryptoKeypath","path","index","parseInt","isHardened","endsWith","PathComponent","hardened","Buffer","from","uuid","undefined","dataItem","getData","fromDataItem","_cborPayload","ETHSignature","signature","generateAddressfromXpub","xpub","derivePath","publicKey","HDKey","fromExtendedKey","derive","publicToAddress","toString","toChecksumAddress","cbor","patchTags","Object","values","filter","rt","numberLimit","rootPath","i","caculateAddress","toLowerCase"],"mappings":"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"}