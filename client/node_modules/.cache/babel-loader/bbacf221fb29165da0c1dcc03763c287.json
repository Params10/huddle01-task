{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoAccount = void 0;\n\nconst _1 = require(\".\");\n\nconst lib_1 = require(\"./lib\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"masterFingerprint\"] = 1] = \"masterFingerprint\";\n  Keys[Keys[\"outputDescriptors\"] = 2] = \"outputDescriptors\";\n})(Keys || (Keys = {}));\n\nclass CryptoAccount extends RegistryItem_1.RegistryItem {\n  constructor(masterFingerprint, outputDescriptors) {\n    super();\n    this.masterFingerprint = masterFingerprint;\n    this.outputDescriptors = outputDescriptors;\n\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;\n    };\n\n    this.getMasterFingerprint = () => this.masterFingerprint;\n\n    this.getOutputDescriptors = () => this.outputDescriptors;\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.masterFingerprint) {\n        map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n      }\n\n      if (this.outputDescriptors) {\n        map[Keys.outputDescriptors] = this.outputDescriptors.map(item => item.toDataItem());\n      }\n\n      return new lib_1.DataItem(map);\n    };\n  }\n\n}\n\nexports.CryptoAccount = CryptoAccount;\n\nCryptoAccount.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const masterFingerprint = Buffer.alloc(4);\n  const _masterFingerprint = map[Keys.masterFingerprint];\n\n  if (_masterFingerprint) {\n    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n  }\n\n  const outputDescriptors = map[Keys.outputDescriptors];\n  const cryptoOutputs = outputDescriptors.map(item => _1.CryptoOutput.fromDataItem(item));\n  return new CryptoAccount(masterFingerprint, cryptoOutputs);\n};\n\nCryptoAccount.fromCBOR = _cborPayload => {\n  const dataItem = lib_1.decodeToDataItem(_cborPayload);\n  return CryptoAccount.fromDataItem(dataItem);\n};","map":{"version":3,"sources":["../src/CryptoAccount.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,EAAA,GAAA,OAAA,CAAA,GAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAK,IAAL;;AAAA,CAAA,UAAK,IAAL,EAAS;AACP,EAAA,IAAA,CAAA,IAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mBAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mBAAA;AACD,CAHD,EAAK,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAT;;AAKA,MAAa,aAAb,SAAmC,cAAA,CAAA,YAAnC,CAA+C;AAK7C,EAAA,WAAA,CACU,iBADV,EAEU,iBAFV,EAE2C;AAEzC;AAHQ,SAAA,iBAAA,GAAA,iBAAA;AACA,SAAA,iBAAA,GAAA,iBAAA;;AANV,SAAA,eAAA,GAAkB,MAAK;AACrB,aAAO,cAAA,CAAA,aAAA,CAAc,cAArB;AACD,KAFD;;AAWO,SAAA,oBAAA,GAAuB,MAAM,KAAK,iBAAlC;;AACA,SAAA,oBAAA,GAAuB,MAAM,KAAK,iBAAlC;;AAEA,SAAA,UAAA,GAAa,MAAK;AACvB,YAAM,GAAG,GAAG,EAAZ;;AACA,UAAI,KAAK,iBAAT,EAA4B;AAC1B,QAAA,GAAG,CAAC,IAAI,CAAC,iBAAN,CAAH,GAA8B,KAAK,iBAAL,CAAuB,YAAvB,CAAoC,CAApC,CAA9B;AACD;;AACD,UAAI,KAAK,iBAAT,EAA4B;AAC1B,QAAA,GAAG,CAAC,IAAI,CAAC,iBAAN,CAAH,GAA8B,KAAK,iBAAL,CAAuB,GAAvB,CAA4B,IAAD,IACvD,IAAI,CAAC,UAAL,EAD4B,CAA9B;AAGD;;AACD,aAAO,IAAI,KAAA,CAAA,QAAJ,CAAa,GAAb,CAAP;AACD,KAXM;AALN;;AAV4C;;AAA/C,OAAA,CAAA,aAAA,GAAA,aAAA;;AA4BgB,aAAA,CAAA,YAAA,GAAgB,QAAD,IAAuB;AAClD,QAAM,GAAG,GAAG,QAAQ,CAAC,OAAT,EAAZ;AACA,QAAM,iBAAiB,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAA1B;AACA,QAAM,kBAAkB,GAAG,GAAG,CAAC,IAAI,CAAC,iBAAN,CAA9B;;AACA,MAAI,kBAAJ,EAAwB;AACtB,IAAA,iBAAiB,CAAC,aAAlB,CAAgC,kBAAhC,EAAoD,CAApD;AACD;;AACD,QAAM,iBAAiB,GAAG,GAAG,CAAC,IAAI,CAAC,iBAAN,CAA7B;AACA,QAAM,aAAa,GAAG,iBAAiB,CAAC,GAAlB,CAAuB,IAAD,IAC1C,EAAA,CAAA,YAAA,CAAa,YAAb,CAA0B,IAA1B,CADoB,CAAtB;AAGA,SAAO,IAAI,aAAJ,CAAkB,iBAAlB,EAAqC,aAArC,CAAP;AACD,CAZa;;AAcA,aAAA,CAAA,QAAA,GAAY,YAAD,IAAyB;AAChD,QAAM,QAAQ,GAAG,KAAA,CAAA,gBAAA,CAAiB,YAAjB,CAAjB;AACA,SAAO,aAAa,CAAC,YAAd,CAA2B,QAA3B,CAAP;AACD,CAHa","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoAccount = void 0;\nconst _1 = require(\".\");\nconst lib_1 = require(\"./lib\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"masterFingerprint\"] = 1] = \"masterFingerprint\";\n    Keys[Keys[\"outputDescriptors\"] = 2] = \"outputDescriptors\";\n})(Keys || (Keys = {}));\nclass CryptoAccount extends RegistryItem_1.RegistryItem {\n    constructor(masterFingerprint, outputDescriptors) {\n        super();\n        this.masterFingerprint = masterFingerprint;\n        this.outputDescriptors = outputDescriptors;\n        this.getRegistryType = () => {\n            return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;\n        };\n        this.getMasterFingerprint = () => this.masterFingerprint;\n        this.getOutputDescriptors = () => this.outputDescriptors;\n        this.toDataItem = () => {\n            const map = {};\n            if (this.masterFingerprint) {\n                map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n            }\n            if (this.outputDescriptors) {\n                map[Keys.outputDescriptors] = this.outputDescriptors.map((item) => item.toDataItem());\n            }\n            return new lib_1.DataItem(map);\n        };\n    }\n}\nexports.CryptoAccount = CryptoAccount;\nCryptoAccount.fromDataItem = (dataItem) => {\n    const map = dataItem.getData();\n    const masterFingerprint = Buffer.alloc(4);\n    const _masterFingerprint = map[Keys.masterFingerprint];\n    if (_masterFingerprint) {\n        masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n    }\n    const outputDescriptors = map[Keys.outputDescriptors];\n    const cryptoOutputs = outputDescriptors.map((item) => _1.CryptoOutput.fromDataItem(item));\n    return new CryptoAccount(masterFingerprint, cryptoOutputs);\n};\nCryptoAccount.fromCBOR = (_cborPayload) => {\n    const dataItem = lib_1.decodeToDataItem(_cborPayload);\n    return CryptoAccount.fromDataItem(dataItem);\n};\n//# sourceMappingURL=CryptoAccount.js.map"]},"metadata":{},"sourceType":"script"}