{"ast":null,"code":"// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which\n// does not have browser (or, by proxy, React-Native) support.\nconst BN = require('bignumber.js');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst cbor = require('borc');\n\nconst constants = require('./constants');\n\nconst ethers = require('ethers');\n\nconst eip712 = require('ethers-eip712');\n\nconst keccak256 = require('js-sha3').keccak256;\n\nconst rlp = require('rlp-browser');\n\nconst secp256k1 = require('secp256k1');\n\nexports.buildEthereumMsgRequest = function (input) {\n  if (!input.payload || !input.protocol || !input.signerPath) throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');\n  if (input.signerPath.length > 5 || input.signerPath.length < 2) throw new Error('Please provide a signer path with 2-5 indices');\n  const req = {\n    schema: constants.signingSchema.ETH_MSG,\n    payload: null,\n    input,\n    // Save the input for later\n    msg: null // Save the buffered message for later\n\n  };\n\n  try {\n    switch (input.protocol) {\n      case 'signPersonal':\n        return buildPersonalSignRequest(req, input);\n\n      case 'eip712':\n        if (!input.fwConstants.eip712Supported) throw new Error('EIP712 is not supported by your Lattice firmware version. Please upgrade.');\n        return buildEIP712Request(req, input);\n\n      default:\n        throw new Error('Unsupported protocol');\n    }\n  } catch (err) {\n    return {\n      err: err.toString()\n    };\n  }\n};\n\nexports.validateEthereumMsgResponse = function (res, req) {\n  const {\n    signer,\n    sig\n  } = res;\n  const {\n    input,\n    msg,\n    prehash = null\n  } = req;\n\n  if (input.protocol === 'signPersonal') {\n    // NOTE: We are currently hardcoding networkID=1 and useEIP155=false but these\n    //       may be configurable in future versions\n    const hash = prehash ? prehash : Buffer.from(keccak256(Buffer.concat([get_personal_sign_prefix(msg.length), msg])), 'hex');\n    return addRecoveryParam(hash, sig, signer, 1, false);\n  } else if (input.protocol === 'eip712') {\n    const digest = prehash ? prehash : eip712.TypedDataUtils.encodeDigest(req.input.payload);\n    return addRecoveryParam(digest, sig, signer);\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n};\n\nexports.buildEthereumTxRequest = function (data) {\n  try {\n    let {\n      chainId = 1\n    } = data;\n    const {\n      signerPath,\n      eip155 = null,\n      fwConstants\n    } = data;\n    const {\n      extraDataFrameSz,\n      extraDataMaxFrames,\n      prehashAllowed\n    } = fwConstants;\n    const EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;\n    const MAX_BASE_DATA_SZ = fwConstants.ethMaxDataSz;\n    const VAR_PATH_SZ = fwConstants.varAddrPathSzAllowed; // Sanity checks:\n    // There are a handful of named chains we allow the user to reference (`chainIds`)\n    // Custom chainIDs should be either numerical or hex strings\n\n    if (typeof chainId !== 'number' && isValidChainIdHexNumStr(chainId) === false) chainId = chainIds[chainId]; // If this was not a custom chainID and we cannot find the name of it, exit\n\n    if (!chainId) throw new Error('Unsupported chain ID or name'); // Sanity check on signePath\n\n    if (!signerPath) throw new Error('`signerPath` not provided'); // Determine if we should use EIP155 given the chainID.\n    // If we are explicitly told to use eip155, we will use it. Otherwise,\n    // we will look up if the specified chainId is associated with a chain\n    // that does not use EIP155 by default. Note that most do use EIP155.\n\n    let useEIP155 = chainUsesEIP155(chainId);\n    if (eip155 !== null && typeof eip155 === 'boolean') useEIP155 = eip155; // Hack for metamask, which sends value=null for 0 ETH transactions\n\n    if (!data.value) data.value = 0; //--------------\n    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING\n    //--------------\n    // Ensure all fields are 0x-prefixed hex strings\n\n    const rawTx = []; // Build the transaction buffer array\n\n    const nonceBytes = ensureHexBuffer(data.nonce);\n    const gasPriceBytes = ensureHexBuffer(data.gasPrice);\n    const gasLimitBytes = ensureHexBuffer(data.gasLimit);\n    const toBytes = ensureHexBuffer(data.to);\n    const valueBytes = ensureHexBuffer(data.value);\n    const dataBytes = ensureHexBuffer(data.data);\n    rawTx.push(nonceBytes);\n    rawTx.push(gasPriceBytes);\n    rawTx.push(gasLimitBytes);\n    rawTx.push(toBytes);\n    rawTx.push(valueBytes);\n    rawTx.push(dataBytes); // Add empty v,r,s values\n\n    if (useEIP155 === true) {\n      rawTx.push(ensureHexBuffer(chainId)); // v\n\n      rawTx.push(ensureHexBuffer(null)); // r\n\n      rawTx.push(ensureHexBuffer(null)); // s\n    } //--------------\n    // 2. BUILD THE LATTICE REQUEST PAYLOAD\n    //--------------\n\n\n    const ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params\n\n    const txReqPayload = Buffer.alloc(MAX_BASE_DATA_SZ + ETH_TX_NON_DATA_SZ);\n    let off = 0; // 1. EIP155 switch and chainID\n    //------------------\n\n    txReqPayload.writeUInt8(Number(useEIP155), off);\n    off++; // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger\n    // chainID values. To account for these, we will put the chainID into the `data` buffer if it\n    // is >=255. Values up to UINT64_MAX will be allowed.\n\n    let chainIdBuf;\n    let chainIdBufSz = 0;\n\n    if (useChainIdBuffer(chainId) === true) {\n      chainIdBuf = getChainIdBuf(chainId);\n      chainIdBufSz = chainIdBuf.length;\n      if (chainIdBufSz > constants.MAX_CHAIN_ID_BYTES) throw new Error('ChainID provided is too large.'); // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer\n\n      txReqPayload.writeUInt8(constants.HANDLE_LARGER_CHAIN_ID, off);\n      off++;\n    } else {\n      // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer\n      chainIdBuf = ensureHexBuffer(chainId);\n      if (chainIdBuf.length !== 1) throw new Error('Error parsing chainID');\n      chainIdBuf.copy(txReqPayload, off);\n      off += chainIdBuf.length;\n    } // 2. Signer Path\n    //------------------\n\n\n    const signerPathBuf = buildSignerPathBuf(signerPath, VAR_PATH_SZ);\n    signerPathBuf.copy(txReqPayload, off);\n    off += signerPathBuf.length; // 3. ETH TX request data\n    //------------------\n\n    if (nonceBytes.length > 4) throw new Error('Nonce too large');\n    nonceBytes.copy(txReqPayload, off + (4 - nonceBytes.length));\n    off += 4;\n    if (gasPriceBytes.length > 8) throw new Error('Gas price too large');\n    gasPriceBytes.copy(txReqPayload, off + (8 - gasPriceBytes.length));\n    off += 8;\n    if (gasLimitBytes.length > 4) throw new Error('Gas limit too large');\n    gasLimitBytes.copy(txReqPayload, off + (4 - gasLimitBytes.length));\n    off += 4;\n    if (toBytes.length !== 20) throw new Error('Invalid `to` address');\n    toBytes.copy(txReqPayload, off);\n    off += 20;\n    if (valueBytes.length > 32) throw new Error('Value too large');\n    valueBytes.copy(txReqPayload, off + (32 - valueBytes.length));\n    off += 32; // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable    \n\n    const extraDataPayloads = [];\n    let prehash = null;\n\n    if (dataBytes && dataBytes.length > MAX_BASE_DATA_SZ) {\n      // Determine sizes and run through sanity checks\n      const chainIdExtraSz = chainIdBufSz > 0 ? chainIdBufSz + 1 : 0;\n      const totalSz = dataBytes.length + chainIdExtraSz;\n      const maxSzAllowed = MAX_BASE_DATA_SZ + extraDataMaxFrames * extraDataFrameSz; // Copy the data into a tmp buffer. Account for larger chain ID sizes if applicable.\n\n      const dataToCopy = Buffer.alloc(dataBytes.length + chainIdExtraSz);\n\n      if (chainIdExtraSz > 0) {\n        dataToCopy.writeUInt8(chainIdBufSz, 0);\n        chainIdBuf.copy(dataToCopy, 1);\n        dataBytes.copy(dataToCopy, chainIdExtraSz);\n      } else {\n        dataBytes.copy(dataToCopy, 0);\n      }\n\n      if (prehashAllowed && totalSz > maxSzAllowed) {\n        // If this payload is too large to send, but the Lattice allows a prehashed message, do that\n        prehash = Buffer.from(keccak256(rlp.encode(rawTx)), 'hex');\n      } else {\n        if (!EXTRA_DATA_ALLOWED || EXTRA_DATA_ALLOWED && totalSz > maxSzAllowed) throw new Error(`Data field too large (got ${dataBytes.length}; must be <=${maxSzAllowed - chainIdExtraSz} bytes)`); // Split overflow data into extraData frames\n\n        const frames = splitFrames(dataToCopy.slice(MAX_BASE_DATA_SZ), extraDataFrameSz);\n        frames.forEach(frame => {\n          const szLE = Buffer.alloc(4);\n          szLE.writeUInt32LE(frame.length);\n          extraDataPayloads.push(Buffer.concat([szLE, frame]));\n        });\n      }\n    } // Write the data size (does *NOT* include the chainId buffer, if that exists)\n\n\n    txReqPayload.writeUInt16BE(dataBytes.length, off);\n    off += 2; // Copy in the chainId buffer if needed\n\n    if (chainIdBufSz > 0) {\n      txReqPayload.writeUInt8(chainIdBufSz, off);\n      off++;\n      chainIdBuf.copy(txReqPayload, off);\n      off += chainIdBufSz;\n    } // Copy the first slice of the data itself. If this payload has been pre-hashed, include it\n    // in the `data` field. This will result in a different Lattice screen being drawn.\n\n\n    if (prehash) {\n      prehash.copy(txReqPayload, off);\n      off += MAX_BASE_DATA_SZ;\n    } else {\n      dataBytes.slice(0, MAX_BASE_DATA_SZ).copy(txReqPayload, off);\n      off += MAX_BASE_DATA_SZ;\n    }\n\n    return {\n      rawTx,\n      payload: txReqPayload.slice(0, off),\n      extraDataPayloads,\n      schema: constants.signingSchema.ETH_TRANSFER,\n      // We will use eth transfer for all ETH txs for v1 \n      chainId,\n      useEIP155,\n      signerPath\n    };\n  } catch (err) {\n    return {\n      err: err.message\n    };\n  }\n}; // From ethereumjs-util\n\n\nfunction stripZeros(a) {\n  let first = a[0];\n\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n\n  return a;\n} // Given a 64-byte signature [r,s] we need to figure out the v value\n// and attah the full signature to the end of the transaction payload\n\n\nexports.buildEthRawTx = function (tx, sig, address, useEIP155 = true) {\n  // RLP-encode the data we sent to the lattice\n  const rlpEncoded = rlp.encode(tx.rawTx);\n  const hash = Buffer.from(keccak256(rlpEncoded), 'hex');\n  const newSig = addRecoveryParam(hash, sig, address, tx.chainId, useEIP155); // Use the signature to generate a new raw transaction payload\n\n  const newRawTx = tx.rawTx.slice(0, 6);\n  newRawTx.push(newSig.v); // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros\n  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187\n\n  newRawTx.push(stripZeros(newSig.r));\n  newRawTx.push(stripZeros(newSig.s));\n  return rlp.encode(newRawTx).toString('hex');\n}; // Attach a recovery parameter to a signature by brute-forcing ECRecover\n\n\nfunction addRecoveryParam(hashBuf, sig, address, chainId, useEIP155) {\n  try {\n    // Rebuild the keccak256 hash here so we can `ecrecover`\n    const hash = new Uint8Array(hashBuf);\n    let v = 0; // Fix signature componenet lengths to 32 bytes each\n\n    const r = fixLen(sig.r, 32);\n    sig.r = r;\n    const s = fixLen(sig.s, 32);\n    sig.s = s; // Calculate the recovery param\n\n    const rs = new Uint8Array(Buffer.concat([r, s]));\n    let pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1); // If the first `v` value is a match, return the sig!\n\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    } // Otherwise, try the other `v` value\n\n\n    v = 1;\n    pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1);\n\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    } else {\n      // If neither is a match, we should return an error\n      throw new Error('Invalid Ethereum signature returned.');\n    }\n  } catch (err) {\n    throw new Error(err);\n  }\n} // Convert an RLP-serialized transaction (plus signature) into a transaction hash\n\n\nexports.hashTransaction = function (serializedTx) {\n  return keccak256(Buffer.from(serializedTx, 'hex'));\n}; // Returns address string given public key buffer\n\n\nfunction pubToAddrStr(pub) {\n  return keccak256(pub).slice(-40);\n}\n\nfunction fixLen(msg, length) {\n  const buf = Buffer.alloc(length);\n\n  if (msg.length < length) {\n    msg.copy(buf, length - msg.length);\n    return buf;\n  }\n\n  return msg.slice(-length);\n} // Convert a 0/1 `v` into a recovery param:\n// * For non-EIP155 transactions, return `27 + v`\n// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`\n\n\nfunction getRecoveryParam(v, useEIP155, chainId = null) {\n  // If we are not using EIP155, convert v directly to a buffer and return it\n  if (false === useEIP155 || chainId === null) return Buffer.from(new BN(v).plus(27).toString(16), 'hex'); // We will use EIP155 in most cases. Convert v to a bignum and operate on it.\n  // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36\n  // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1\n  // so we add 35 to that.\n\n  const chainIdBuf = getChainIdBuf(chainId);\n  const chainIdBN = new BN(chainIdBuf.toString('hex'), 16);\n  return ensureHexBuffer(`0x${chainIdBN.times(2).plus(35).plus(v).toString(16)}`);\n}\n\nfunction isHexStr(str) {\n  return /^[0-9a-fA-F]+$/.test(str);\n}\n\nfunction isASCIIStr(str) {\n  return /^[\\x00-\\x7F]+$/.test(str);\n} // Determine if the Lattice can display a string we give it. Currently, the Lattice can only\n// display ASCII strings, so we will reject other UTF8 codes.\n// In the future we may add a mechanism to display certain UTF8 codes such as popular emojis.\n\n\nfunction latticeCanDisplayStr(str) {\n  for (let i = 0; i < str.length; i++) if (str.charCodeAt(i) < 0x0020 || str.charCodeAt(i) > 0x007f) return false;\n\n  return true;\n}\n\nconst chainIds = {\n  mainnet: 1,\n  roptsten: 3,\n  rinkeby: 4,\n  kovan: 42,\n  goerli: 5\n}; // Get a buffer containing the chainId value.\n// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian\n\nfunction getChainIdBuf(chainId) {\n  let b; // If our chainID is a hex string, we can convert it to a hex\n  // buffer directly\n\n  if (true === isValidChainIdHexNumStr(chainId)) b = ensureHexBuffer(chainId); // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer\n  else b = ensureHexBuffer(`0x${new BN(chainId).toString(16)}`); // Make sure the buffer is an allowed size\n\n  if (b.length > 8) throw new Error('ChainID provided is too large.'); // If this matches a u16, u32, or u64 size, return it now\n\n  if (b.length <= 2 || b.length === 4 || b.length === 8) return b; // For other size buffers, we need to pack into u32 or u64 before returning;\n\n  let buf;\n\n  if (b.length === 3) {\n    buf = Buffer.alloc(4);\n    buf.writeUInt32BE(chainId);\n  } else if (b.length <= 8) {\n    buf = Buffer.alloc(8);\n    b.copy(buf, 8 - b.length);\n  }\n\n  return buf;\n} // Determine if the chain uses EIP155 by default, based on the chainID\n\n\nfunction chainUsesEIP155(chainID) {\n  switch (chainID) {\n    case 3: // ropsten\n\n    case 4:\n      // rinkeby\n      return false;\n\n    case 1: // mainnet\n\n    case 42: // kovan\n\n    case 5: // goerli\n\n    default:\n      // all others should use eip155\n      return true;\n  }\n} // Determine if a valid number was passed in as a hex string\n\n\nfunction isValidChainIdHexNumStr(s) {\n  if (typeof s !== 'string') return false;\n  if (s.slice(0, 2) !== '0x') return false;\n\n  try {\n    const b = new BN(s, 16);\n    return b.isNaN() === false;\n  } catch (err) {\n    return false;\n  }\n} // If this is a nubmer that fits in one byte, we don't need to add it\n// to the `data` buffer of the main transaction. \n// Note the one edge case: we still need to use the `data` field for chainID=255.\n\n\nfunction useChainIdBuffer(id) {\n  const buf = getChainIdBuf(id);\n  if (buf.length === 1) return buf.readUInt8(0) === 255;\n  return true;\n}\n\nexports.chainIds = chainIds;\n\nfunction isBase10NumStr(x) {\n  const bn = new BN(x).toString().split('.').join('');\n  const s = new String(x); // Note that the JS native `String()` loses precision for large numbers, but we only\n  // want to validate the base of the number so we don't care about far out precision.\n\n  return bn.slice(0, 8) === s.slice(0, 8);\n} // Ensure a param is represented by a buffer\n// TODO: Remove circular dependency in util.js so that we can put this function there\n\n\nfunction ensureHexBuffer(x, zeroIsNull = true) {\n  try {\n    // For null values, return a 0-sized buffer. For most situations we assume\n    // 0 should be represented with a zero-length buffer (e.g. for RLP-building\n    // txs), but it can also be treated as a 1-byte buffer (`00`) if needed\n    if (x === null || x === 0 && zeroIsNull === true) return Buffer.alloc(0);\n    const isNumber = typeof x === 'number' || isBase10NumStr(x); // Otherwise try to get this converted to a hex string\n\n    if (isNumber) {\n      // If this is a number or a base-10 number string, convert it to hex\n      x = `${new BN(x).toString(16)}`;\n    } else if (typeof x === 'string' && x.slice(0, 2) === '0x') {\n      x = x.slice(2);\n    } else {\n      x = x.toString('hex');\n    }\n\n    if (x.length % 2 > 0) x = `0${x}`;\n    if (x === '00' && !isNumber) return Buffer.alloc(0);\n    return Buffer.from(x, 'hex');\n  } catch (err) {\n    throw new Error(`Cannot convert ${x.toString()} to hex buffer (${err.toString()})`);\n  }\n}\n\nexports.ensureHexBuffer = ensureHexBuffer;\n\nfunction buildPersonalSignRequest(req, input) {\n  const MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;\n  const VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;\n  const L = 24 + MAX_BASE_MSG_SZ + 4;\n  let off = 0;\n  req.payload = Buffer.alloc(L);\n  req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0);\n  off += 1; // Write the signer path into the buffer\n\n  const signerPathBuf = buildSignerPathBuf(input.signerPath, VAR_PATH_SZ);\n  signerPathBuf.copy(req.payload, off);\n  off += signerPathBuf.length; // Write the payload buffer. The payload can come in either as a buffer or as a string\n\n  let payload = input.payload; // Determine if this is a hex string\n\n  let displayHex = false;\n\n  if (typeof input.payload === 'string') {\n    if (input.payload.slice(0, 2) === '0x') {\n      payload = ensureHexBuffer(input.payload);\n      displayHex = false === isASCIIStr(Buffer.from(input.payload.slice(2), 'hex').toString());\n    } else {\n      if (false === latticeCanDisplayStr(input.payload)) throw new Error('Currently, the Lattice can only display ASCII strings.');\n      payload = Buffer.from(input.payload);\n    }\n  } else if (typeof input.displayHex === 'boolean') {\n    // If this is a buffer and the user has specified whether or not this\n    // is a hex buffer with the optional argument, write that\n    displayHex = input.displayHex;\n  } else {\n    // Otherwise, determine if this buffer is an ASCII string. If it is, set `displayHex` accordingly.\n    // NOTE: THIS MEANS THAT NON-ASCII STRINGS WILL DISPLAY AS HEX SINCE WE CANNOT KNOW IF THE REQUESTER\n    //        EXPECTED NON-ASCII CHARACTERS TO DISPLAY IN A STRING\n    // TODO: Develop a more elegant solution for this\n    if (!input.payload.toString) throw new Error('Unsupported input data type');\n    displayHex = false === isASCIIStr(input.payload.toString());\n  }\n\n  const fwConst = input.fwConstants;\n  const maxSzAllowed = MAX_BASE_MSG_SZ + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;\n\n  if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {\n    // If this message will not fit and pre-hashing is allowed, do that\n    req.payload.writeUInt8(displayHex, off);\n    off += 1;\n    req.payload.writeUInt16LE(payload.length, off);\n    off += 2;\n    const prehash = Buffer.from(keccak256(Buffer.concat([get_personal_sign_prefix(payload.length), payload])), 'hex');\n    prehash.copy(req.payload, off);\n    req.prehash = prehash;\n  } else {\n    // Otherwise we can fit the payload.\n    // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable    \n    const extraDataPayloads = getExtraData(payload, input); // Write the payload and metadata into our buffer\n\n    req.extraDataPayloads = extraDataPayloads;\n    req.msg = payload;\n    req.payload.writeUInt8(displayHex, off);\n    off += 1;\n    req.payload.writeUInt16LE(payload.length, off);\n    off += 2;\n    payload.copy(req.payload, off);\n  }\n\n  return req;\n}\n\nfunction buildEIP712Request(req, input) {\n  try {\n    const MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;\n    const VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;\n    const TYPED_DATA = constants.ethMsgProtocol.TYPED_DATA;\n    const L = 24 + MAX_BASE_MSG_SZ + 4;\n    let off = 0;\n    req.payload = Buffer.alloc(L);\n    req.payload.writeUInt8(TYPED_DATA.enumIdx, 0);\n    off += 1; // Write the signer path\n\n    const signerPathBuf = buildSignerPathBuf(input.signerPath, VAR_PATH_SZ);\n    signerPathBuf.copy(req.payload, off);\n    off += signerPathBuf.length; // Parse/clean the EIP712 payload, serialize with CBOR, and write to the payload\n\n    const data = JSON.parse(JSON.stringify(input.payload));\n    if (!data.primaryType || !data.types[data.primaryType]) throw new Error('primaryType must be specified and the type must be included.');\n    if (!data.message || !data.domain) throw new Error('message and domain must be specified.');\n    if (0 > Object.keys(data.types).indexOf('EIP712Domain')) throw new Error('EIP712Domain type must be defined.'); // Parse the payload to ensure we have valid EIP712 data types and that\n    // they are encoded such that Lattice firmware can parse them.\n    // We need two different encodings:\n    // 1. Use `ethers` BigNumber when building the request to be validated by ethers-eip712.\n    //    Make sure we use a copy of the data to avoid mutation problems\n\n    input.payload.message = parseEIP712Msg(JSON.parse(JSON.stringify(data.message)), JSON.parse(JSON.stringify(data.primaryType)), JSON.parse(JSON.stringify(data.types)), true);\n    input.payload.domain = parseEIP712Msg(JSON.parse(JSON.stringify(data.domain)), 'EIP712Domain', JSON.parse(JSON.stringify(data.types)), true); // 2. Use `bignumber.js` for the request going to the Lattice, since it's the required\n    //    BigNumber lib for `cbor`, which we use to encode the request data to the Lattice.\n\n    data.domain = parseEIP712Msg(data.domain, 'EIP712Domain', data.types, false);\n    data.message = parseEIP712Msg(data.message, data.primaryType, data.types, false); // Now build the message to be sent to the Lattice\n\n    const payload = Buffer.from(cbor.encode(data));\n    const fwConst = input.fwConstants;\n    const maxSzAllowed = MAX_BASE_MSG_SZ + fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz;\n\n    if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {\n      // If this payload is too large to send, but the Lattice allows a prehashed message, do that\n      req.payload.writeUInt16LE(payload.length, off);\n      off += 2;\n      const prehash = Buffer.from(keccak256(eip712.TypedDataUtils.encodeDigest(req.input.payload), 'hex'), 'hex');\n      prehash.copy(req.payload, off);\n      req.prehash = prehash;\n    } else {\n      const extraDataPayloads = getExtraData(payload, input);\n      req.extraDataPayloads = extraDataPayloads;\n      req.payload.writeUInt16LE(payload.length, off);\n      off += 2;\n      payload.copy(req.payload, off);\n      off += payload.length; // Slice out the part of the buffer that we didn't use.\n\n      req.payload = req.payload.slice(0, off);\n    }\n\n    return req;\n  } catch (err) {\n    return {\n      err: `Failed to build EIP712 request: ${err.message}`\n    };\n  }\n}\n\nfunction buildSignerPathBuf(signerPath, varAddrPathSzAllowed) {\n  const buf = Buffer.alloc(24);\n  let off = 0;\n  if (varAddrPathSzAllowed && signerPath.length > 5) throw new Error('Signer path must be <=5 indices.');\n  if (!varAddrPathSzAllowed && signerPath.length !== 5) throw new Error('Your Lattice firmware only supports 5-index derivation paths. Please upgrade.');\n  buf.writeUInt32LE(signerPath.length, off);\n  off += 4;\n\n  for (let i = 0; i < 5; i++) {\n    if (i < signerPath.length) buf.writeUInt32LE(signerPath[i], off);else buf.writeUInt32LE(0, off);\n    off += 4;\n  }\n\n  return buf;\n}\n\nfunction getExtraData(payload, input) {\n  const {\n    ethMaxMsgSz,\n    extraDataFrameSz,\n    extraDataMaxFrames\n  } = input.fwConstants;\n  const MAX_BASE_MSG_SZ = ethMaxMsgSz;\n  const EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;\n  const extraDataPayloads = [];\n\n  if (payload.length > MAX_BASE_MSG_SZ) {\n    // Determine sizes and run through sanity checks\n    const maxSzAllowed = MAX_BASE_MSG_SZ + extraDataMaxFrames * extraDataFrameSz;\n    if (!EXTRA_DATA_ALLOWED) throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${MAX_BASE_MSG_SZ}`);else if (EXTRA_DATA_ALLOWED && payload.length > maxSzAllowed) throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${maxSzAllowed}`); // Split overflow data into extraData frames\n\n    const frames = splitFrames(payload.slice(MAX_BASE_MSG_SZ), extraDataFrameSz);\n    frames.forEach(frame => {\n      const szLE = Buffer.alloc(4);\n      szLE.writeUInt32LE(frame.length);\n      extraDataPayloads.push(Buffer.concat([szLE, frame]));\n    });\n  }\n\n  return extraDataPayloads;\n}\n\nfunction splitFrames(data, frameSz) {\n  const frames = [];\n  const n = Math.ceil(data.length / frameSz);\n  let off = 0;\n\n  for (let i = 0; i < n; i++) {\n    frames.push(data.slice(off, off + frameSz));\n    off += frameSz;\n  }\n\n  return frames;\n}\n\nfunction parseEIP712Msg(msg, typeName, types, isEthers = false) {\n  try {\n    const type = types[typeName];\n    type.forEach(item => {\n      const isCustomType = Object.keys(types).indexOf(item.type) > -1;\n\n      if (true === isCustomType) {\n        msg[item.name] = parseEIP712Msg(msg[item.name], item.type, types, isEthers);\n      } else {\n        msg[item.name] = parseEIP712Item(msg[item.name], item.type, isEthers);\n      }\n    });\n  } catch (err) {\n    throw new Error(err.message);\n  }\n\n  return msg;\n}\n\nfunction parseEIP712Item(data, type, isEthers = false) {\n  if (type === 'bytes') {\n    // Variable sized bytes need to be buffer type\n    data = ensureHexBuffer(data);\n  } else if (type.slice(0, 5) === 'bytes') {\n    // Fixed sizes bytes need to be buffer type. We also add some sanity checks.\n    const nBytes = parseInt(type.slice(5));\n    data = ensureHexBuffer(data);\n    if (data.length !== nBytes) throw new Error(`Expected ${type} type, but got ${data.length} bytes`);\n  } else if (type === 'address') {\n    // Address must be a 20 byte buffer\n    data = ensureHexBuffer(data); // Edge case to handle the 0-address\n\n    if (data.length === 0) {\n      data = Buffer.alloc(20);\n    }\n\n    if (data.length !== 20) throw new Error(`Address type must be 20 bytes, but got ${data.length} bytes`); // Ethers wants addresses as hex strings\n\n    if (isEthers === true) {\n      data = `0x${data.toString('hex')}`;\n    }\n  } else if (constants.ethMsgProtocol.TYPED_DATA.typeCodes[type] && (type.indexOf('uint') > -1 || type.indexOf('int') > -1)) {\n    let b = ensureHexBuffer(data); // Edge case to handle 0-value bignums\n\n    if (b.length === 0) {\n      b = Buffer.from('00', 'hex');\n    } // Uint256s should be encoded as bignums.\n\n\n    if (isEthers === true) {\n      // `ethers` uses their own BigNumber lib\n      data = ethers.BigNumber.from(`0x${b.toString('hex')}`);\n    } else {\n      // `bignumber.js` is needed for `cbor` encoding, which gets sent to the Lattice and plays\n      // nicely with its firmware cbor lib.\n      // NOTE: If we instantiate a `bignumber.js` object, it will not match what `borc` creates\n      // when run inside of the browser (i.e. MetaMask). Thus we introduce this hack to make sure\n      // we are creating a compatible type.\n      // TODO: Find another cbor lib that is compataible with the firmware's lib in a browser\n      // context. This is surprisingly difficult - I tried several libs and only cbor/borc have\n      // worked (borc is a supposedly \"browser compatible\" version of cbor)\n      data = new cbor.Encoder().semanticTypes[1][0](b.toString('hex'), 16);\n    }\n  } else if (type === 'bool') {\n    // Booleans need to be cast to a u8\n    data = data === true ? 1 : 0;\n  } // Other types don't need to be modified\n\n\n  return data;\n}\n\nfunction get_personal_sign_prefix(L) {\n  return Buffer.from(`\\u0019Ethereum Signed Message:\\n${L.toString()}`, 'utf-8');\n}","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/gridplus-sdk/src/ethereum.js"],"names":["BN","require","Buffer","cbor","constants","ethers","eip712","keccak256","rlp","secp256k1","exports","buildEthereumMsgRequest","input","payload","protocol","signerPath","Error","length","req","schema","signingSchema","ETH_MSG","msg","buildPersonalSignRequest","fwConstants","eip712Supported","buildEIP712Request","err","toString","validateEthereumMsgResponse","res","signer","sig","prehash","hash","from","concat","get_personal_sign_prefix","addRecoveryParam","digest","TypedDataUtils","encodeDigest","buildEthereumTxRequest","data","chainId","eip155","extraDataFrameSz","extraDataMaxFrames","prehashAllowed","EXTRA_DATA_ALLOWED","MAX_BASE_DATA_SZ","ethMaxDataSz","VAR_PATH_SZ","varAddrPathSzAllowed","isValidChainIdHexNumStr","chainIds","useEIP155","chainUsesEIP155","value","rawTx","nonceBytes","ensureHexBuffer","nonce","gasPriceBytes","gasPrice","gasLimitBytes","gasLimit","toBytes","to","valueBytes","dataBytes","push","ETH_TX_NON_DATA_SZ","txReqPayload","alloc","off","writeUInt8","Number","chainIdBuf","chainIdBufSz","useChainIdBuffer","getChainIdBuf","MAX_CHAIN_ID_BYTES","HANDLE_LARGER_CHAIN_ID","copy","signerPathBuf","buildSignerPathBuf","extraDataPayloads","chainIdExtraSz","totalSz","maxSzAllowed","dataToCopy","encode","frames","splitFrames","slice","forEach","frame","szLE","writeUInt32LE","writeUInt16BE","ETH_TRANSFER","message","stripZeros","a","first","buildEthRawTx","tx","address","rlpEncoded","newSig","newRawTx","v","r","s","hashBuf","Uint8Array","fixLen","rs","pubkey","ecdsaRecover","pubToAddrStr","getRecoveryParam","hashTransaction","serializedTx","pub","buf","plus","chainIdBN","times","isHexStr","str","test","isASCIIStr","latticeCanDisplayStr","i","charCodeAt","mainnet","roptsten","rinkeby","kovan","goerli","b","writeUInt32BE","chainID","isNaN","id","readUInt8","isBase10NumStr","x","bn","split","join","String","zeroIsNull","isNumber","MAX_BASE_MSG_SZ","ethMaxMsgSz","L","ethMsgProtocol","SIGN_PERSONAL","displayHex","fwConst","ethMsgPreHashAllowed","writeUInt16LE","getExtraData","TYPED_DATA","enumIdx","JSON","parse","stringify","primaryType","types","domain","Object","keys","indexOf","parseEIP712Msg","frameSz","n","Math","ceil","typeName","isEthers","type","item","isCustomType","name","parseEIP712Item","nBytes","parseInt","typeCodes","BigNumber","Encoder","semanticTypes"],"mappings":"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","sourcesContent":["// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which\n// does not have browser (or, by proxy, React-Native) support.\nconst BN = require('bignumber.js');\nconst Buffer = require('buffer/').Buffer;\nconst cbor = require('borc');\nconst constants = require('./constants');\nconst ethers = require('ethers');\nconst eip712 = require('ethers-eip712');\nconst keccak256 = require('js-sha3').keccak256;\nconst rlp = require('rlp-browser');\nconst secp256k1 = require('secp256k1');\n\nexports.buildEthereumMsgRequest = function(input) {\n  if (!input.payload || !input.protocol || !input.signerPath)\n    throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');\n  if (input.signerPath.length > 5 || input.signerPath.length < 2) \n    throw new Error('Please provide a signer path with 2-5 indices');\n  const req = {\n    schema: constants.signingSchema.ETH_MSG,\n    payload: null,\n    input, // Save the input for later\n    msg: null, // Save the buffered message for later\n  }\n  try {\n    switch (input.protocol) {\n      case 'signPersonal':\n        return buildPersonalSignRequest(req, input)\n      case 'eip712':\n        if (!input.fwConstants.eip712Supported)\n          throw new Error('EIP712 is not supported by your Lattice firmware version. Please upgrade.')\n        return buildEIP712Request(req, input)\n      default:\n        throw new Error('Unsupported protocol');\n    }\n  } catch (err) {\n    return { err: err.toString() }\n  }\n}\n\nexports.validateEthereumMsgResponse = function(res, req) {\n  const { signer, sig } = res;\n  const { input, msg, prehash=null } = req;\n  if (input.protocol === 'signPersonal') {\n    // NOTE: We are currently hardcoding networkID=1 and useEIP155=false but these\n    //       may be configurable in future versions\n    const hash =  prehash ? \n                  prehash : \n                  Buffer.from(keccak256(Buffer.concat([get_personal_sign_prefix(msg.length), msg])), 'hex');\n    return addRecoveryParam(hash, sig, signer, 1, false)\n  } else if (input.protocol === 'eip712') {\n    const digest = prehash ? prehash : eip712.TypedDataUtils.encodeDigest(req.input.payload);\n    return addRecoveryParam(digest, sig, signer)\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n}\n\nexports.buildEthereumTxRequest = function(data) {\n  try {\n    let { chainId=1 } = data;\n    const { signerPath, eip155=null, fwConstants } = data;\n    const { extraDataFrameSz, extraDataMaxFrames, prehashAllowed } = fwConstants;\n    const EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;\n    const MAX_BASE_DATA_SZ = fwConstants.ethMaxDataSz;\n    const VAR_PATH_SZ = fwConstants.varAddrPathSzAllowed;\n\n    // Sanity checks:\n    // There are a handful of named chains we allow the user to reference (`chainIds`)\n    // Custom chainIDs should be either numerical or hex strings\n    if (typeof chainId !== 'number' && isValidChainIdHexNumStr(chainId) === false) \n      chainId = chainIds[chainId];\n    // If this was not a custom chainID and we cannot find the name of it, exit\n    if (!chainId) \n      throw new Error('Unsupported chain ID or name');\n    // Sanity check on signePath\n    if (!signerPath) \n      throw new Error('`signerPath` not provided');\n\n    // Determine if we should use EIP155 given the chainID.\n    // If we are explicitly told to use eip155, we will use it. Otherwise,\n    // we will look up if the specified chainId is associated with a chain\n    // that does not use EIP155 by default. Note that most do use EIP155.\n    let useEIP155 = chainUsesEIP155(chainId);\n    if (eip155 !== null && typeof eip155 === 'boolean')\n      useEIP155 = eip155;\n\n    // Hack for metamask, which sends value=null for 0 ETH transactions\n    if (!data.value)\n      data.value = 0;\n      \n    //--------------\n    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING\n    //--------------\n\n    // Ensure all fields are 0x-prefixed hex strings\n    const rawTx = [];\n    // Build the transaction buffer array\n    const nonceBytes = ensureHexBuffer(data.nonce);\n    const gasPriceBytes = ensureHexBuffer(data.gasPrice);\n    const gasLimitBytes = ensureHexBuffer(data.gasLimit);\n    const toBytes = ensureHexBuffer(data.to);\n    const valueBytes = ensureHexBuffer(data.value);\n    const dataBytes = ensureHexBuffer(data.data);\n    rawTx.push(nonceBytes);\n    rawTx.push(gasPriceBytes);\n    rawTx.push(gasLimitBytes);\n    rawTx.push(toBytes);\n    rawTx.push(valueBytes);\n    rawTx.push(dataBytes);\n    // Add empty v,r,s values\n    if (useEIP155 === true) {\n      rawTx.push(ensureHexBuffer(chainId)); // v\n      rawTx.push(ensureHexBuffer(null));    // r\n      rawTx.push(ensureHexBuffer(null));    // s\n    }\n    //--------------\n    // 2. BUILD THE LATTICE REQUEST PAYLOAD\n    //--------------\n    const ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params\n    const txReqPayload = Buffer.alloc(MAX_BASE_DATA_SZ + ETH_TX_NON_DATA_SZ);\n    let off = 0;\n    // 1. EIP155 switch and chainID\n    //------------------\n    txReqPayload.writeUInt8(Number(useEIP155), off); off++;\n    // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger\n    // chainID values. To account for these, we will put the chainID into the `data` buffer if it\n    // is >=255. Values up to UINT64_MAX will be allowed.\n    let chainIdBuf; \n    let chainIdBufSz = 0;\n    if (useChainIdBuffer(chainId) === true) {\n      chainIdBuf = getChainIdBuf(chainId);\n      chainIdBufSz = chainIdBuf.length;\n      if (chainIdBufSz > constants.MAX_CHAIN_ID_BYTES)\n        throw new Error('ChainID provided is too large.');\n      // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer\n      txReqPayload.writeUInt8(constants.HANDLE_LARGER_CHAIN_ID, off); off++;\n    } else {\n      // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer\n      chainIdBuf = ensureHexBuffer(chainId);\n      if (chainIdBuf.length !== 1)\n        throw new Error('Error parsing chainID');\n      chainIdBuf.copy(txReqPayload, off); off += chainIdBuf.length;\n    }\n\n    // 2. Signer Path\n    //------------------\n    const signerPathBuf = buildSignerPathBuf(signerPath, VAR_PATH_SZ);\n    signerPathBuf.copy(txReqPayload, off);\n    off += signerPathBuf.length;\n\n    // 3. ETH TX request data\n    //------------------\n    if (nonceBytes.length > 4)\n      throw new Error('Nonce too large');\n    nonceBytes.copy(txReqPayload, off + (4 - nonceBytes.length)); off += 4;\n    if (gasPriceBytes.length > 8)\n      throw new Error('Gas price too large');\n    gasPriceBytes.copy(txReqPayload, off + (8 - gasPriceBytes.length)); off += 8;\n    if (gasLimitBytes.length > 4)\n      throw new Error('Gas limit too large');\n    gasLimitBytes.copy(txReqPayload, off + (4 - gasLimitBytes.length)); off += 4;\n    if (toBytes.length !== 20)\n      throw new Error('Invalid `to` address');\n    toBytes.copy(txReqPayload, off); off += 20;\n    if (valueBytes.length > 32)\n      throw new Error('Value too large');\n    valueBytes.copy(txReqPayload, off + (32 - valueBytes.length)); off += 32;\n    // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable    \n    const extraDataPayloads = [];\n    let prehash = null;\n    if (dataBytes && dataBytes.length > MAX_BASE_DATA_SZ) {\n      // Determine sizes and run through sanity checks\n      const chainIdExtraSz = chainIdBufSz > 0 ? chainIdBufSz + 1 : 0;\n      const totalSz = dataBytes.length + chainIdExtraSz;\n      const maxSzAllowed = MAX_BASE_DATA_SZ + (extraDataMaxFrames * extraDataFrameSz);\n\n      // Copy the data into a tmp buffer. Account for larger chain ID sizes if applicable.\n      const dataToCopy = Buffer.alloc(dataBytes.length + chainIdExtraSz)\n      if (chainIdExtraSz > 0) {\n        dataToCopy.writeUInt8(chainIdBufSz, 0);\n        chainIdBuf.copy(dataToCopy, 1);\n        dataBytes.copy(dataToCopy, chainIdExtraSz);\n      } else {\n        dataBytes.copy(dataToCopy, 0);\n      }\n\n      if (prehashAllowed && totalSz > maxSzAllowed) {\n        // If this payload is too large to send, but the Lattice allows a prehashed message, do that\n        prehash = Buffer.from(keccak256(rlp.encode(rawTx)), 'hex')\n      } else {\n        if ((!EXTRA_DATA_ALLOWED) || (EXTRA_DATA_ALLOWED && totalSz > maxSzAllowed))\n          throw new Error(`Data field too large (got ${dataBytes.length}; must be <=${maxSzAllowed-chainIdExtraSz} bytes)`);\n        // Split overflow data into extraData frames\n        const frames = splitFrames(dataToCopy.slice(MAX_BASE_DATA_SZ), extraDataFrameSz);\n        frames.forEach((frame) => {\n          const szLE = Buffer.alloc(4);\n          szLE.writeUInt32LE(frame.length);\n          extraDataPayloads.push(Buffer.concat([szLE, frame]));\n        })\n      }\n    }\n    // Write the data size (does *NOT* include the chainId buffer, if that exists)\n    txReqPayload.writeUInt16BE(dataBytes.length, off); off += 2;\n    // Copy in the chainId buffer if needed\n    if (chainIdBufSz > 0) {\n      txReqPayload.writeUInt8(chainIdBufSz, off); off++;\n      chainIdBuf.copy(txReqPayload, off); off += chainIdBufSz;\n    }\n    // Copy the first slice of the data itself. If this payload has been pre-hashed, include it\n    // in the `data` field. This will result in a different Lattice screen being drawn.\n    if (prehash) {\n      prehash.copy(txReqPayload, off); off += MAX_BASE_DATA_SZ;\n    } else {\n      dataBytes.slice(0, MAX_BASE_DATA_SZ).copy(txReqPayload, off); off += MAX_BASE_DATA_SZ;\n    }\n    return {\n      rawTx,\n      payload: txReqPayload.slice(0, off),\n      extraDataPayloads,\n      schema: constants.signingSchema.ETH_TRANSFER,  // We will use eth transfer for all ETH txs for v1 \n      chainId,\n      useEIP155,\n      signerPath,\n    };\n  } catch (err) {\n    return { err: err.message };\n  }\n}\n\n// From ethereumjs-util\nfunction stripZeros(a) {\n  let first = a[0]\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1)\n    first = a[0]\n  }\n  return a\n}\n\n// Given a 64-byte signature [r,s] we need to figure out the v value\n// and attah the full signature to the end of the transaction payload\nexports.buildEthRawTx = function(tx, sig, address, useEIP155=true) {\n  // RLP-encode the data we sent to the lattice\n  const rlpEncoded = rlp.encode(tx.rawTx);\n  const hash = Buffer.from(keccak256(rlpEncoded), 'hex')\n  const newSig = addRecoveryParam(hash, sig, address, tx.chainId, useEIP155);\n  // Use the signature to generate a new raw transaction payload\n  const newRawTx = tx.rawTx.slice(0, 6);\n  newRawTx.push(newSig.v);\n  // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros\n  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187\n  newRawTx.push(stripZeros(newSig.r));\n  newRawTx.push(stripZeros(newSig.s));\n  return rlp.encode(newRawTx).toString('hex');\n}\n\n// Attach a recovery parameter to a signature by brute-forcing ECRecover\nfunction addRecoveryParam(hashBuf, sig, address, chainId, useEIP155) {\n  try {\n    // Rebuild the keccak256 hash here so we can `ecrecover`\n    const hash = new Uint8Array(hashBuf);\n    let v = 0;\n    // Fix signature componenet lengths to 32 bytes each\n    const r = fixLen(sig.r, 32); sig.r = r;\n    const s = fixLen(sig.s, 32); sig.s = s;\n    // Calculate the recovery param\n    const rs = new Uint8Array(Buffer.concat([r, s]));\n    let pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1)\n    // If the first `v` value is a match, return the sig!\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v  = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    }\n    // Otherwise, try the other `v` value\n    v = 1;\n    pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1)\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v  = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    } else {\n      // If neither is a match, we should return an error\n      throw new Error('Invalid Ethereum signature returned.');\n    }\n  } catch (err) {\n    throw new Error(err);\n  }\n}\n\n// Convert an RLP-serialized transaction (plus signature) into a transaction hash\nexports.hashTransaction = function(serializedTx) {\n  return keccak256(Buffer.from(serializedTx, 'hex')); \n}\n\n// Returns address string given public key buffer\nfunction pubToAddrStr(pub) {\n  return keccak256(pub).slice(-40);\n}\n\nfunction fixLen(msg, length) {\n  const buf = Buffer.alloc(length)\n  if (msg.length < length) {\n    msg.copy(buf, length - msg.length)\n    return buf\n  }\n  return msg.slice(-length)\n}\n\n// Convert a 0/1 `v` into a recovery param:\n// * For non-EIP155 transactions, return `27 + v`\n// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`\nfunction getRecoveryParam(v, useEIP155, chainId=null) {\n  // If we are not using EIP155, convert v directly to a buffer and return it\n  if (false === useEIP155 || chainId === null)\n    return Buffer.from(new BN(v).plus(27).toString(16), 'hex');\n  // We will use EIP155 in most cases. Convert v to a bignum and operate on it.\n  // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36\n  // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1\n  // so we add 35 to that.\n  const chainIdBuf = getChainIdBuf(chainId);\n  const chainIdBN = new BN(chainIdBuf.toString('hex'), 16);\n  return ensureHexBuffer(`0x${chainIdBN.times(2).plus(35).plus(v).toString(16)}`);\n}\n\nfunction isHexStr(str) {\n  return (/^[0-9a-fA-F]+$/).test(str)\n}\n\nfunction isASCIIStr(str) {\n  return (/^[\\x00-\\x7F]+$/).test(str)\n}\n\n// Determine if the Lattice can display a string we give it. Currently, the Lattice can only\n// display ASCII strings, so we will reject other UTF8 codes.\n// In the future we may add a mechanism to display certain UTF8 codes such as popular emojis.\nfunction latticeCanDisplayStr(str) {\n  for (let i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) < 0x0020 || str.charCodeAt(i) > 0x007f)\n      return false;\n  return true;\n}\n\nconst chainIds = {\n  mainnet: 1,\n  roptsten: 3,\n  rinkeby: 4,\n  kovan: 42,\n  goerli: 5\n}\n\n// Get a buffer containing the chainId value.\n// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian\nfunction getChainIdBuf(chainId) {\n  let b;\n  // If our chainID is a hex string, we can convert it to a hex\n  // buffer directly\n  if (true === isValidChainIdHexNumStr(chainId))\n    b = ensureHexBuffer(chainId);\n  // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer\n  else\n    b = ensureHexBuffer(`0x${new BN(chainId).toString(16)}`);\n  // Make sure the buffer is an allowed size\n  if (b.length > 8)\n    throw new Error('ChainID provided is too large.');\n  // If this matches a u16, u32, or u64 size, return it now\n  if (b.length <= 2 || b.length === 4 || b.length === 8)\n    return b;\n  // For other size buffers, we need to pack into u32 or u64 before returning;\n  let buf;\n  if (b.length === 3) {\n    buf = Buffer.alloc(4);\n    buf.writeUInt32BE(chainId);\n  } else if (b.length <= 8) {\n    buf = Buffer.alloc(8);\n    b.copy(buf, 8 - b.length)\n  }\n  return buf;\n}\n\n// Determine if the chain uses EIP155 by default, based on the chainID\nfunction chainUsesEIP155(chainID) {\n  switch (chainID) {\n    case 3: // ropsten\n    case 4: // rinkeby\n      return false;\n    case 1: // mainnet\n    case 42: // kovan\n    case 5: // goerli\n    default: // all others should use eip155\n      return true;\n  }\n}\n\n// Determine if a valid number was passed in as a hex string\nfunction isValidChainIdHexNumStr(s) {\n  if (typeof s !== 'string')\n    return false;\n  if (s.slice(0, 2) !== '0x')\n    return false;\n  try {\n    const b = new BN(s, 16)\n    return b.isNaN() === false;\n  } catch (err) {\n    return false;\n  }\n}\n\n// If this is a nubmer that fits in one byte, we don't need to add it\n// to the `data` buffer of the main transaction. \n// Note the one edge case: we still need to use the `data` field for chainID=255.\nfunction useChainIdBuffer(id) {\n  const buf = getChainIdBuf(id);\n  if (buf.length === 1)\n    return buf.readUInt8(0) === 255;\n  return true;\n}\n\nexports.chainIds = chainIds;\n\nfunction isBase10NumStr(x) {\n  const bn = new BN(x).toString().split('.').join('');\n  const s = new String(x)\n  // Note that the JS native `String()` loses precision for large numbers, but we only\n  // want to validate the base of the number so we don't care about far out precision.\n  return bn.slice(0, 8) === s.slice(0, 8)\n}\n\n// Ensure a param is represented by a buffer\n// TODO: Remove circular dependency in util.js so that we can put this function there\nfunction ensureHexBuffer(x, zeroIsNull=true) {\n  try {\n    // For null values, return a 0-sized buffer. For most situations we assume\n    // 0 should be represented with a zero-length buffer (e.g. for RLP-building\n    // txs), but it can also be treated as a 1-byte buffer (`00`) if needed\n    if (x === null || (x === 0 && zeroIsNull === true)) \n      return Buffer.alloc(0);\n    const isNumber = typeof x === 'number' || isBase10NumStr(x);\n    // Otherwise try to get this converted to a hex string\n    if (isNumber) {\n      // If this is a number or a base-10 number string, convert it to hex\n      x = `${new BN(x).toString(16)}`;\n    } else if (typeof x === 'string' && x.slice(0, 2) === '0x') {\n      x = x.slice(2);\n    } else {\n      x = x.toString('hex')\n    }\n    if (x.length % 2 > 0) x = `0${x}`;\n    if (x === '00' && !isNumber)\n      return Buffer.alloc(0);\n    return Buffer.from(x, 'hex');\n  } catch (err) {\n    throw new Error(`Cannot convert ${x.toString()} to hex buffer (${err.toString()})`);\n  }\n}\nexports.ensureHexBuffer = ensureHexBuffer;\n\n\nfunction buildPersonalSignRequest(req, input) {\n  const MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;\n  const VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;\n  const L = (24) + MAX_BASE_MSG_SZ + 4;\n  let off = 0;\n  req.payload = Buffer.alloc(L);\n  req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0); off += 1;\n  // Write the signer path into the buffer\n  const signerPathBuf = buildSignerPathBuf(input.signerPath, VAR_PATH_SZ);\n  signerPathBuf.copy(req.payload, off);\n  off += signerPathBuf.length;\n  // Write the payload buffer. The payload can come in either as a buffer or as a string\n  let payload = input.payload;\n  // Determine if this is a hex string\n  let displayHex = false;\n  if (typeof input.payload === 'string') {\n    if (input.payload.slice(0, 2) === '0x') {\n      payload = ensureHexBuffer(input.payload)\n      displayHex = false === isASCIIStr(Buffer.from(input.payload.slice(2), 'hex').toString())\n    } else {\n      if (false === latticeCanDisplayStr(input.payload))\n        throw new Error('Currently, the Lattice can only display ASCII strings.');\n      payload = Buffer.from(input.payload)\n    }\n  } else if (typeof input.displayHex === 'boolean') {\n    // If this is a buffer and the user has specified whether or not this\n    // is a hex buffer with the optional argument, write that\n    displayHex = input.displayHex\n  } else {\n    // Otherwise, determine if this buffer is an ASCII string. If it is, set `displayHex` accordingly.\n    // NOTE: THIS MEANS THAT NON-ASCII STRINGS WILL DISPLAY AS HEX SINCE WE CANNOT KNOW IF THE REQUESTER\n    //        EXPECTED NON-ASCII CHARACTERS TO DISPLAY IN A STRING\n    // TODO: Develop a more elegant solution for this\n    if (!input.payload.toString)\n      throw new Error('Unsupported input data type');\n    displayHex = false === isASCIIStr(input.payload.toString())\n  }\n  const fwConst = input.fwConstants;\n  const maxSzAllowed = MAX_BASE_MSG_SZ + (fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz);\n  if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {\n    // If this message will not fit and pre-hashing is allowed, do that\n    req.payload.writeUInt8(displayHex, off); off += 1;\n    req.payload.writeUInt16LE(payload.length, off); off += 2;\n    const prehash = Buffer.from(keccak256(Buffer.concat([get_personal_sign_prefix(payload.length), payload])), 'hex');\n    prehash.copy(req.payload, off);\n    req.prehash = prehash;\n  } else {\n    // Otherwise we can fit the payload.\n    // Flow data into extraData requests, which will follow-up transaction requests, if supported/applicable    \n    const extraDataPayloads = getExtraData(payload, input);\n    // Write the payload and metadata into our buffer\n    req.extraDataPayloads = extraDataPayloads\n    req.msg = payload;\n    req.payload.writeUInt8(displayHex, off); off += 1;\n    req.payload.writeUInt16LE(payload.length, off); off += 2;\n    payload.copy(req.payload, off);\n  }\n  return req;\n}\n\nfunction buildEIP712Request(req, input) {\n  try {\n    const MAX_BASE_MSG_SZ = input.fwConstants.ethMaxMsgSz;\n    const VAR_PATH_SZ = input.fwConstants.varAddrPathSzAllowed;\n    const TYPED_DATA = constants.ethMsgProtocol.TYPED_DATA;\n    const L = (24) + MAX_BASE_MSG_SZ + 4;\n    let off = 0;\n    req.payload = Buffer.alloc(L);\n    req.payload.writeUInt8(TYPED_DATA.enumIdx, 0); off += 1;\n    // Write the signer path\n    const signerPathBuf = buildSignerPathBuf(input.signerPath, VAR_PATH_SZ);\n    signerPathBuf.copy(req.payload, off);\n    off += signerPathBuf.length;\n    // Parse/clean the EIP712 payload, serialize with CBOR, and write to the payload\n    const data = JSON.parse(JSON.stringify(input.payload));\n    if (!data.primaryType || !data.types[data.primaryType])\n      throw new Error('primaryType must be specified and the type must be included.')\n    if (!data.message || !data.domain)\n      throw new Error('message and domain must be specified.')\n    if (0 > Object.keys(data.types).indexOf('EIP712Domain'))\n      throw new Error('EIP712Domain type must be defined.')\n    // Parse the payload to ensure we have valid EIP712 data types and that\n    // they are encoded such that Lattice firmware can parse them.\n    // We need two different encodings:\n    // 1. Use `ethers` BigNumber when building the request to be validated by ethers-eip712.\n    //    Make sure we use a copy of the data to avoid mutation problems\n    input.payload.message = parseEIP712Msg( JSON.parse(JSON.stringify(data.message)), \n                                            JSON.parse(JSON.stringify(data.primaryType)), \n                                            JSON.parse(JSON.stringify(data.types)), \n                                            true);\n    input.payload.domain = parseEIP712Msg( JSON.parse(JSON.stringify(data.domain)), \n                                            'EIP712Domain', \n                                            JSON.parse(JSON.stringify(data.types)), \n                                            true);\n    // 2. Use `bignumber.js` for the request going to the Lattice, since it's the required\n    //    BigNumber lib for `cbor`, which we use to encode the request data to the Lattice.\n    data.domain = parseEIP712Msg(data.domain, 'EIP712Domain', data.types, false);\n    data.message = parseEIP712Msg(data.message, data.primaryType, data.types, false);\n    // Now build the message to be sent to the Lattice\n    const payload = Buffer.from(cbor.encode(data));\n    const fwConst = input.fwConstants;\n    const maxSzAllowed = MAX_BASE_MSG_SZ + (fwConst.extraDataMaxFrames * fwConst.extraDataFrameSz);\n    if (fwConst.ethMsgPreHashAllowed && payload.length > maxSzAllowed) {\n      // If this payload is too large to send, but the Lattice allows a prehashed message, do that\n      req.payload.writeUInt16LE(payload.length, off); off += 2;\n      const prehash = Buffer.from(keccak256(eip712.TypedDataUtils.encodeDigest(req.input.payload), 'hex'), 'hex');\n      prehash.copy(req.payload, off);\n      req.prehash = prehash;\n    } else {\n      const extraDataPayloads = getExtraData(payload, input);\n      req.extraDataPayloads = extraDataPayloads;\n      req.payload.writeUInt16LE(payload.length, off); off += 2;\n      payload.copy(req.payload, off); off += payload.length;\n      // Slice out the part of the buffer that we didn't use.\n      req.payload = req.payload.slice(0, off);\n    }\n    return req;\n  } catch (err) {\n    return { err: `Failed to build EIP712 request: ${err.message}` };\n  }\n}\n\nfunction buildSignerPathBuf(signerPath, varAddrPathSzAllowed) {\n  const buf = Buffer.alloc(24);\n  let off = 0;\n  if (varAddrPathSzAllowed && signerPath.length > 5)\n    throw new Error('Signer path must be <=5 indices.');\n  if (!varAddrPathSzAllowed && signerPath.length !== 5)\n    throw new Error('Your Lattice firmware only supports 5-index derivation paths. Please upgrade.');\n  buf.writeUInt32LE(signerPath.length, off); off += 4;\n  for (let i = 0; i < 5; i++) {\n    if (i < signerPath.length)\n      buf.writeUInt32LE(signerPath[i], off); \n    else\n      buf.writeUInt32LE(0, off);\n    off += 4;\n  }\n  return buf;\n}\n\nfunction getExtraData(payload, input) {\n  const { ethMaxMsgSz, extraDataFrameSz, extraDataMaxFrames } = input.fwConstants;\n  const MAX_BASE_MSG_SZ = ethMaxMsgSz;\n  const EXTRA_DATA_ALLOWED = extraDataFrameSz > 0 && extraDataMaxFrames > 0;\n  const extraDataPayloads = [];\n  if (payload.length > MAX_BASE_MSG_SZ) {\n    // Determine sizes and run through sanity checks\n    const maxSzAllowed = MAX_BASE_MSG_SZ + (extraDataMaxFrames * extraDataFrameSz);\n    if (!EXTRA_DATA_ALLOWED)\n      throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${MAX_BASE_MSG_SZ}`);\n    else if (EXTRA_DATA_ALLOWED && payload.length > maxSzAllowed)\n      throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${maxSzAllowed}`);\n    // Split overflow data into extraData frames\n    const frames = splitFrames(payload.slice(MAX_BASE_MSG_SZ), extraDataFrameSz);\n    frames.forEach((frame) => {\n      const szLE = Buffer.alloc(4);\n      szLE.writeUInt32LE(frame.length);\n      extraDataPayloads.push(Buffer.concat([szLE, frame]));\n    })\n  }\n  return extraDataPayloads;\n}\n\nfunction splitFrames(data, frameSz) {\n  const frames = []\n  const n = Math.ceil(data.length / frameSz);\n  let off = 0;\n  for (let i = 0; i < n; i++) {\n    frames.push(data.slice(off, off + frameSz));\n    off += frameSz;\n  }\n  return frames;\n}\n\nfunction parseEIP712Msg(msg, typeName, types, isEthers=false) {\n  try {\n    const type = types[typeName];\n    type.forEach((item) => {\n      const isCustomType = Object.keys(types).indexOf(item.type) > -1;\n      if (true === isCustomType) {\n        msg[item.name] = parseEIP712Msg(msg[item.name], item.type, types, isEthers)\n      } else {\n        msg[item.name] = parseEIP712Item(msg[item.name], item.type, isEthers)\n      }\n    })\n  } catch (err) {\n    throw new Error(err.message);\n  }\n  return msg;\n}\n\nfunction parseEIP712Item(data, type, isEthers=false) {\n  if (type === 'bytes') {\n    // Variable sized bytes need to be buffer type\n    data = ensureHexBuffer(data);\n  } else if (type.slice(0, 5) === 'bytes') {\n    // Fixed sizes bytes need to be buffer type. We also add some sanity checks.\n    const nBytes = parseInt(type.slice(5));\n    data = ensureHexBuffer(data);\n    if (data.length !== nBytes)\n      throw new Error(`Expected ${type} type, but got ${data.length} bytes`);\n  } else if (type === 'address') {\n    // Address must be a 20 byte buffer\n    data = ensureHexBuffer(data);\n    // Edge case to handle the 0-address\n    if (data.length === 0) {\n      data = Buffer.alloc(20);\n    }\n    if (data.length !== 20)\n      throw new Error(`Address type must be 20 bytes, but got ${data.length} bytes`);\n    // Ethers wants addresses as hex strings\n    if (isEthers === true) {\n      data = `0x${data.toString('hex')}`\n    }\n  } else if ( (constants.ethMsgProtocol.TYPED_DATA.typeCodes[type]) && \n              (type.indexOf('uint') > -1 || type.indexOf('int') > -1)) {\n    let b = ensureHexBuffer(data);\n    // Edge case to handle 0-value bignums\n    if (b.length === 0) {\n      b = Buffer.from('00', 'hex');\n    }\n    // Uint256s should be encoded as bignums.\n    if (isEthers === true) {\n      // `ethers` uses their own BigNumber lib\n      data = ethers.BigNumber.from(`0x${b.toString('hex')}`)\n    } else {\n      // `bignumber.js` is needed for `cbor` encoding, which gets sent to the Lattice and plays\n      // nicely with its firmware cbor lib.\n      // NOTE: If we instantiate a `bignumber.js` object, it will not match what `borc` creates\n      // when run inside of the browser (i.e. MetaMask). Thus we introduce this hack to make sure\n      // we are creating a compatible type.\n      // TODO: Find another cbor lib that is compataible with the firmware's lib in a browser\n      // context. This is surprisingly difficult - I tried several libs and only cbor/borc have\n      // worked (borc is a supposedly \"browser compatible\" version of cbor)\n      data = new cbor.Encoder().semanticTypes[1][0](b.toString('hex'), 16)\n    }\n  } else if (type === 'bool') {\n    // Booleans need to be cast to a u8\n    data = data === true ? 1 : 0;\n  }\n  // Other types don't need to be modified\n  return data;\n}\n\nfunction get_personal_sign_prefix(L) {\n  return Buffer.from(\n    `\\u0019Ethereum Signed Message:\\n${L.toString()}`,\n    'utf-8',\n  );\n}"]},"metadata":{},"sourceType":"script"}