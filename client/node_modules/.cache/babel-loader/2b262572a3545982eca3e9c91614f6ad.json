{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Firefox60 = void 0;\n\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\n\nconst Logger_1 = require(\"../Logger\");\n\nconst errors_1 = require(\"../errors\");\n\nconst utils = __importStar(require(\"../utils\"));\n\nconst ortc = __importStar(require(\"../ortc\"));\n\nconst sdpCommonUtils = __importStar(require(\"./sdp/commonUtils\"));\n\nconst sdpUnifiedPlanUtils = __importStar(require(\"./sdp/unifiedPlanUtils\"));\n\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\n\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\n\nconst logger = new Logger_1.Logger('Firefox60');\nconst SCTP_NUM_STREAMS = {\n  OS: 16,\n  MIS: 2048\n};\n\nclass Firefox60 extends HandlerInterface_1.HandlerInterface {\n  constructor() {\n    super(); // Map of RTCTransceivers indexed by MID.\n\n    this._mapMidTransceiver = new Map(); // Local stream for sending.\n\n    this._sendStream = new MediaStream(); // Whether a DataChannel m=application section has been created.\n\n    this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    this._transportReady = false;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  static createFactory() {\n    return () => new Firefox60();\n  }\n\n  get name() {\n    return 'Firefox60';\n  }\n\n  close() {\n    logger.debug('close()'); // Close RTCPeerConnection.\n\n    if (this._pc) {\n      try {\n        this._pc.close();\n      } catch (error) {}\n    }\n  }\n\n  async getNativeRtpCapabilities() {\n    logger.debug('getNativeRtpCapabilities()');\n    const pc = new RTCPeerConnection({\n      iceServers: [],\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require'\n    }); // NOTE: We need to add a real video track to get the RID extension mapping.\n\n    const canvas = document.createElement('canvas'); // NOTE: Otherwise Firefox fails in next line.\n\n    canvas.getContext('2d');\n    const fakeStream = canvas.captureStream();\n    const fakeVideoTrack = fakeStream.getVideoTracks()[0];\n\n    try {\n      pc.addTransceiver('audio', {\n        direction: 'sendrecv'\n      });\n      const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {\n        direction: 'sendrecv'\n      });\n      const parameters = videoTransceiver.sender.getParameters();\n      const encodings = [{\n        rid: 'r0',\n        maxBitrate: 100000\n      }, {\n        rid: 'r1',\n        maxBitrate: 500000\n      }];\n      parameters.encodings = encodings;\n      await videoTransceiver.sender.setParameters(parameters);\n      const offer = await pc.createOffer();\n\n      try {\n        canvas.remove();\n      } catch (error) {}\n\n      try {\n        fakeVideoTrack.stop();\n      } catch (error) {}\n\n      try {\n        pc.close();\n      } catch (error) {}\n\n      const sdpObject = sdpTransform.parse(offer.sdp);\n      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n        sdpObject\n      });\n      return nativeRtpCapabilities;\n    } catch (error) {\n      try {\n        canvas.remove();\n      } catch (error2) {}\n\n      try {\n        fakeVideoTrack.stop();\n      } catch (error2) {}\n\n      try {\n        pc.close();\n      } catch (error2) {}\n\n      throw error;\n    }\n  }\n\n  async getNativeSctpCapabilities() {\n    logger.debug('getNativeSctpCapabilities()');\n    return {\n      numStreams: SCTP_NUM_STREAMS\n    };\n  }\n\n  run({\n    direction,\n    iceParameters,\n    iceCandidates,\n    dtlsParameters,\n    sctpParameters,\n    iceServers,\n    iceTransportPolicy,\n    additionalSettings,\n    proprietaryConstraints,\n    extendedRtpCapabilities\n  }) {\n    logger.debug('run()');\n    this._direction = direction;\n    this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters\n    });\n    this._sendingRtpParametersByKind = {\n      audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._sendingRemoteRtpParametersByKind = {\n      audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._pc = new RTCPeerConnection(Object.assign({\n      iceServers: iceServers || [],\n      iceTransportPolicy: iceTransportPolicy || 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require'\n    }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n    this._pc.addEventListener('iceconnectionstatechange', () => {\n      switch (this._pc.iceConnectionState) {\n        case 'checking':\n          this.emit('@connectionstatechange', 'connecting');\n          break;\n\n        case 'connected':\n        case 'completed':\n          this.emit('@connectionstatechange', 'connected');\n          break;\n\n        case 'failed':\n          this.emit('@connectionstatechange', 'failed');\n          break;\n\n        case 'disconnected':\n          this.emit('@connectionstatechange', 'disconnected');\n          break;\n\n        case 'closed':\n          this.emit('@connectionstatechange', 'closed');\n          break;\n      }\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  async updateIceServers(iceServers) {\n    // NOTE: Firefox does not implement pc.setConfiguration().\n    throw new errors_1.UnsupportedError('not supported');\n  }\n\n  async restartIce(iceParameters) {\n    logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n    this._remoteSdp.updateIceParameters(iceParameters);\n\n    if (!this._transportReady) return;\n\n    if (this._direction === 'send') {\n      const offer = await this._pc.createOffer({\n        iceRestart: true\n      });\n      logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n    } else {\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n    }\n  }\n\n  async getTransportStats() {\n    return this._pc.getStats();\n  }\n\n  async send({\n    track,\n    encodings,\n    codecOptions,\n    codec\n  }) {\n    this._assertSendDirection();\n\n    logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n    if (encodings) {\n      encodings = utils.clone(encodings, []);\n\n      if (encodings.length > 1) {\n        encodings.forEach((encoding, idx) => {\n          encoding.rid = `r${idx}`;\n        }); // Clone the encodings and reverse them because Firefox likes them\n        // from high to low.\n\n        encodings.reverse();\n      }\n    }\n\n    const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {}); // This may throw.\n\n    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n    const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {}); // This may throw.\n\n    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec); // NOTE: Firefox fails sometimes to properly anticipate the closed media\n    // section that it should use, so don't reuse closed media sections.\n    //   https://github.com/versatica/mediasoup-client/issues/104\n    //\n    // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n\n    const transceiver = this._pc.addTransceiver(track, {\n      direction: 'sendonly',\n      streams: [this._sendStream]\n    }); // NOTE: This is not spec compliants. Encodings should be given in addTransceiver\n    // second argument, but Firefox does not support it.\n\n\n    if (encodings) {\n      const parameters = transceiver.sender.getParameters();\n      parameters.encodings = encodings;\n      await transceiver.sender.setParameters(parameters);\n    }\n\n    const offer = await this._pc.createOffer();\n    let localSdpObject = sdpTransform.parse(offer.sdp); // In Firefox use DTLS role client even if we are the \"offerer\" since\n    // Firefox does not respect ICE-Lite.\n\n    if (!this._transportReady) await this._setupTransport({\n      localDtlsRole: 'client',\n      localSdpObject\n    });\n    logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer); // We can now get the transceiver.mid.\n\n    const localId = transceiver.mid; // Set MID.\n\n    sendingRtpParameters.mid = localId;\n    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1]; // Set RTCP CNAME.\n\n    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n      offerMediaObject\n    }); // Set RTP encodings by parsing the SDP offer if no encodings are given.\n\n    if (!encodings) {\n      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({\n        offerMediaObject\n      });\n    } // Set RTP encodings by parsing the SDP offer and complete them with given\n    // one if just a single encoding has been given.\n    else if (encodings.length === 1) {\n      const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({\n        offerMediaObject\n      });\n      Object.assign(newEncodings[0], encodings[0]);\n      sendingRtpParameters.encodings = newEncodings;\n    } // Otherwise if more than 1 encoding are given use them verbatim (but\n    // reverse them back since we reversed them above to satisfy Firefox).\n    else {\n      sendingRtpParameters.encodings = encodings.reverse();\n    } // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n    // each encoding.\n\n\n    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n      for (const encoding of sendingRtpParameters.encodings) {\n        encoding.scalabilityMode = 'S1T3';\n      }\n    }\n\n    this._remoteSdp.send({\n      offerMediaObject,\n      offerRtpParameters: sendingRtpParameters,\n      answerRtpParameters: sendingRemoteRtpParameters,\n      codecOptions,\n      extmapAllowMixed: true\n    });\n\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer); // Store in the map.\n\n    this._mapMidTransceiver.set(localId, transceiver);\n\n    return {\n      localId,\n      rtpParameters: sendingRtpParameters,\n      rtpSender: transceiver.sender\n    };\n  }\n\n  async stopSending(localId) {\n    logger.debug('stopSending() [localId:%s]', localId);\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated transceiver not found');\n    transceiver.sender.replaceTrack(null);\n\n    this._pc.removeTrack(transceiver.sender); // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n    // method.\n    // this._remoteSdp!.closeMediaSection(transceiver.mid);\n\n\n    this._remoteSdp.disableMediaSection(transceiver.mid);\n\n    const offer = await this._pc.createOffer();\n    logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n\n  async replaceTrack(localId, track) {\n    this._assertSendDirection();\n\n    if (track) {\n      logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n    } else {\n      logger.debug('replaceTrack() [localId:%s, no track]', localId);\n    }\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated RTCRtpTransceiver not found');\n    await transceiver.sender.replaceTrack(track);\n  }\n\n  async setMaxSpatialLayer(localId, spatialLayer) {\n    this._assertSendDirection();\n\n    logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated transceiver not found');\n    const parameters = transceiver.sender.getParameters(); // NOTE: We require encodings given from low to high, however Firefox\n    // requires them in reverse order, so do magic here.\n\n    spatialLayer = parameters.encodings.length - 1 - spatialLayer;\n    parameters.encodings.forEach((encoding, idx) => {\n      if (idx >= spatialLayer) encoding.active = true;else encoding.active = false;\n    });\n    await transceiver.sender.setParameters(parameters);\n  }\n\n  async setRtpEncodingParameters(localId, params) {\n    this._assertSendDirection();\n\n    logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated RTCRtpTransceiver not found');\n    const parameters = transceiver.sender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\n    });\n    await transceiver.sender.setParameters(parameters);\n  }\n\n  async getSenderStats(localId) {\n    this._assertSendDirection();\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated RTCRtpTransceiver not found');\n    return transceiver.sender.getStats();\n  }\n\n  async sendDataChannel({\n    ordered,\n    maxPacketLifeTime,\n    maxRetransmits,\n    label,\n    protocol\n  }) {\n    this._assertSendDirection();\n\n    const options = {\n      negotiated: true,\n      id: this._nextSendSctpStreamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('sendDataChannel() [options:%o]', options);\n\n    const dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n\n    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n    // m=application section.\n\n    if (!this._hasDataChannelMediaSection) {\n      const offer = await this._pc.createOffer();\n      const localSdpObject = sdpTransform.parse(offer.sdp);\n      const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');\n      if (!this._transportReady) await this._setupTransport({\n        localDtlsRole: 'server',\n        localSdpObject\n      });\n      logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n\n      this._remoteSdp.sendSctpAssociation({\n        offerMediaObject\n      });\n\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n\n    const sctpStreamParameters = {\n      streamId: options.id,\n      ordered: options.ordered,\n      maxPacketLifeTime: options.maxPacketLifeTime,\n      maxRetransmits: options.maxRetransmits\n    };\n    return {\n      dataChannel,\n      sctpStreamParameters\n    };\n  }\n\n  async receive({\n    trackId,\n    kind,\n    rtpParameters\n  }) {\n    this._assertRecvDirection();\n\n    logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n    const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n\n    this._remoteSdp.receive({\n      mid: localId,\n      kind,\n      offerRtpParameters: rtpParameters,\n      streamId: rtpParameters.rtcp.cname,\n      trackId\n    });\n\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    let answer = await this._pc.createAnswer();\n    const localSdpObject = sdpTransform.parse(answer.sdp);\n    const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId); // May need to modify codec parameters in the answer based on codec\n    // parameters in the offer.\n\n    sdpCommonUtils.applyCodecParameters({\n      offerRtpParameters: rtpParameters,\n      answerMediaObject\n    });\n    answer = {\n      type: 'answer',\n      sdp: sdpTransform.write(localSdpObject)\n    };\n    if (!this._transportReady) await this._setupTransport({\n      localDtlsRole: 'client',\n      localSdpObject\n    });\n    logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n\n    const transceiver = this._pc.getTransceivers().find(t => t.mid === localId);\n\n    if (!transceiver) throw new Error('new RTCRtpTransceiver not found'); // Store in the map.\n\n    this._mapMidTransceiver.set(localId, transceiver);\n\n    return {\n      localId,\n      track: transceiver.receiver.track,\n      rtpReceiver: transceiver.receiver\n    };\n  }\n\n  async stopReceiving(localId) {\n    this._assertRecvDirection();\n\n    logger.debug('stopReceiving() [localId:%s]', localId);\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated RTCRtpTransceiver not found');\n\n    this._remoteSdp.closeMediaSection(transceiver.mid);\n\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n  }\n\n  async getReceiverStats(localId) {\n    this._assertRecvDirection();\n\n    const transceiver = this._mapMidTransceiver.get(localId);\n\n    if (!transceiver) throw new Error('associated RTCRtpTransceiver not found');\n    return transceiver.receiver.getStats();\n  }\n\n  async receiveDataChannel({\n    sctpStreamParameters,\n    label,\n    protocol\n  }) {\n    this._assertRecvDirection();\n\n    const {\n      streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits\n    } = sctpStreamParameters;\n    const options = {\n      negotiated: true,\n      id: streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('receiveDataChannel() [options:%o]', options);\n\n    const dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n    // m=application section.\n\n\n    if (!this._hasDataChannelMediaSection) {\n      this._remoteSdp.receiveSctpAssociation();\n\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n\n      if (!this._transportReady) {\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        await this._setupTransport({\n          localDtlsRole: 'client',\n          localSdpObject\n        });\n      }\n\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n\n    return {\n      dataChannel\n    };\n  }\n\n  async _setupTransport({\n    localDtlsRole,\n    localSdpObject\n  }) {\n    if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n      sdpObject: localSdpObject\n    }); // Set our DTLS role.\n\n    dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n    this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n    await this.safeEmitAsPromise('@connect', {\n      dtlsParameters\n    });\n    this._transportReady = true;\n  }\n\n  _assertSendDirection() {\n    if (this._direction !== 'send') {\n      throw new Error('method can just be called for handlers with \"send\" direction');\n    }\n  }\n\n  _assertRecvDirection() {\n    if (this._direction !== 'recv') {\n      throw new Error('method can just be called for handlers with \"recv\" direction');\n    }\n  }\n\n}\n\nexports.Firefox60 = Firefox60;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/mediasoup-client/lib/handlers/Firefox60.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","exports","Firefox60","sdpTransform","require","Logger_1","errors_1","utils","ortc","sdpCommonUtils","sdpUnifiedPlanUtils","HandlerInterface_1","RemoteSdp_1","logger","Logger","SCTP_NUM_STREAMS","OS","MIS","HandlerInterface","constructor","_mapMidTransceiver","Map","_sendStream","MediaStream","_hasDataChannelMediaSection","_nextSendSctpStreamId","_transportReady","createFactory","name","close","debug","_pc","error","getNativeRtpCapabilities","pc","RTCPeerConnection","iceServers","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","canvas","document","createElement","getContext","fakeStream","captureStream","fakeVideoTrack","getVideoTracks","addTransceiver","direction","videoTransceiver","parameters","sender","getParameters","encodings","rid","maxBitrate","setParameters","offer","createOffer","remove","stop","sdpObject","parse","sdp","nativeRtpCapabilities","extractRtpCapabilities","error2","getNativeSctpCapabilities","numStreams","run","iceParameters","iceCandidates","dtlsParameters","sctpParameters","additionalSettings","proprietaryConstraints","extendedRtpCapabilities","_direction","_remoteSdp","RemoteSdp","_sendingRtpParametersByKind","audio","getSendingRtpParameters","video","_sendingRemoteRtpParametersByKind","getSendingRemoteRtpParameters","assign","addEventListener","iceConnectionState","emit","updateIceServers","UnsupportedError","restartIce","updateIceParameters","iceRestart","setLocalDescription","answer","type","getSdp","setRemoteDescription","createAnswer","getTransportStats","getStats","send","track","codecOptions","codec","_assertSendDirection","kind","id","clone","length","forEach","encoding","idx","reverse","sendingRtpParameters","codecs","reduceCodecs","sendingRemoteRtpParameters","transceiver","streams","localSdpObject","_setupTransport","localDtlsRole","localId","mid","localDescription","offerMediaObject","media","rtcp","cname","getCname","getRtpEncodings","newEncodings","mimeType","toLowerCase","scalabilityMode","offerRtpParameters","answerRtpParameters","extmapAllowMixed","set","rtpParameters","rtpSender","stopSending","Error","replaceTrack","removeTrack","disableMediaSection","setMaxSpatialLayer","spatialLayer","active","setRtpEncodingParameters","params","getSenderStats","sendDataChannel","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","options","negotiated","dataChannel","createDataChannel","find","sendSctpAssociation","sctpStreamParameters","streamId","receive","trackId","_assertRecvDirection","String","size","answerMediaObject","applyCodecParameters","write","getTransceivers","t","receiver","rtpReceiver","stopReceiving","closeMediaSection","getReceiverStats","receiveDataChannel","receiveSctpAssociation","extractDtlsParameters","role","updateDtlsRole","safeEmitAsPromise"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Firefox60 = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\nconst Logger_1 = require(\"../Logger\");\nconst errors_1 = require(\"../errors\");\nconst utils = __importStar(require(\"../utils\"));\nconst ortc = __importStar(require(\"../ortc\"));\nconst sdpCommonUtils = __importStar(require(\"./sdp/commonUtils\"));\nconst sdpUnifiedPlanUtils = __importStar(require(\"./sdp/unifiedPlanUtils\"));\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst logger = new Logger_1.Logger('Firefox60');\nconst SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };\nclass Firefox60 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Map of RTCTransceivers indexed by MID.\n        this._mapMidTransceiver = new Map();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Firefox60();\n    }\n    get name() {\n        return 'Firefox60';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require'\n        });\n        // NOTE: We need to add a real video track to get the RID extension mapping.\n        const canvas = document.createElement('canvas');\n        // NOTE: Otherwise Firefox fails in next line.\n        canvas.getContext('2d');\n        const fakeStream = canvas.captureStream();\n        const fakeVideoTrack = fakeStream.getVideoTracks()[0];\n        try {\n            pc.addTransceiver('audio', { direction: 'sendrecv' });\n            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, { direction: 'sendrecv' });\n            const parameters = videoTransceiver.sender.getParameters();\n            const encodings = [\n                { rid: 'r0', maxBitrate: 100000 },\n                { rid: 'r1', maxBitrate: 500000 }\n            ];\n            parameters.encodings = encodings;\n            await videoTransceiver.sender.setParameters(parameters);\n            const offer = await pc.createOffer();\n            try {\n                canvas.remove();\n            }\n            catch (error) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error) { }\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                canvas.remove();\n            }\n            catch (error2) { }\n            try {\n                fakeVideoTrack.stop();\n            }\n            catch (error2) { }\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async updateIceServers(iceServers) {\n        // NOTE: Firefox does not implement pc.setConfiguration().\n        throw new errors_1.UnsupportedError('not supported');\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (encodings) {\n            encodings = utils.clone(encodings, []);\n            if (encodings.length > 1) {\n                encodings.forEach((encoding, idx) => {\n                    encoding.rid = `r${idx}`;\n                });\n                // Clone the encodings and reverse them because Firefox likes them\n                // from high to low.\n                encodings.reverse();\n            }\n        }\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});\n        // This may throw.\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs, codec);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});\n        // This may throw.\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);\n        // NOTE: Firefox fails sometimes to properly anticipate the closed media\n        // section that it should use, so don't reuse closed media sections.\n        //   https://github.com/versatica/mediasoup-client/issues/104\n        //\n        // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();\n        const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });\n        // NOTE: This is not spec compliants. Encodings should be given in addTransceiver\n        // second argument, but Firefox does not support it.\n        if (encodings) {\n            const parameters = transceiver.sender.getParameters();\n            parameters.encodings = encodings;\n            await transceiver.sender.setParameters(parameters);\n        }\n        const offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        // In Firefox use DTLS role client even if we are the \"offerer\" since\n        // Firefox does not respect ICE-Lite.\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        // We can now get the transceiver.mid.\n        const localId = transceiver.mid;\n        // Set MID.\n        sendingRtpParameters.mid = localId;\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings by parsing the SDP offer if no encodings are given.\n        if (!encodings) {\n            sendingRtpParameters.encodings =\n                sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n        }\n        // Set RTP encodings by parsing the SDP offer and complete them with given\n        // one if just a single encoding has been given.\n        else if (encodings.length === 1) {\n            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });\n            Object.assign(newEncodings[0], encodings[0]);\n            sendingRtpParameters.encodings = newEncodings;\n        }\n        // Otherwise if more than 1 encoding are given use them verbatim (but\n        // reverse them back since we reversed them above to satisfy Firefox).\n        else {\n            sendingRtpParameters.encodings = encodings.reverse();\n        }\n        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to\n        // each encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||\n                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions,\n            extmapAllowMixed: true\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender: transceiver.sender\n        };\n    }\n    async stopSending(localId) {\n        logger.debug('stopSending() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated transceiver not found');\n        transceiver.sender.replaceTrack(null);\n        this._pc.removeTrack(transceiver.sender);\n        // NOTE: Cannot use closeMediaSection() due to the the note above in send()\n        // method.\n        // this._remoteSdp!.closeMediaSection(transceiver.mid);\n        this._remoteSdp.disableMediaSection(transceiver.mid);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        await transceiver.sender.replaceTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated transceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        // NOTE: We require encodings given from low to high, however Firefox\n        // requires them in reverse order, so do magic here.\n        spatialLayer = parameters.encodings.length - 1 - spatialLayer;\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx >= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        const parameters = transceiver.sender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\n        });\n        await transceiver.sender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.sender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);\n        this._remoteSdp.receive({\n            mid: localId,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === localId);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const transceiver = this._pc.getTransceivers()\n            .find((t) => t.mid === localId);\n        if (!transceiver)\n            throw new Error('new RTCRtpTransceiver not found');\n        // Store in the map.\n        this._mapMidTransceiver.set(localId, transceiver);\n        return {\n            localId,\n            track: transceiver.receiver.track,\n            rtpReceiver: transceiver.receiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        this._remoteSdp.closeMediaSection(transceiver.mid);\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const transceiver = this._mapMidTransceiver.get(localId);\n        if (!transceiver)\n            throw new Error('associated RTCRtpTransceiver not found');\n        return transceiver.receiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation();\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Firefox60 = Firefox60;\n"]},"metadata":{},"sourceType":"script"}