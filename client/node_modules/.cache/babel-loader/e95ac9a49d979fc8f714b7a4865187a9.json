{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ethVerifyMessage = exports.ethSignMessage = exports.ethGetAddress = exports.ethSignTx = exports.ethGetAccountPaths = exports.ethSupportsEIP1559 = exports.ethSupportsNativeShapeShift = exports.ethSupportsSecureTransfer = exports.ethSupportsNetwork = void 0;\n\nconst Exchange = __importStar(require(\"@keepkey/device-protocol/lib/exchange_pb\"));\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst Types = __importStar(require(\"@keepkey/device-protocol/lib/types_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst common_1 = __importDefault(require(\"@ethereumjs/common\"));\n\nconst tx_1 = require(\"@ethereumjs/tx\");\n\nconst eip55 = __importStar(require(\"eip55\"));\n\nconst utils_1 = require(\"./utils\");\n\nfunction ethSupportsNetwork(chain_id) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return true;\n  });\n}\n\nexports.ethSupportsNetwork = ethSupportsNetwork;\n\nfunction ethSupportsSecureTransfer() {\n  return __awaiter(this, void 0, void 0, function* () {\n    return true;\n  });\n}\n\nexports.ethSupportsSecureTransfer = ethSupportsSecureTransfer;\n\nfunction ethSupportsNativeShapeShift() {\n  return true;\n}\n\nexports.ethSupportsNativeShapeShift = ethSupportsNativeShapeShift;\n\nfunction ethSupportsEIP1559() {\n  return false;\n}\n\nexports.ethSupportsEIP1559 = ethSupportsEIP1559;\n\nfunction ethGetAccountPaths(msg) {\n  const slip44 = core.slip44ByCoin(msg.coin);\n  if (slip44 === undefined) return [];\n  return [{\n    addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx, 0, 0],\n    hardenedPath: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx],\n    relPath: [0, 0],\n    description: \"KeepKey\"\n  }];\n}\n\nexports.ethGetAccountPaths = ethGetAccountPaths;\n\nfunction stripLeadingZeroes(buf) {\n  const firstZeroIndex = buf.findIndex(x => x !== 0);\n  return buf.slice(firstZeroIndex !== -1 ? firstZeroIndex : buf.length);\n}\n\nfunction ethSignTx(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n      const est = new Messages.EthereumSignTx();\n      est.setAddressNList(msg.addressNList);\n      est.setNonce(stripLeadingZeroes(core.arrayify(msg.nonce)));\n      est.setGasLimit(core.arrayify(msg.gasLimit));\n\n      if (msg.gasPrice) {\n        est.setGasPrice(core.arrayify(msg.gasPrice));\n        est.setType(core.ETHTransactionType.ETH_TX_TYPE_LEGACY);\n      }\n\n      if (msg.maxFeePerGas) {\n        est.setMaxFeePerGas(core.arrayify(msg.maxFeePerGas));\n        est.setType(core.ETHTransactionType.ETH_TX_TYPE_EIP_1559);\n\n        if (msg.maxPriorityFeePerGas) {\n          est.setMaxPriorityFeePerGas(core.arrayify(msg.maxPriorityFeePerGas));\n        }\n      }\n\n      if (msg.value.match(\"^0x0*$\") === null) {\n        est.setValue(core.arrayify(msg.value));\n      }\n\n      if (msg.toAddressNList) {\n        est.setAddressType(Types.OutputAddressType.SPEND);\n        est.setToAddressNList(msg.toAddressNList);\n      } else if (msg.exchangeType) {\n        est.setAddressType(Types.OutputAddressType.EXCHANGE);\n        const signedHex = core.base64toHEX(msg.exchangeType.signedExchangeResponse);\n        const signedExchangeOut = Exchange.SignedExchangeResponse.deserializeBinary(core.arrayify(signedHex));\n        const exchangeType = new Types.ExchangeType();\n        exchangeType.setSignedExchangeResponse(signedExchangeOut);\n        exchangeType.setWithdrawalCoinName(msg.exchangeType.withdrawalCoinName); // KeepKey firmware will complain if this doesn't match signed exchange response\n\n        exchangeType.setWithdrawalAddressNList(msg.exchangeType.withdrawalAddressNList);\n        exchangeType.setWithdrawalScriptType(utils_1.translateInputScriptType(msg.exchangeType.withdrawalScriptType || core.BTCInputScriptType.SpendAddress));\n        exchangeType.setReturnAddressNList(msg.exchangeType.returnAddressNList);\n        exchangeType.setReturnScriptType(utils_1.translateInputScriptType(msg.exchangeType.returnScriptType || core.BTCInputScriptType.SpendAddress));\n        est.setExchangeType(exchangeType);\n      } else {\n        est.setAddressType(Types.OutputAddressType.SPEND);\n      }\n\n      if (msg.to) {\n        est.setTo(core.arrayify(msg.to));\n      }\n\n      let dataChunk = null;\n      let dataRemaining = undefined;\n\n      if (msg.data) {\n        dataRemaining = core.arrayify(msg.data);\n        est.setDataLength(dataRemaining.length);\n        dataChunk = dataRemaining.slice(0, 1024);\n        dataRemaining = dataRemaining.slice(dataChunk.length);\n        est.setDataInitialChunk(dataChunk);\n      }\n\n      if (msg.chainId !== undefined) {\n        est.setChainId(msg.chainId);\n      }\n\n      let response;\n      let nextResponse = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNTX, est, core.LONG_TIMEOUT,\n      /*omitLock=*/\n      true);\n\n      if (nextResponse.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n        throw nextResponse;\n      }\n\n      response = nextResponse.proto;\n\n      try {\n        const esa = new Messages.EthereumTxAck();\n\n        while (response.hasDataLength()) {\n          const dataLength = response.getDataLength();\n          dataRemaining = core.mustBeDefined(dataRemaining);\n          dataChunk = dataRemaining.slice(0, dataLength);\n          dataRemaining = dataRemaining.slice(dataLength, dataRemaining.length);\n          esa.setDataChunk(dataChunk);\n          nextResponse = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMTXACK, esa, core.LONG_TIMEOUT,\n          /*omitLock=*/\n          true);\n\n          if (nextResponse.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n            throw nextResponse;\n          }\n\n          response = nextResponse.proto;\n        }\n      } catch (error) {\n        console.error({\n          error\n        });\n        throw new Error(\"Failed to sign ETH transaction\");\n      }\n\n      const utxBase = {\n        to: msg.to,\n        value: msg.value,\n        data: msg.data,\n        chainId: msg.chainId,\n        nonce: msg.nonce,\n        gasLimit: msg.gasLimit,\n        maxFeePerGas: msg.maxFeePerGas,\n        maxPriorityFeePerGas: msg.maxPriorityFeePerGas\n      };\n      const r = \"0x\" + core.toHexString(response.getSignatureR_asU8());\n      const s = \"0x\" + core.toHexString(response.getSignatureS_asU8());\n      if (!response.hasSignatureV()) throw new Error(\"could not get v\");\n      const v = response.getSignatureV();\n      const v2 = \"0x\" + v.toString(16);\n      const common = new common_1.default({\n        chain: \"mainnet\",\n        hardfork: \"london\"\n      });\n      const tx = msg.maxFeePerGas ? tx_1.FeeMarketEIP1559Transaction.fromTxData(Object.assign(Object.assign({}, utxBase), {\n        maxFeePerGas: msg.maxFeePerGas,\n        maxPriorityFeePerGas: msg.maxPriorityFeePerGas,\n        r: r,\n        s: s,\n        v: v2\n      })) : tx_1.Transaction.fromTxData(Object.assign(Object.assign({}, utxBase), {\n        gasPrice: msg.gasPrice,\n        r: r,\n        s: s,\n        v: v2\n      }), {\n        common\n      });\n      return {\n        r,\n        s,\n        v,\n        serialized: \"0x\" + core.toHexString(tx.serialize())\n      };\n    }));\n  });\n}\n\nexports.ethSignTx = ethSignTx;\n\nfunction ethGetAddress(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const getAddr = new Messages.EthereumGetAddress();\n    getAddr.setAddressNList(msg.addressNList);\n    getAddr.setShowDisplay(msg.showDisplay !== false);\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMGETADDRESS, getAddr, core.LONG_TIMEOUT);\n    const ethAddress = response.proto;\n    if (response.message_type === core.Events.FAILURE) throw response;\n    let address;\n    if (ethAddress.hasAddressStr()) address = ethAddress.getAddressStr();else if (ethAddress.hasAddress()) address = \"0x\" + core.toHexString(ethAddress.getAddress_asU8());else throw new Error(\"Unable to obtain ETH address from device.\");\n    return address;\n  });\n}\n\nexports.ethGetAddress = ethGetAddress;\n\nfunction ethSignMessage(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const m = new Messages.EthereumSignMessage();\n    m.setAddressNList(msg.addressNList);\n    m.setMessage(utils_1.toUTF8Array(msg.message));\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE, m, core.LONG_TIMEOUT);\n    const sig = response.proto;\n    return {\n      address: eip55.encode(\"0x\" + core.toHexString(sig.getAddress_asU8())),\n      signature: \"0x\" + core.toHexString(sig.getSignature_asU8())\n    };\n  });\n}\n\nexports.ethSignMessage = ethSignMessage;\n\nfunction ethVerifyMessage(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const m = new Messages.EthereumVerifyMessage();\n    m.setAddress(core.arrayify(msg.address));\n    m.setSignature(core.arrayify(msg.signature));\n    m.setMessage(utils_1.toUTF8Array(msg.message));\n    const event = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMVERIFYMESSAGE, m, core.LONG_TIMEOUT);\n    const success = event.proto;\n    return success.getMessage() === \"Message verified\";\n  });\n}\n\nexports.ethVerifyMessage = ethVerifyMessage;","map":{"version":3,"sources":["../src/ethereum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ethVerifyMessage = exports.ethSignMessage = exports.ethGetAddress = exports.ethSignTx = exports.ethGetAccountPaths = exports.ethSupportsEIP1559 = exports.ethSupportsNativeShapeShift = exports.ethSupportsSecureTransfer = exports.ethSupportsNetwork = void 0;\nconst Exchange = __importStar(require(\"@keepkey/device-protocol/lib/exchange_pb\"));\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\nconst Types = __importStar(require(\"@keepkey/device-protocol/lib/types_pb\"));\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst common_1 = __importDefault(require(\"@ethereumjs/common\"));\nconst tx_1 = require(\"@ethereumjs/tx\");\nconst eip55 = __importStar(require(\"eip55\"));\nconst utils_1 = require(\"./utils\");\nfunction ethSupportsNetwork(chain_id) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return true;\n    });\n}\nexports.ethSupportsNetwork = ethSupportsNetwork;\nfunction ethSupportsSecureTransfer() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return true;\n    });\n}\nexports.ethSupportsSecureTransfer = ethSupportsSecureTransfer;\nfunction ethSupportsNativeShapeShift() {\n    return true;\n}\nexports.ethSupportsNativeShapeShift = ethSupportsNativeShapeShift;\nfunction ethSupportsEIP1559() {\n    return false;\n}\nexports.ethSupportsEIP1559 = ethSupportsEIP1559;\nfunction ethGetAccountPaths(msg) {\n    const slip44 = core.slip44ByCoin(msg.coin);\n    if (slip44 === undefined)\n        return [];\n    return [\n        {\n            addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx, 0, 0],\n            hardenedPath: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx],\n            relPath: [0, 0],\n            description: \"KeepKey\",\n        },\n    ];\n}\nexports.ethGetAccountPaths = ethGetAccountPaths;\nfunction stripLeadingZeroes(buf) {\n    const firstZeroIndex = buf.findIndex((x) => x !== 0);\n    return buf.slice(firstZeroIndex !== -1 ? firstZeroIndex : buf.length);\n}\nfunction ethSignTx(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n            const est = new Messages.EthereumSignTx();\n            est.setAddressNList(msg.addressNList);\n            est.setNonce(stripLeadingZeroes(core.arrayify(msg.nonce)));\n            est.setGasLimit(core.arrayify(msg.gasLimit));\n            if (msg.gasPrice) {\n                est.setGasPrice(core.arrayify(msg.gasPrice));\n                est.setType(core.ETHTransactionType.ETH_TX_TYPE_LEGACY);\n            }\n            if (msg.maxFeePerGas) {\n                est.setMaxFeePerGas(core.arrayify(msg.maxFeePerGas));\n                est.setType(core.ETHTransactionType.ETH_TX_TYPE_EIP_1559);\n                if (msg.maxPriorityFeePerGas) {\n                    est.setMaxPriorityFeePerGas(core.arrayify(msg.maxPriorityFeePerGas));\n                }\n            }\n            if (msg.value.match(\"^0x0*$\") === null) {\n                est.setValue(core.arrayify(msg.value));\n            }\n            if (msg.toAddressNList) {\n                est.setAddressType(Types.OutputAddressType.SPEND);\n                est.setToAddressNList(msg.toAddressNList);\n            }\n            else if (msg.exchangeType) {\n                est.setAddressType(Types.OutputAddressType.EXCHANGE);\n                const signedHex = core.base64toHEX(msg.exchangeType.signedExchangeResponse);\n                const signedExchangeOut = Exchange.SignedExchangeResponse.deserializeBinary(core.arrayify(signedHex));\n                const exchangeType = new Types.ExchangeType();\n                exchangeType.setSignedExchangeResponse(signedExchangeOut);\n                exchangeType.setWithdrawalCoinName(msg.exchangeType.withdrawalCoinName); // KeepKey firmware will complain if this doesn't match signed exchange response\n                exchangeType.setWithdrawalAddressNList(msg.exchangeType.withdrawalAddressNList);\n                exchangeType.setWithdrawalScriptType(utils_1.translateInputScriptType(msg.exchangeType.withdrawalScriptType || core.BTCInputScriptType.SpendAddress));\n                exchangeType.setReturnAddressNList(msg.exchangeType.returnAddressNList);\n                exchangeType.setReturnScriptType(utils_1.translateInputScriptType(msg.exchangeType.returnScriptType || core.BTCInputScriptType.SpendAddress));\n                est.setExchangeType(exchangeType);\n            }\n            else {\n                est.setAddressType(Types.OutputAddressType.SPEND);\n            }\n            if (msg.to) {\n                est.setTo(core.arrayify(msg.to));\n            }\n            let dataChunk = null;\n            let dataRemaining = undefined;\n            if (msg.data) {\n                dataRemaining = core.arrayify(msg.data);\n                est.setDataLength(dataRemaining.length);\n                dataChunk = dataRemaining.slice(0, 1024);\n                dataRemaining = dataRemaining.slice(dataChunk.length);\n                est.setDataInitialChunk(dataChunk);\n            }\n            if (msg.chainId !== undefined) {\n                est.setChainId(msg.chainId);\n            }\n            let response;\n            let nextResponse = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNTX, est, core.LONG_TIMEOUT, \n            /*omitLock=*/ true);\n            if (nextResponse.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n                throw nextResponse;\n            }\n            response = nextResponse.proto;\n            try {\n                const esa = new Messages.EthereumTxAck();\n                while (response.hasDataLength()) {\n                    const dataLength = response.getDataLength();\n                    dataRemaining = core.mustBeDefined(dataRemaining);\n                    dataChunk = dataRemaining.slice(0, dataLength);\n                    dataRemaining = dataRemaining.slice(dataLength, dataRemaining.length);\n                    esa.setDataChunk(dataChunk);\n                    nextResponse = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMTXACK, esa, core.LONG_TIMEOUT, \n                    /*omitLock=*/ true);\n                    if (nextResponse.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n                        throw nextResponse;\n                    }\n                    response = nextResponse.proto;\n                }\n            }\n            catch (error) {\n                console.error({ error });\n                throw new Error(\"Failed to sign ETH transaction\");\n            }\n            const utxBase = {\n                to: msg.to,\n                value: msg.value,\n                data: msg.data,\n                chainId: msg.chainId,\n                nonce: msg.nonce,\n                gasLimit: msg.gasLimit,\n                maxFeePerGas: msg.maxFeePerGas,\n                maxPriorityFeePerGas: msg.maxPriorityFeePerGas,\n            };\n            const r = \"0x\" + core.toHexString(response.getSignatureR_asU8());\n            const s = \"0x\" + core.toHexString(response.getSignatureS_asU8());\n            if (!response.hasSignatureV())\n                throw new Error(\"could not get v\");\n            const v = response.getSignatureV();\n            const v2 = \"0x\" + v.toString(16);\n            const common = new common_1.default({ chain: \"mainnet\", hardfork: \"london\" });\n            const tx = msg.maxFeePerGas\n                ? tx_1.FeeMarketEIP1559Transaction.fromTxData(Object.assign(Object.assign({}, utxBase), { maxFeePerGas: msg.maxFeePerGas, maxPriorityFeePerGas: msg.maxPriorityFeePerGas, r: r, s: s, v: v2 }))\n                : tx_1.Transaction.fromTxData(Object.assign(Object.assign({}, utxBase), { gasPrice: msg.gasPrice, r: r, s: s, v: v2 }), { common });\n            return {\n                r,\n                s,\n                v,\n                serialized: \"0x\" + core.toHexString(tx.serialize()),\n            };\n        }));\n    });\n}\nexports.ethSignTx = ethSignTx;\nfunction ethGetAddress(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const getAddr = new Messages.EthereumGetAddress();\n        getAddr.setAddressNList(msg.addressNList);\n        getAddr.setShowDisplay(msg.showDisplay !== false);\n        const response = yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMGETADDRESS, getAddr, core.LONG_TIMEOUT);\n        const ethAddress = response.proto;\n        if (response.message_type === core.Events.FAILURE)\n            throw response;\n        let address;\n        if (ethAddress.hasAddressStr())\n            address = ethAddress.getAddressStr();\n        else if (ethAddress.hasAddress())\n            address = \"0x\" + core.toHexString(ethAddress.getAddress_asU8());\n        else\n            throw new Error(\"Unable to obtain ETH address from device.\");\n        return address;\n    });\n}\nexports.ethGetAddress = ethGetAddress;\nfunction ethSignMessage(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const m = new Messages.EthereumSignMessage();\n        m.setAddressNList(msg.addressNList);\n        m.setMessage(utils_1.toUTF8Array(msg.message));\n        const response = (yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE, m, core.LONG_TIMEOUT));\n        const sig = response.proto;\n        return {\n            address: eip55.encode(\"0x\" + core.toHexString(sig.getAddress_asU8())),\n            signature: \"0x\" + core.toHexString(sig.getSignature_asU8()),\n        };\n    });\n}\nexports.ethSignMessage = ethSignMessage;\nfunction ethVerifyMessage(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const m = new Messages.EthereumVerifyMessage();\n        m.setAddress(core.arrayify(msg.address));\n        m.setSignature(core.arrayify(msg.signature));\n        m.setMessage(utils_1.toUTF8Array(msg.message));\n        const event = (yield transport.call(Messages.MessageType.MESSAGETYPE_ETHEREUMVERIFYMESSAGE, m, core.LONG_TIMEOUT));\n        const success = event.proto;\n        return success.getMessage() === \"Message verified\";\n    });\n}\nexports.ethVerifyMessage = ethVerifyMessage;\n//# sourceMappingURL=ethereum.js.map"]},"metadata":{},"sourceType":"script"}