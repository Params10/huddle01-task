{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chrome67 = void 0;\n\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\n\nconst Logger_1 = require(\"../Logger\");\n\nconst utils = __importStar(require(\"../utils\"));\n\nconst ortc = __importStar(require(\"../ortc\"));\n\nconst sdpCommonUtils = __importStar(require(\"./sdp/commonUtils\"));\n\nconst sdpPlanBUtils = __importStar(require(\"./sdp/planBUtils\"));\n\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\n\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\n\nconst logger = new Logger_1.Logger('Chrome67');\nconst SCTP_NUM_STREAMS = {\n  OS: 1024,\n  MIS: 1024\n};\n\nclass Chrome67 extends HandlerInterface_1.HandlerInterface {\n  constructor() {\n    super(); // Local stream for sending.\n\n    this._sendStream = new MediaStream(); // Map of RTCRtpSender indexed by localId.\n\n    this._mapSendLocalIdRtpSender = new Map(); // Next sending localId.\n\n    this._nextSendLocalId = 0; // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n    // Value is an Object with mid, rtpParameters and rtpReceiver.\n\n    this._mapRecvLocalIdInfo = new Map(); // Whether a DataChannel m=application section has been created.\n\n    this._hasDataChannelMediaSection = false; // Sending DataChannel id value counter. Incremented for each new DataChannel.\n\n    this._nextSendSctpStreamId = 0; // Got transport local and remote parameters.\n\n    this._transportReady = false;\n  }\n  /**\n   * Creates a factory function.\n   */\n\n\n  static createFactory() {\n    return () => new Chrome67();\n  }\n\n  get name() {\n    return 'Chrome67';\n  }\n\n  close() {\n    logger.debug('close()'); // Close RTCPeerConnection.\n\n    if (this._pc) {\n      try {\n        this._pc.close();\n      } catch (error) {}\n    }\n  }\n\n  async getNativeRtpCapabilities() {\n    logger.debug('getNativeRtpCapabilities()');\n    const pc = new RTCPeerConnection({\n      iceServers: [],\n      iceTransportPolicy: 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'plan-b'\n    });\n\n    try {\n      const offer = await pc.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n\n      try {\n        pc.close();\n      } catch (error) {}\n\n      const sdpObject = sdpTransform.parse(offer.sdp);\n      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({\n        sdpObject\n      });\n      return nativeRtpCapabilities;\n    } catch (error) {\n      try {\n        pc.close();\n      } catch (error2) {}\n\n      throw error;\n    }\n  }\n\n  async getNativeSctpCapabilities() {\n    logger.debug('getNativeSctpCapabilities()');\n    return {\n      numStreams: SCTP_NUM_STREAMS\n    };\n  }\n\n  run({\n    direction,\n    iceParameters,\n    iceCandidates,\n    dtlsParameters,\n    sctpParameters,\n    iceServers,\n    iceTransportPolicy,\n    additionalSettings,\n    proprietaryConstraints,\n    extendedRtpCapabilities\n  }) {\n    logger.debug('run()');\n    this._direction = direction;\n    this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      planB: true\n    });\n    this._sendingRtpParametersByKind = {\n      audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._sendingRemoteRtpParametersByKind = {\n      audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n      video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n    };\n    this._pc = new RTCPeerConnection(Object.assign({\n      iceServers: iceServers || [],\n      iceTransportPolicy: iceTransportPolicy || 'all',\n      bundlePolicy: 'max-bundle',\n      rtcpMuxPolicy: 'require',\n      sdpSemantics: 'plan-b'\n    }, additionalSettings), proprietaryConstraints); // Handle RTCPeerConnection connection status.\n\n    this._pc.addEventListener('iceconnectionstatechange', () => {\n      switch (this._pc.iceConnectionState) {\n        case 'checking':\n          this.emit('@connectionstatechange', 'connecting');\n          break;\n\n        case 'connected':\n        case 'completed':\n          this.emit('@connectionstatechange', 'connected');\n          break;\n\n        case 'failed':\n          this.emit('@connectionstatechange', 'failed');\n          break;\n\n        case 'disconnected':\n          this.emit('@connectionstatechange', 'disconnected');\n          break;\n\n        case 'closed':\n          this.emit('@connectionstatechange', 'closed');\n          break;\n      }\n    });\n  }\n\n  async updateIceServers(iceServers) {\n    logger.debug('updateIceServers()');\n\n    const configuration = this._pc.getConfiguration();\n\n    configuration.iceServers = iceServers;\n\n    this._pc.setConfiguration(configuration);\n  }\n\n  async restartIce(iceParameters) {\n    logger.debug('restartIce()'); // Provide the remote SDP handler with new remote ICE parameters.\n\n    this._remoteSdp.updateIceParameters(iceParameters);\n\n    if (!this._transportReady) return;\n\n    if (this._direction === 'send') {\n      const offer = await this._pc.createOffer({\n        iceRestart: true\n      });\n      logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n    } else {\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n      logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n    }\n  }\n\n  async getTransportStats() {\n    return this._pc.getStats();\n  }\n\n  async send({\n    track,\n    encodings,\n    codecOptions,\n    codec\n  }) {\n    this._assertSendDirection();\n\n    logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n\n    if (codec) {\n      logger.warn('send() | codec selection is not available in %s handler', this.name);\n    }\n\n    this._sendStream.addTrack(track);\n\n    this._pc.addTrack(track, this._sendStream);\n\n    let offer = await this._pc.createOffer();\n    let localSdpObject = sdpTransform.parse(offer.sdp);\n    let offerMediaObject;\n    const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});\n    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);\n    const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});\n    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n    if (!this._transportReady) await this._setupTransport({\n      localDtlsRole: 'server',\n      localSdpObject\n    });\n\n    if (track.kind === 'video' && encodings && encodings.length > 1) {\n      logger.debug('send() | enabling simulcast');\n      localSdpObject = sdpTransform.parse(offer.sdp);\n      offerMediaObject = localSdpObject.media.find(m => m.type === 'video');\n      sdpPlanBUtils.addLegacySimulcast({\n        offerMediaObject,\n        track,\n        numStreams: encodings.length\n      });\n      offer = {\n        type: 'offer',\n        sdp: sdpTransform.write(localSdpObject)\n      };\n    }\n\n    logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n    await this._pc.setLocalDescription(offer);\n    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n    offerMediaObject = localSdpObject.media.find(m => m.type === track.kind); // Set RTCP CNAME.\n\n    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({\n      offerMediaObject\n    }); // Set RTP encodings.\n\n    sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({\n      offerMediaObject,\n      track\n    }); // Complete encodings with given values.\n\n    if (encodings) {\n      for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n        if (encodings[idx]) Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n      }\n    } // If VP8 and there is effective simulcast, add scalabilityMode to each\n    // encoding.\n\n\n    if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n      for (const encoding of sendingRtpParameters.encodings) {\n        encoding.scalabilityMode = 'S1T3';\n      }\n    }\n\n    this._remoteSdp.send({\n      offerMediaObject,\n      offerRtpParameters: sendingRtpParameters,\n      answerRtpParameters: sendingRemoteRtpParameters,\n      codecOptions\n    });\n\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n    const localId = String(this._nextSendLocalId);\n    this._nextSendLocalId++;\n\n    const rtpSender = this._pc.getSenders().find(s => s.track === track); // Insert into the map.\n\n\n    this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n\n    return {\n      localId: localId,\n      rtpParameters: sendingRtpParameters,\n      rtpSender\n    };\n  }\n\n  async stopSending(localId) {\n    this._assertSendDirection();\n\n    logger.debug('stopSending() [localId:%s]', localId);\n\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n\n    this._pc.removeTrack(rtpSender);\n\n    if (rtpSender.track) this._sendStream.removeTrack(rtpSender.track);\n\n    this._mapSendLocalIdRtpSender.delete(localId);\n\n    const offer = await this._pc.createOffer();\n    logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n\n    try {\n      await this._pc.setLocalDescription(offer);\n    } catch (error) {\n      // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n      // \"Failed to create channels\". If so, ignore it.\n      if (this._sendStream.getTracks().length === 0) {\n        logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n        return;\n      }\n\n      throw error;\n    }\n\n    if (this._pc.signalingState === 'stable') return;\n    const answer = {\n      type: 'answer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n    await this._pc.setRemoteDescription(answer);\n  }\n\n  async replaceTrack(localId, track) {\n    this._assertSendDirection();\n\n    if (track) {\n      logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n    } else {\n      logger.debug('replaceTrack() [localId:%s, no track]', localId);\n    }\n\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    const oldTrack = rtpSender.track;\n    await rtpSender.replaceTrack(track); // Remove the old track from the local stream.\n\n    if (oldTrack) this._sendStream.removeTrack(oldTrack); // Add the new track to the local stream.\n\n    if (track) this._sendStream.addTrack(track);\n  }\n\n  async setMaxSpatialLayer(localId, spatialLayer) {\n    this._assertSendDirection();\n\n    logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    const parameters = rtpSender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      if (idx <= spatialLayer) encoding.active = true;else encoding.active = false;\n    });\n    await rtpSender.setParameters(parameters);\n  }\n\n  async setRtpEncodingParameters(localId, params) {\n    this._assertSendDirection();\n\n    logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    const parameters = rtpSender.getParameters();\n    parameters.encodings.forEach((encoding, idx) => {\n      parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\n    });\n    await rtpSender.setParameters(parameters);\n  }\n\n  async getSenderStats(localId) {\n    this._assertSendDirection();\n\n    const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n\n    if (!rtpSender) throw new Error('associated RTCRtpSender not found');\n    return rtpSender.getStats();\n  }\n\n  async sendDataChannel({\n    ordered,\n    maxPacketLifeTime,\n    maxRetransmits,\n    label,\n    protocol\n  }) {\n    this._assertSendDirection();\n\n    const options = {\n      negotiated: true,\n      id: this._nextSendSctpStreamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmitTime: maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('sendDataChannel() [options:%o]', options);\n\n    const dataChannel = this._pc.createDataChannel(label, options); // Increase next id.\n\n\n    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS; // If this is the first DataChannel we need to create the SDP answer with\n    // m=application section.\n\n    if (!this._hasDataChannelMediaSection) {\n      const offer = await this._pc.createOffer();\n      const localSdpObject = sdpTransform.parse(offer.sdp);\n      const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');\n      if (!this._transportReady) await this._setupTransport({\n        localDtlsRole: 'server',\n        localSdpObject\n      });\n      logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n      await this._pc.setLocalDescription(offer);\n\n      this._remoteSdp.sendSctpAssociation({\n        offerMediaObject\n      });\n\n      const answer = {\n        type: 'answer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setRemoteDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n\n    const sctpStreamParameters = {\n      streamId: options.id,\n      ordered: options.ordered,\n      maxPacketLifeTime: options.maxPacketLifeTime,\n      maxRetransmits: options.maxRetransmits\n    };\n    return {\n      dataChannel,\n      sctpStreamParameters\n    };\n  }\n\n  async receive({\n    trackId,\n    kind,\n    rtpParameters\n  }) {\n    this._assertRecvDirection();\n\n    logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n    const localId = trackId;\n    const mid = kind;\n\n    this._remoteSdp.receive({\n      mid,\n      kind,\n      offerRtpParameters: rtpParameters,\n      streamId: rtpParameters.rtcp.cname,\n      trackId\n    });\n\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    let answer = await this._pc.createAnswer();\n    const localSdpObject = sdpTransform.parse(answer.sdp);\n    const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === mid); // May need to modify codec parameters in the answer based on codec\n    // parameters in the offer.\n\n    sdpCommonUtils.applyCodecParameters({\n      offerRtpParameters: rtpParameters,\n      answerMediaObject\n    });\n    answer = {\n      type: 'answer',\n      sdp: sdpTransform.write(localSdpObject)\n    };\n    if (!this._transportReady) await this._setupTransport({\n      localDtlsRole: 'client',\n      localSdpObject\n    });\n    logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n\n    const rtpReceiver = this._pc.getReceivers().find(r => r.track && r.track.id === localId);\n\n    if (!rtpReceiver) throw new Error('new RTCRtpReceiver not'); // Insert into the map.\n\n    this._mapRecvLocalIdInfo.set(localId, {\n      mid,\n      rtpParameters,\n      rtpReceiver\n    });\n\n    return {\n      localId,\n      track: rtpReceiver.track,\n      rtpReceiver\n    };\n  }\n\n  async stopReceiving(localId) {\n    this._assertRecvDirection();\n\n    logger.debug('stopReceiving() [localId:%s]', localId);\n    const {\n      mid,\n      rtpParameters\n    } = this._mapRecvLocalIdInfo.get(localId) || {}; // Remove from the map.\n\n    this._mapRecvLocalIdInfo.delete(localId);\n\n    this._remoteSdp.planBStopReceiving({\n      mid: mid,\n      offerRtpParameters: rtpParameters\n    });\n\n    const offer = {\n      type: 'offer',\n      sdp: this._remoteSdp.getSdp()\n    };\n    logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n    await this._pc.setRemoteDescription(offer);\n    const answer = await this._pc.createAnswer();\n    logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n    await this._pc.setLocalDescription(answer);\n  }\n\n  async getReceiverStats(localId) {\n    this._assertRecvDirection();\n\n    const {\n      rtpReceiver\n    } = this._mapRecvLocalIdInfo.get(localId) || {};\n    if (!rtpReceiver) throw new Error('associated RTCRtpReceiver not found');\n    return rtpReceiver.getStats();\n  }\n\n  async receiveDataChannel({\n    sctpStreamParameters,\n    label,\n    protocol\n  }) {\n    this._assertRecvDirection();\n\n    const {\n      streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmits\n    } = sctpStreamParameters;\n    const options = {\n      negotiated: true,\n      id: streamId,\n      ordered,\n      maxPacketLifeTime,\n      maxRetransmitTime: maxPacketLifeTime,\n      maxRetransmits,\n      protocol\n    };\n    logger.debug('receiveDataChannel() [options:%o]', options);\n\n    const dataChannel = this._pc.createDataChannel(label, options); // If this is the first DataChannel we need to create the SDP offer with\n    // m=application section.\n\n\n    if (!this._hasDataChannelMediaSection) {\n      this._remoteSdp.receiveSctpAssociation({\n        oldDataChannelSpec: true\n      });\n\n      const offer = {\n        type: 'offer',\n        sdp: this._remoteSdp.getSdp()\n      };\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n      await this._pc.setRemoteDescription(offer);\n      const answer = await this._pc.createAnswer();\n\n      if (!this._transportReady) {\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        await this._setupTransport({\n          localDtlsRole: 'client',\n          localSdpObject\n        });\n      }\n\n      logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n      await this._pc.setLocalDescription(answer);\n      this._hasDataChannelMediaSection = true;\n    }\n\n    return {\n      dataChannel\n    };\n  }\n\n  async _setupTransport({\n    localDtlsRole,\n    localSdpObject\n  }) {\n    if (!localSdpObject) localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp); // Get our local DTLS parameters.\n\n    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({\n      sdpObject: localSdpObject\n    }); // Set our DTLS role.\n\n    dtlsParameters.role = localDtlsRole; // Update the remote DTLS role in the SDP.\n\n    this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client'); // Need to tell the remote transport about our parameters.\n\n\n    await this.safeEmitAsPromise('@connect', {\n      dtlsParameters\n    });\n    this._transportReady = true;\n  }\n\n  _assertSendDirection() {\n    if (this._direction !== 'send') {\n      throw new Error('method can just be called for handlers with \"send\" direction');\n    }\n  }\n\n  _assertRecvDirection() {\n    if (this._direction !== 'recv') {\n      throw new Error('method can just be called for handlers with \"recv\" direction');\n    }\n  }\n\n}\n\nexports.Chrome67 = Chrome67;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/mediasoup-client/lib/handlers/Chrome67.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","exports","Chrome67","sdpTransform","require","Logger_1","utils","ortc","sdpCommonUtils","sdpPlanBUtils","HandlerInterface_1","RemoteSdp_1","logger","Logger","SCTP_NUM_STREAMS","OS","MIS","HandlerInterface","constructor","_sendStream","MediaStream","_mapSendLocalIdRtpSender","Map","_nextSendLocalId","_mapRecvLocalIdInfo","_hasDataChannelMediaSection","_nextSendSctpStreamId","_transportReady","createFactory","name","close","debug","_pc","error","getNativeRtpCapabilities","pc","RTCPeerConnection","iceServers","iceTransportPolicy","bundlePolicy","rtcpMuxPolicy","sdpSemantics","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","sdpObject","parse","sdp","nativeRtpCapabilities","extractRtpCapabilities","error2","getNativeSctpCapabilities","numStreams","run","direction","iceParameters","iceCandidates","dtlsParameters","sctpParameters","additionalSettings","proprietaryConstraints","extendedRtpCapabilities","_direction","_remoteSdp","RemoteSdp","planB","_sendingRtpParametersByKind","audio","getSendingRtpParameters","video","_sendingRemoteRtpParametersByKind","getSendingRemoteRtpParameters","assign","addEventListener","iceConnectionState","emit","updateIceServers","configuration","getConfiguration","setConfiguration","restartIce","updateIceParameters","iceRestart","setLocalDescription","answer","type","getSdp","setRemoteDescription","createAnswer","getTransportStats","getStats","send","track","encodings","codecOptions","codec","_assertSendDirection","kind","id","warn","addTrack","localSdpObject","offerMediaObject","sendingRtpParameters","clone","codecs","reduceCodecs","sendingRemoteRtpParameters","_setupTransport","localDtlsRole","length","media","find","addLegacySimulcast","write","localDescription","rtcp","cname","getCname","getRtpEncodings","idx","mimeType","toLowerCase","encoding","scalabilityMode","offerRtpParameters","answerRtpParameters","localId","String","rtpSender","getSenders","s","set","rtpParameters","stopSending","Error","removeTrack","delete","getTracks","toString","signalingState","replaceTrack","oldTrack","setMaxSpatialLayer","spatialLayer","parameters","getParameters","forEach","active","setParameters","setRtpEncodingParameters","params","getSenderStats","sendDataChannel","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","options","negotiated","maxRetransmitTime","dataChannel","createDataChannel","sendSctpAssociation","sctpStreamParameters","streamId","receive","trackId","_assertRecvDirection","mid","answerMediaObject","applyCodecParameters","rtpReceiver","getReceivers","r","stopReceiving","planBStopReceiving","getReceiverStats","receiveDataChannel","receiveSctpAssociation","oldDataChannelSpec","extractDtlsParameters","role","updateDtlsRole","safeEmitAsPromise"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chrome67 = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\nconst Logger_1 = require(\"../Logger\");\nconst utils = __importStar(require(\"../utils\"));\nconst ortc = __importStar(require(\"../ortc\"));\nconst sdpCommonUtils = __importStar(require(\"./sdp/commonUtils\"));\nconst sdpPlanBUtils = __importStar(require(\"./sdp/planBUtils\"));\nconst HandlerInterface_1 = require(\"./HandlerInterface\");\nconst RemoteSdp_1 = require(\"./sdp/RemoteSdp\");\nconst logger = new Logger_1.Logger('Chrome67');\nconst SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };\nclass Chrome67 extends HandlerInterface_1.HandlerInterface {\n    constructor() {\n        super();\n        // Local stream for sending.\n        this._sendStream = new MediaStream();\n        // Map of RTCRtpSender indexed by localId.\n        this._mapSendLocalIdRtpSender = new Map();\n        // Next sending localId.\n        this._nextSendLocalId = 0;\n        // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.\n        // Value is an Object with mid, rtpParameters and rtpReceiver.\n        this._mapRecvLocalIdInfo = new Map();\n        // Whether a DataChannel m=application section has been created.\n        this._hasDataChannelMediaSection = false;\n        // Sending DataChannel id value counter. Incremented for each new DataChannel.\n        this._nextSendSctpStreamId = 0;\n        // Got transport local and remote parameters.\n        this._transportReady = false;\n    }\n    /**\n     * Creates a factory function.\n     */\n    static createFactory() {\n        return () => new Chrome67();\n    }\n    get name() {\n        return 'Chrome67';\n    }\n    close() {\n        logger.debug('close()');\n        // Close RTCPeerConnection.\n        if (this._pc) {\n            try {\n                this._pc.close();\n            }\n            catch (error) { }\n        }\n    }\n    async getNativeRtpCapabilities() {\n        logger.debug('getNativeRtpCapabilities()');\n        const pc = new RTCPeerConnection({\n            iceServers: [],\n            iceTransportPolicy: 'all',\n            bundlePolicy: 'max-bundle',\n            rtcpMuxPolicy: 'require',\n            sdpSemantics: 'plan-b'\n        });\n        try {\n            const offer = await pc.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true\n            });\n            try {\n                pc.close();\n            }\n            catch (error) { }\n            const sdpObject = sdpTransform.parse(offer.sdp);\n            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });\n            return nativeRtpCapabilities;\n        }\n        catch (error) {\n            try {\n                pc.close();\n            }\n            catch (error2) { }\n            throw error;\n        }\n    }\n    async getNativeSctpCapabilities() {\n        logger.debug('getNativeSctpCapabilities()');\n        return {\n            numStreams: SCTP_NUM_STREAMS\n        };\n    }\n    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {\n        logger.debug('run()');\n        this._direction = direction;\n        this._remoteSdp = new RemoteSdp_1.RemoteSdp({\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            planB: true\n        });\n        this._sendingRtpParametersByKind =\n            {\n                audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._sendingRemoteRtpParametersByKind =\n            {\n                audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),\n                video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)\n            };\n        this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);\n        // Handle RTCPeerConnection connection status.\n        this._pc.addEventListener('iceconnectionstatechange', () => {\n            switch (this._pc.iceConnectionState) {\n                case 'checking':\n                    this.emit('@connectionstatechange', 'connecting');\n                    break;\n                case 'connected':\n                case 'completed':\n                    this.emit('@connectionstatechange', 'connected');\n                    break;\n                case 'failed':\n                    this.emit('@connectionstatechange', 'failed');\n                    break;\n                case 'disconnected':\n                    this.emit('@connectionstatechange', 'disconnected');\n                    break;\n                case 'closed':\n                    this.emit('@connectionstatechange', 'closed');\n                    break;\n            }\n        });\n    }\n    async updateIceServers(iceServers) {\n        logger.debug('updateIceServers()');\n        const configuration = this._pc.getConfiguration();\n        configuration.iceServers = iceServers;\n        this._pc.setConfiguration(configuration);\n    }\n    async restartIce(iceParameters) {\n        logger.debug('restartIce()');\n        // Provide the remote SDP handler with new remote ICE parameters.\n        this._remoteSdp.updateIceParameters(iceParameters);\n        if (!this._transportReady)\n            return;\n        if (this._direction === 'send') {\n            const offer = await this._pc.createOffer({ iceRestart: true });\n            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n        }\n        else {\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n        }\n    }\n    async getTransportStats() {\n        return this._pc.getStats();\n    }\n    async send({ track, encodings, codecOptions, codec }) {\n        this._assertSendDirection();\n        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);\n        if (codec) {\n            logger.warn('send() | codec selection is not available in %s handler', this.name);\n        }\n        this._sendStream.addTrack(track);\n        this._pc.addTrack(track, this._sendStream);\n        let offer = await this._pc.createOffer();\n        let localSdpObject = sdpTransform.parse(offer.sdp);\n        let offerMediaObject;\n        const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});\n        sendingRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRtpParameters.codecs);\n        const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});\n        sendingRemoteRtpParameters.codecs =\n            ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n        if (track.kind === 'video' && encodings && encodings.length > 1) {\n            logger.debug('send() | enabling simulcast');\n            localSdpObject = sdpTransform.parse(offer.sdp);\n            offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'video');\n            sdpPlanBUtils.addLegacySimulcast({\n                offerMediaObject,\n                track,\n                numStreams: encodings.length\n            });\n            offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };\n        }\n        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);\n        await this._pc.setLocalDescription(offer);\n        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        offerMediaObject = localSdpObject.media\n            .find((m) => m.type === track.kind);\n        // Set RTCP CNAME.\n        sendingRtpParameters.rtcp.cname =\n            sdpCommonUtils.getCname({ offerMediaObject });\n        // Set RTP encodings.\n        sendingRtpParameters.encodings =\n            sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });\n        // Complete encodings with given values.\n        if (encodings) {\n            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {\n                if (encodings[idx])\n                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);\n            }\n        }\n        // If VP8 and there is effective simulcast, add scalabilityMode to each\n        // encoding.\n        if (sendingRtpParameters.encodings.length > 1 &&\n            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {\n            for (const encoding of sendingRtpParameters.encodings) {\n                encoding.scalabilityMode = 'S1T3';\n            }\n        }\n        this._remoteSdp.send({\n            offerMediaObject,\n            offerRtpParameters: sendingRtpParameters,\n            answerRtpParameters: sendingRemoteRtpParameters,\n            codecOptions\n        });\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n        const localId = String(this._nextSendLocalId);\n        this._nextSendLocalId++;\n        const rtpSender = this._pc.getSenders()\n            .find((s) => s.track === track);\n        // Insert into the map.\n        this._mapSendLocalIdRtpSender.set(localId, rtpSender);\n        return {\n            localId: localId,\n            rtpParameters: sendingRtpParameters,\n            rtpSender\n        };\n    }\n    async stopSending(localId) {\n        this._assertSendDirection();\n        logger.debug('stopSending() [localId:%s]', localId);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        this._pc.removeTrack(rtpSender);\n        if (rtpSender.track)\n            this._sendStream.removeTrack(rtpSender.track);\n        this._mapSendLocalIdRtpSender.delete(localId);\n        const offer = await this._pc.createOffer();\n        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);\n        try {\n            await this._pc.setLocalDescription(offer);\n        }\n        catch (error) {\n            // NOTE: If there are no sending tracks, setLocalDescription() will fail with\n            // \"Failed to create channels\". If so, ignore it.\n            if (this._sendStream.getTracks().length === 0) {\n                logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());\n                return;\n            }\n            throw error;\n        }\n        if (this._pc.signalingState === 'stable')\n            return;\n        const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);\n        await this._pc.setRemoteDescription(answer);\n    }\n    async replaceTrack(localId, track) {\n        this._assertSendDirection();\n        if (track) {\n            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);\n        }\n        else {\n            logger.debug('replaceTrack() [localId:%s, no track]', localId);\n        }\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const oldTrack = rtpSender.track;\n        await rtpSender.replaceTrack(track);\n        // Remove the old track from the local stream.\n        if (oldTrack)\n            this._sendStream.removeTrack(oldTrack);\n        // Add the new track to the local stream.\n        if (track)\n            this._sendStream.addTrack(track);\n    }\n    async setMaxSpatialLayer(localId, spatialLayer) {\n        this._assertSendDirection();\n        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            if (idx <= spatialLayer)\n                encoding.active = true;\n            else\n                encoding.active = false;\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async setRtpEncodingParameters(localId, params) {\n        this._assertSendDirection();\n        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        const parameters = rtpSender.getParameters();\n        parameters.encodings.forEach((encoding, idx) => {\n            parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);\n        });\n        await rtpSender.setParameters(parameters);\n    }\n    async getSenderStats(localId) {\n        this._assertSendDirection();\n        const rtpSender = this._mapSendLocalIdRtpSender.get(localId);\n        if (!rtpSender)\n            throw new Error('associated RTCRtpSender not found');\n        return rtpSender.getStats();\n    }\n    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {\n        this._assertSendDirection();\n        const options = {\n            negotiated: true,\n            id: this._nextSendSctpStreamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('sendDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // Increase next id.\n        this._nextSendSctpStreamId =\n            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;\n        // If this is the first DataChannel we need to create the SDP answer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            const offer = await this._pc.createOffer();\n            const localSdpObject = sdpTransform.parse(offer.sdp);\n            const offerMediaObject = localSdpObject.media\n                .find((m) => m.type === 'application');\n            if (!this._transportReady)\n                await this._setupTransport({ localDtlsRole: 'server', localSdpObject });\n            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);\n            await this._pc.setLocalDescription(offer);\n            this._remoteSdp.sendSctpAssociation({ offerMediaObject });\n            const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setRemoteDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        const sctpStreamParameters = {\n            streamId: options.id,\n            ordered: options.ordered,\n            maxPacketLifeTime: options.maxPacketLifeTime,\n            maxRetransmits: options.maxRetransmits\n        };\n        return { dataChannel, sctpStreamParameters };\n    }\n    async receive({ trackId, kind, rtpParameters }) {\n        this._assertRecvDirection();\n        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);\n        const localId = trackId;\n        const mid = kind;\n        this._remoteSdp.receive({\n            mid,\n            kind,\n            offerRtpParameters: rtpParameters,\n            streamId: rtpParameters.rtcp.cname,\n            trackId\n        });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        let answer = await this._pc.createAnswer();\n        const localSdpObject = sdpTransform.parse(answer.sdp);\n        const answerMediaObject = localSdpObject.media\n            .find((m) => String(m.mid) === mid);\n        // May need to modify codec parameters in the answer based on codec\n        // parameters in the offer.\n        sdpCommonUtils.applyCodecParameters({\n            offerRtpParameters: rtpParameters,\n            answerMediaObject\n        });\n        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };\n        if (!this._transportReady)\n            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n        const rtpReceiver = this._pc.getReceivers()\n            .find((r) => r.track && r.track.id === localId);\n        if (!rtpReceiver)\n            throw new Error('new RTCRtpReceiver not');\n        // Insert into the map.\n        this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });\n        return {\n            localId,\n            track: rtpReceiver.track,\n            rtpReceiver\n        };\n    }\n    async stopReceiving(localId) {\n        this._assertRecvDirection();\n        logger.debug('stopReceiving() [localId:%s]', localId);\n        const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};\n        // Remove from the map.\n        this._mapRecvLocalIdInfo.delete(localId);\n        this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });\n        const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);\n        await this._pc.setRemoteDescription(offer);\n        const answer = await this._pc.createAnswer();\n        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);\n        await this._pc.setLocalDescription(answer);\n    }\n    async getReceiverStats(localId) {\n        this._assertRecvDirection();\n        const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};\n        if (!rtpReceiver)\n            throw new Error('associated RTCRtpReceiver not found');\n        return rtpReceiver.getStats();\n    }\n    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {\n        this._assertRecvDirection();\n        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;\n        const options = {\n            negotiated: true,\n            id: streamId,\n            ordered,\n            maxPacketLifeTime,\n            maxRetransmitTime: maxPacketLifeTime,\n            maxRetransmits,\n            protocol\n        };\n        logger.debug('receiveDataChannel() [options:%o]', options);\n        const dataChannel = this._pc.createDataChannel(label, options);\n        // If this is the first DataChannel we need to create the SDP offer with\n        // m=application section.\n        if (!this._hasDataChannelMediaSection) {\n            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });\n            const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);\n            await this._pc.setRemoteDescription(offer);\n            const answer = await this._pc.createAnswer();\n            if (!this._transportReady) {\n                const localSdpObject = sdpTransform.parse(answer.sdp);\n                await this._setupTransport({ localDtlsRole: 'client', localSdpObject });\n            }\n            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            await this._pc.setLocalDescription(answer);\n            this._hasDataChannelMediaSection = true;\n        }\n        return { dataChannel };\n    }\n    async _setupTransport({ localDtlsRole, localSdpObject }) {\n        if (!localSdpObject)\n            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);\n        // Get our local DTLS parameters.\n        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });\n        // Set our DTLS role.\n        dtlsParameters.role = localDtlsRole;\n        // Update the remote DTLS role in the SDP.\n        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');\n        // Need to tell the remote transport about our parameters.\n        await this.safeEmitAsPromise('@connect', { dtlsParameters });\n        this._transportReady = true;\n    }\n    _assertSendDirection() {\n        if (this._direction !== 'send') {\n            throw new Error('method can just be called for handlers with \"send\" direction');\n        }\n    }\n    _assertRecvDirection() {\n        if (this._direction !== 'recv') {\n            throw new Error('method can just be called for handlers with \"recv\" direction');\n        }\n    }\n}\nexports.Chrome67 = Chrome67;\n"]},"metadata":{},"sourceType":"script"}