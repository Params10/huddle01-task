{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractSingleWorkload = exports.smartDecodeUR = exports.decodeUR = void 0;\n\nvar utils_1 = require(\"./utils\");\n\nvar miniCbor_1 = require(\"./miniCbor\");\n\nvar bc_bech32_1 = require(\"@cvbb/bc-bech32\");\n\nvar checkAndGetSequence = function (sequence) {\n  var pieces = sequence.toUpperCase().split('OF');\n  if (pieces.length !== 2) throw new Error(\"invalid sequence: \" + sequence);\n  var index = pieces[0],\n      total = pieces[1];\n  return [+index, +total];\n};\n\nvar checkDigest = function (digest, payload) {\n  var decoded = bc_bech32_1.decodeBc32Data(payload);\n  if (!decoded) throw new Error(\"can not decode payload: \" + payload);\n\n  if (bc_bech32_1.decodeBc32Data(digest) !== utils_1.sha256Hash(Buffer.from(decoded, 'hex')).toString('hex')) {\n    throw new Error(\"invalid digest: \\n digest:\" + digest + \" \\n payload:\" + payload);\n  }\n};\n\nvar checkURHeader = function (UR, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  if (UR.toUpperCase() !== (\"ur:\" + type).toUpperCase()) throw new Error(\"invalid UR header: \" + UR);\n};\n\nvar dealWithSingleWorkload = function (workload, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  var pieces = workload.split('/');\n\n  switch (pieces.length) {\n    case 2:\n      {\n        //UR:Type/[Fragment]\n        checkURHeader(pieces[0], type);\n        return pieces[1];\n      }\n\n    case 3:\n      {\n        //UR:Type/[Digest]/[Fragment] when Sequencing is omitted, Digest MAY be omitted;\n        //should check digest\n        checkURHeader(pieces[0], type);\n        var digest = pieces[1];\n        var fragment = pieces[2];\n        checkDigest(digest, fragment);\n        return fragment;\n      }\n\n    case 4:\n      {\n        //UR:Type/[Sequencing]/[Digest]/[Fragment]\n        //should check sequencing and digest\n        checkURHeader(pieces[0], type);\n        checkAndGetSequence(pieces[1]);\n        var digest = pieces[2];\n        var fragment = pieces[3];\n        checkDigest(digest, fragment);\n        return fragment;\n      }\n\n    default:\n      throw new Error(\"invalid workload pieces length: expect 2 / 3 / 4 bug got \" + pieces.length);\n  }\n};\n\nvar dealWithMultipleWorkloads = function (workloads, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  var length = workloads.length;\n  var fragments = new Array(length).fill('');\n  var digest = '';\n  workloads.forEach(function (workload) {\n    var pieces = workload.split('/');\n    checkURHeader(pieces[0], type);\n\n    var _a = checkAndGetSequence(pieces[1]),\n        index = _a[0],\n        total = _a[1];\n\n    if (total !== length) throw new Error(\"invalid workload: \" + workload + \", total \" + total + \" not equal workloads length \" + length);\n    if (digest && digest !== pieces[2]) throw new Error(\"invalid workload: \" + workload + \", checksum changed \" + digest + \", \" + pieces[2]);\n    digest = pieces[2];\n    if (fragments[index - 1]) throw new Error(\"invalid workload: \" + workload + \", index \" + index + \" has already been set\");\n    fragments[index - 1] = pieces[3];\n  });\n  var payload = fragments.join('');\n  checkDigest(digest, payload);\n  return payload;\n};\n\nvar getBC32Payload = function (workloads, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  try {\n    var length_1 = workloads.length;\n\n    if (length_1 === 1) {\n      return dealWithSingleWorkload(workloads[0], type);\n    } else {\n      return dealWithMultipleWorkloads(workloads, type);\n    }\n  } catch (e) {\n    throw new Error(\"invalid workloads: \" + workloads + \"\\n \" + e);\n  }\n};\n\nvar decodeUR = function (workloads, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  var bc32Payload = getBC32Payload(workloads, type);\n  var cborPayload = bc_bech32_1.decodeBc32Data(bc32Payload);\n\n  if (!cborPayload) {\n    throw new Error('invalid data');\n  }\n\n  return miniCbor_1.decodeSimpleCBOR(cborPayload);\n};\n\nexports.decodeUR = decodeUR;\n\nvar onlyUniq = function (value, index, self) {\n  return self.indexOf(value) === index;\n};\n\nvar smartDecodeUR = function (workloads) {\n  if (workloads.length > 0) {\n    var _a = exports.extractSingleWorkload(workloads[0]),\n        index = _a[0],\n        total = _a[1];\n\n    if (workloads.length === total) {\n      return {\n        success: true,\n        current: workloads.length,\n        length: total,\n        workloads: [],\n        result: exports.decodeUR(workloads)\n      };\n    } else {\n      return {\n        success: false,\n        current: workloads.length,\n        length: total,\n        workloads: workloads.filter(onlyUniq),\n        result: ''\n      };\n    }\n  } else {\n    return {\n      success: false,\n      current: 0,\n      length: 0,\n      workloads: [],\n      result: ''\n    };\n  }\n};\n\nexports.smartDecodeUR = smartDecodeUR;\n\nvar extractSingleWorkload = function (workload) {\n  var pieces = workload.toUpperCase().split('/');\n\n  switch (pieces.length) {\n    case 2: //UR:Type/[Fragment]\n\n    case 3:\n      {\n        //UR:Type/[Digest]/[Fragment] when Sequencing is omitted, Digest MAY be omitted;\n        return [1, 1];\n      }\n\n    case 4:\n      {\n        //UR:Type/[Sequencing]/[Digest]/[Fragment]\n        return checkAndGetSequence(pieces[1]);\n      }\n\n    default:\n      throw new Error(\"invalid workload pieces length: expect 2 / 3 / 4 bug got \" + pieces.length);\n  }\n};\n\nexports.extractSingleWorkload = extractSingleWorkload;","map":{"version":3,"sources":["../src/decodeUR.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extractSingleWorkload = exports.smartDecodeUR = exports.decodeUR = void 0;\nvar utils_1 = require(\"./utils\");\nvar miniCbor_1 = require(\"./miniCbor\");\nvar bc_bech32_1 = require(\"@cvbb/bc-bech32\");\nvar checkAndGetSequence = function (sequence) {\n    var pieces = sequence.toUpperCase().split('OF');\n    if (pieces.length !== 2)\n        throw new Error(\"invalid sequence: \" + sequence);\n    var index = pieces[0], total = pieces[1];\n    return [+index, +total];\n};\nvar checkDigest = function (digest, payload) {\n    var decoded = bc_bech32_1.decodeBc32Data(payload);\n    if (!decoded)\n        throw new Error(\"can not decode payload: \" + payload);\n    if (bc_bech32_1.decodeBc32Data(digest) !== utils_1.sha256Hash(Buffer.from(decoded, 'hex')).toString('hex')) {\n        throw new Error(\"invalid digest: \\n digest:\" + digest + \" \\n payload:\" + payload);\n    }\n};\nvar checkURHeader = function (UR, type) {\n    if (type === void 0) { type = 'bytes'; }\n    if (UR.toUpperCase() !== (\"ur:\" + type).toUpperCase())\n        throw new Error(\"invalid UR header: \" + UR);\n};\nvar dealWithSingleWorkload = function (workload, type) {\n    if (type === void 0) { type = 'bytes'; }\n    var pieces = workload.split('/');\n    switch (pieces.length) {\n        case 2: {\n            //UR:Type/[Fragment]\n            checkURHeader(pieces[0], type);\n            return pieces[1];\n        }\n        case 3: {\n            //UR:Type/[Digest]/[Fragment] when Sequencing is omitted, Digest MAY be omitted;\n            //should check digest\n            checkURHeader(pieces[0], type);\n            var digest = pieces[1];\n            var fragment = pieces[2];\n            checkDigest(digest, fragment);\n            return fragment;\n        }\n        case 4: {\n            //UR:Type/[Sequencing]/[Digest]/[Fragment]\n            //should check sequencing and digest\n            checkURHeader(pieces[0], type);\n            checkAndGetSequence(pieces[1]);\n            var digest = pieces[2];\n            var fragment = pieces[3];\n            checkDigest(digest, fragment);\n            return fragment;\n        }\n        default:\n            throw new Error(\"invalid workload pieces length: expect 2 / 3 / 4 bug got \" + pieces.length);\n    }\n};\nvar dealWithMultipleWorkloads = function (workloads, type) {\n    if (type === void 0) { type = 'bytes'; }\n    var length = workloads.length;\n    var fragments = new Array(length).fill('');\n    var digest = '';\n    workloads.forEach(function (workload) {\n        var pieces = workload.split('/');\n        checkURHeader(pieces[0], type);\n        var _a = checkAndGetSequence(pieces[1]), index = _a[0], total = _a[1];\n        if (total !== length)\n            throw new Error(\"invalid workload: \" + workload + \", total \" + total + \" not equal workloads length \" + length);\n        if (digest && digest !== pieces[2])\n            throw new Error(\"invalid workload: \" + workload + \", checksum changed \" + digest + \", \" + pieces[2]);\n        digest = pieces[2];\n        if (fragments[index - 1])\n            throw new Error(\"invalid workload: \" + workload + \", index \" + index + \" has already been set\");\n        fragments[index - 1] = pieces[3];\n    });\n    var payload = fragments.join('');\n    checkDigest(digest, payload);\n    return payload;\n};\nvar getBC32Payload = function (workloads, type) {\n    if (type === void 0) { type = 'bytes'; }\n    try {\n        var length_1 = workloads.length;\n        if (length_1 === 1) {\n            return dealWithSingleWorkload(workloads[0], type);\n        }\n        else {\n            return dealWithMultipleWorkloads(workloads, type);\n        }\n    }\n    catch (e) {\n        throw new Error(\"invalid workloads: \" + workloads + \"\\n \" + e);\n    }\n};\nvar decodeUR = function (workloads, type) {\n    if (type === void 0) { type = 'bytes'; }\n    var bc32Payload = getBC32Payload(workloads, type);\n    var cborPayload = bc_bech32_1.decodeBc32Data(bc32Payload);\n    if (!cborPayload) {\n        throw new Error('invalid data');\n    }\n    return miniCbor_1.decodeSimpleCBOR(cborPayload);\n};\nexports.decodeUR = decodeUR;\nvar onlyUniq = function (value, index, self) {\n    return self.indexOf(value) === index;\n};\nvar smartDecodeUR = function (workloads) {\n    if (workloads.length > 0) {\n        var _a = exports.extractSingleWorkload(workloads[0]), index = _a[0], total = _a[1];\n        if (workloads.length === total) {\n            return {\n                success: true,\n                current: workloads.length,\n                length: total,\n                workloads: [],\n                result: exports.decodeUR(workloads),\n            };\n        }\n        else {\n            return {\n                success: false,\n                current: workloads.length,\n                length: total,\n                workloads: workloads.filter(onlyUniq),\n                result: '',\n            };\n        }\n    }\n    else {\n        return {\n            success: false,\n            current: 0,\n            length: 0,\n            workloads: [],\n            result: '',\n        };\n    }\n};\nexports.smartDecodeUR = smartDecodeUR;\nvar extractSingleWorkload = function (workload) {\n    var pieces = workload.toUpperCase().split('/');\n    switch (pieces.length) {\n        case 2: //UR:Type/[Fragment]\n        case 3: {\n            //UR:Type/[Digest]/[Fragment] when Sequencing is omitted, Digest MAY be omitted;\n            return [1, 1];\n        }\n        case 4: {\n            //UR:Type/[Sequencing]/[Digest]/[Fragment]\n            return checkAndGetSequence(pieces[1]);\n        }\n        default:\n            throw new Error(\"invalid workload pieces length: expect 2 / 3 / 4 bug got \" + pieces.length);\n    }\n};\nexports.extractSingleWorkload = extractSingleWorkload;\n//# sourceMappingURL=decodeUR.js.map"]},"metadata":{},"sourceType":"script"}