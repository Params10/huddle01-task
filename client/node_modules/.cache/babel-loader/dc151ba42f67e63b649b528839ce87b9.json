{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TXs = void 0;\n\nconst methods_1 = require(\"../communication/methods\");\n\nclass TXs {\n  constructor(communicator) {\n    this.txServiceUrl = null;\n    this.communicator = communicator;\n  }\n\n  async getBySafeTxHash(safeTxHash) {\n    if (!this.txServiceUrl) {\n      throw new Error(\"ENV information hasn't been synced yet or there was an error during the process\");\n    }\n\n    const controller = new AbortController();\n    const options = {\n      method: 'GET',\n      signal: controller.signal\n    };\n    setTimeout(() => controller.abort(), 10000);\n\n    try {\n      const res = await fetch(`${this.txServiceUrl}/transactions/${safeTxHash}`, options);\n\n      if (res.status !== 200) {\n        throw new Error(\"Failed to get the transaction. Either safeTxHash is incorrect or transaction hasn't been indexed by the service yet\");\n      }\n\n      const json = await res.json();\n      return json;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  async send({\n    txs,\n    params\n  }) {\n    if (!txs || !txs.length) {\n      throw new Error('No transactions were passed');\n    }\n\n    const messagePayload = {\n      txs,\n      params\n    };\n    const response = await this.communicator.send(methods_1.METHODS.sendTransactions, messagePayload);\n\n    if (!response.success) {\n      throw new Error(response.error);\n    }\n\n    return response.data;\n  }\n\n  setTxServiceUrl(url) {\n    this.txServiceUrl = url;\n  }\n\n}\n\nexports.TXs = TXs;","map":{"version":3,"sources":["../../../src/txs/index.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAGA,MAAM,GAAN,CAAS;AAIP,EAAA,WAAA,CAAY,YAAZ,EAAsC;AAH9B,SAAA,YAAA,GAA8B,IAA9B;AAIN,SAAK,YAAL,GAAoB,YAApB;AACD;;AAEoB,QAAf,eAAe,CAAC,UAAD,EAAmB;AACtC,QAAI,CAAC,KAAK,YAAV,EAAwB;AACtB,YAAM,IAAI,KAAJ,CAAU,iFAAV,CAAN;AACD;;AAED,UAAM,UAAU,GAAG,IAAI,eAAJ,EAAnB;AACA,UAAM,OAAO,GAAG;AACd,MAAA,MAAM,EAAE,KADM;AAEd,MAAA,MAAM,EAAE,UAAU,CAAC;AAFL,KAAhB;AAIA,IAAA,UAAU,CAAC,MAAM,UAAU,CAAC,KAAX,EAAP,EAA2B,KAA3B,CAAV;;AAEA,QAAI;AACF,YAAM,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,KAAK,YAAY,iBAAiB,UAAU,EAAhD,EAAoD,OAApD,CAAvB;;AACA,UAAI,GAAG,CAAC,MAAJ,KAAe,GAAnB,EAAwB;AACtB,cAAM,IAAI,KAAJ,CACJ,qHADI,CAAN;AAGD;;AAED,YAAM,IAAI,GAAG,MAAM,GAAG,CAAC,IAAJ,EAAnB;AAEA,aAAO,IAAP;AACD,KAXD,CAWE,OAAO,GAAP,EAAY;AACZ,YAAM,GAAN;AACD;AACF;;AAES,QAAJ,IAAI,CAAC;AAAE,IAAA,GAAF;AAAO,IAAA;AAAP,GAAD,EAAsC;AAC9C,QAAI,CAAC,GAAD,IAAQ,CAAC,GAAG,CAAC,MAAjB,EAAyB;AACvB,YAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,UAAM,cAAc,GAAG;AACrB,MAAA,GADqB;AAErB,MAAA;AAFqB,KAAvB;AAKA,UAAM,QAAQ,GAAG,MAAM,KAAK,YAAL,CAAkB,IAAlB,CACrB,SAAA,CAAA,OAAA,CAAQ,gBADa,EAErB,cAFqB,CAAvB;;AAKA,QAAI,CAAC,QAAQ,CAAC,OAAd,EAAuB;AACrB,YAAM,IAAI,KAAJ,CAAU,QAAQ,CAAC,KAAnB,CAAN;AACD;;AAED,WAAO,QAAQ,CAAC,IAAhB;AACD;;AAEM,EAAA,eAAe,CAAC,GAAD,EAAY;AAChC,SAAK,YAAL,GAAoB,GAApB;AACD;;AA5DM;;AA+DA,OAAA,CAAA,GAAA,GAAA,GAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TXs = void 0;\nconst methods_1 = require(\"../communication/methods\");\nclass TXs {\n    constructor(communicator) {\n        this.txServiceUrl = null;\n        this.communicator = communicator;\n    }\n    async getBySafeTxHash(safeTxHash) {\n        if (!this.txServiceUrl) {\n            throw new Error(\"ENV information hasn't been synced yet or there was an error during the process\");\n        }\n        const controller = new AbortController();\n        const options = {\n            method: 'GET',\n            signal: controller.signal,\n        };\n        setTimeout(() => controller.abort(), 10000);\n        try {\n            const res = await fetch(`${this.txServiceUrl}/transactions/${safeTxHash}`, options);\n            if (res.status !== 200) {\n                throw new Error(\"Failed to get the transaction. Either safeTxHash is incorrect or transaction hasn't been indexed by the service yet\");\n            }\n            const json = await res.json();\n            return json;\n        }\n        catch (err) {\n            throw err;\n        }\n    }\n    async send({ txs, params }) {\n        if (!txs || !txs.length) {\n            throw new Error('No transactions were passed');\n        }\n        const messagePayload = {\n            txs,\n            params,\n        };\n        const response = await this.communicator.send(methods_1.METHODS.sendTransactions, messagePayload);\n        if (!response.success) {\n            throw new Error(response.error);\n        }\n        return response.data;\n    }\n    setTxServiceUrl(url) {\n        this.txServiceUrl = url;\n    }\n}\nexports.TXs = TXs;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}