{"ast":null,"code":"\"use strict\";\n\n(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    global.CBOR = factory();\n  }\n})(this, function () {\n  const {\n    DataItem\n  } = require('./DataItem');\n\n  var CBOR = function () {\n    function BinaryHex(hex) {\n      this.$hex = hex;\n    }\n\n    BinaryHex.prototype = {\n      length: function () {\n        return this.$hex.length / 2;\n      },\n      toString: function (format) {\n        if (!format || format === 'hex' || format === 16) return this.$hex;\n\n        if (format === 'utf-8') {\n          var encoded = '';\n\n          for (var i = 0; i < this.$hex.length; i += 2) {\n            encoded += '%' + this.$hex.substring(i, i + 2);\n          }\n\n          return decodeURIComponent(encoded);\n        }\n\n        if (format === 'latin') {\n          var encoded = [];\n\n          for (var i = 0; i < this.$hex.length; i += 2) {\n            encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));\n          }\n\n          return String.fromCharCode.apply(String, encoded);\n        }\n\n        throw new Error('Unrecognised format: ' + format);\n      }\n    };\n\n    BinaryHex.fromLatinString = function (latinString) {\n      var hex = '';\n\n      for (var i = 0; i < latinString.length; i++) {\n        var pair = latinString.charCodeAt(i).toString(16);\n        if (pair.length === 1) pair = '0' + pair;\n        hex += pair;\n      }\n\n      return new BinaryHex(hex);\n    };\n\n    BinaryHex.fromUtf8String = function (utf8String) {\n      var encoded = encodeURIComponent(utf8String);\n      var hex = '';\n\n      for (var i = 0; i < encoded.length; i++) {\n        if (encoded.charAt(i) === '%') {\n          hex += encoded.substring(i + 1, i + 3);\n          i += 2;\n        } else {\n          var hexPair = encoded.charCodeAt(i).toString(16);\n          if (hexPair.length < 2) hexPair = '0' + hexPair;\n          hex += hexPair;\n        }\n      }\n\n      return new BinaryHex(hex);\n    };\n\n    var semanticEncoders = [];\n    var semanticDecoders = {};\n\n    var notImplemented = function (label) {\n      return function () {\n        throw new Error(label + ' not implemented');\n      };\n    };\n\n    function Reader() {}\n\n    Reader.prototype = {\n      peekByte: notImplemented('peekByte'),\n      readByte: notImplemented('readByte'),\n      readChunk: notImplemented('readChunk'),\n      readFloat16: function () {\n        var half = this.readUint16();\n        var exponent = (half & 0x7fff) >> 10;\n        var mantissa = half & 0x3ff;\n        var negative = half & 0x8000;\n\n        if (exponent === 0x1f) {\n          if (mantissa === 0) {\n            return negative ? -Infinity : Infinity;\n          }\n\n          return NaN;\n        }\n\n        var magnitude = exponent ? Math.pow(2, exponent - 25) * (1024 + mantissa) : Math.pow(2, -24) * mantissa;\n        return negative ? -magnitude : magnitude;\n      },\n      readFloat32: function () {\n        var intValue = this.readUint32();\n        var exponent = (intValue & 0x7fffffff) >> 23;\n        var mantissa = intValue & 0x7fffff;\n        var negative = intValue & 0x80000000;\n\n        if (exponent === 0xff) {\n          if (mantissa === 0) {\n            return negative ? -Infinity : Infinity;\n          }\n\n          return NaN;\n        }\n\n        var magnitude = exponent ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa) : Math.pow(2, -23 - 126) * mantissa;\n        return negative ? -magnitude : magnitude;\n      },\n      readFloat64: function () {\n        var int1 = this.readUint32(),\n            int2 = this.readUint32();\n        var exponent = int1 >> 20 & 0x7ff;\n        var mantissa = (int1 & 0xfffff) * 4294967296 + int2;\n        var negative = int1 & 0x80000000;\n\n        if (exponent === 0x7ff) {\n          if (mantissa === 0) {\n            return negative ? -Infinity : Infinity;\n          }\n\n          return NaN;\n        }\n\n        var magnitude = exponent ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa) : Math.pow(2, -52 - 1022) * mantissa;\n        return negative ? -magnitude : magnitude;\n      },\n      readUint16: function () {\n        return this.readByte() * 256 + this.readByte();\n      },\n      readUint32: function () {\n        return this.readUint16() * 65536 + this.readUint16();\n      },\n      readUint64: function () {\n        return this.readUint32() * 4294967296 + this.readUint32();\n      }\n    };\n\n    function Writer() {}\n\n    Writer.prototype = {\n      writeByte: notImplemented('writeByte'),\n      result: notImplemented('result'),\n      writeFloat16: notImplemented('writeFloat16'),\n      writeFloat32: notImplemented('writeFloat32'),\n      writeFloat64: notImplemented('writeFloat64'),\n      writeUint16: function (value) {\n        this.writeByte(value >> 8 & 0xff);\n        this.writeByte(value & 0xff);\n      },\n      writeUint32: function (value) {\n        this.writeUint16(value >> 16 & 0xffff);\n        this.writeUint16(value & 0xffff);\n      },\n      writeUint64: function (value) {\n        if (value >= 9007199254740992 || value <= -9007199254740992) {\n          throw new Error('Cannot encode Uint64 of: ' + value + ' magnitude to big (floating point errors)');\n        }\n\n        this.writeUint32(Math.floor(value / 4294967296));\n        this.writeUint32(value % 4294967296);\n      },\n      writeString: notImplemented('writeString'),\n      canWriteBinary: function (chunk) {\n        return false;\n      },\n      writeBinary: notImplemented('writeChunk')\n    };\n\n    function readHeaderRaw(reader) {\n      var firstByte = reader.readByte();\n      var majorType = firstByte >> 5,\n          value = firstByte & 0x1f;\n      return {\n        type: majorType,\n        value: value\n      };\n    }\n\n    function valueFromHeader(header, reader) {\n      var value = header.value;\n\n      if (value < 24) {\n        return value;\n      } else if (value == 24) {\n        return reader.readByte();\n      } else if (value == 25) {\n        return reader.readUint16();\n      } else if (value == 26) {\n        return reader.readUint32();\n      } else if (value == 27) {\n        return reader.readUint64();\n      } else if (value == 31) {\n        return null;\n      }\n\n      notImplemented('Additional info: ' + value)();\n    }\n\n    function writeHeaderRaw(type, value, writer) {\n      writer.writeByte(type << 5 | value);\n    }\n\n    function writeHeader(type, value, writer) {\n      var firstByte = type << 5;\n\n      if (value < 24) {\n        writer.writeByte(firstByte | value);\n      } else if (value < 256) {\n        writer.writeByte(firstByte | 24);\n        writer.writeByte(value);\n      } else if (value < 65536) {\n        writer.writeByte(firstByte | 25);\n        writer.writeUint16(value);\n      } else if (value < 4294967296) {\n        writer.writeByte(firstByte | 26);\n        writer.writeUint32(value);\n      } else {\n        writer.writeByte(firstByte | 27);\n        writer.writeUint64(value);\n      }\n    }\n\n    var stopCode = new Error();\n\n    function decodeReader(reader) {\n      var header = readHeaderRaw(reader);\n\n      switch (header.type) {\n        case 0:\n          return valueFromHeader(header, reader);\n\n        case 1:\n          return -1 - valueFromHeader(header, reader);\n\n        case 2:\n          return reader.readChunk(valueFromHeader(header, reader));\n\n        case 3:\n          var buffer = reader.readChunk(valueFromHeader(header, reader));\n          return buffer.toString('utf-8');\n\n        case 4:\n        case 5:\n          var arrayLength = valueFromHeader(header, reader);\n          var result = [];\n\n          if (arrayLength !== null) {\n            if (header.type === 5) {\n              arrayLength *= 2;\n            }\n\n            for (var i = 0; i < arrayLength; i++) {\n              result[i] = decodeReader(reader);\n            }\n          } else {\n            var item;\n\n            while ((item = decodeReader(reader)) !== stopCode) {\n              result.push(item);\n            }\n          }\n\n          if (header.type === 5) {\n            var objResult = {};\n\n            for (var i = 0; i < result.length; i += 2) {\n              objResult[result[i]] = result[i + 1];\n            }\n\n            return objResult;\n          } else {\n            return result;\n          }\n\n        case 6:\n          var tag = valueFromHeader(header, reader);\n          var decoder = semanticDecoders[tag];\n          var result = decodeReader(reader);\n          return decoder ? decoder(result) : result;\n\n        case 7:\n          if (header.value === 25) {\n            return reader.readFloat16();\n          } else if (header.value === 26) {\n            return reader.readFloat32();\n          } else if (header.value === 27) {\n            return reader.readFloat64();\n          }\n\n          switch (valueFromHeader(header, reader)) {\n            case 20:\n              return false;\n\n            case 21:\n              return true;\n\n            case 22:\n              return null;\n\n            case 23:\n              return undefined;\n\n            case null:\n              return stopCode;\n\n            default:\n              throw new Error('Unknown fixed value: ' + header.value);\n          }\n\n        default:\n          throw new Error('Unsupported header: ' + JSON.stringify(header));\n      }\n\n      throw new Error('not implemented yet');\n    }\n\n    function encodeWriter(data, writer) {\n      for (var i = 0; i < semanticEncoders.length; i++) {\n        var replacement = semanticEncoders[i].fn(data);\n\n        if (replacement !== undefined) {\n          writeHeader(6, semanticEncoders[i].tag, writer);\n          return encodeWriter(replacement, writer);\n        }\n      }\n\n      if (data && typeof data.toCBOR === 'function') {\n        data = data.toCBOR();\n      }\n\n      if (data === false) {\n        writeHeader(7, 20, writer);\n      } else if (data === true) {\n        writeHeader(7, 21, writer);\n      } else if (data === null) {\n        writeHeader(7, 22, writer);\n      } else if (data === undefined) {\n        writeHeader(7, 23, writer);\n      } else if (typeof data === 'number') {\n        if (Math.floor(data) === data && data < 9007199254740992 && data > -9007199254740992) {\n          if (data < 0) {\n            writeHeader(1, -1 - data, writer);\n          } else {\n            writeHeader(0, data, writer);\n          }\n        } else {\n          writeHeaderRaw(7, 27, writer);\n          writer.writeFloat64(data);\n        }\n      } else if (typeof data === 'string') {\n        writer.writeString(data, function (length) {\n          writeHeader(3, length, writer);\n        });\n      } else if (writer.canWriteBinary(data)) {\n        writer.writeBinary(data, function (length) {\n          writeHeader(2, length, writer);\n        });\n      } else if (typeof data === 'object') {\n        if (api.config.useToJSON && typeof data.toJSON === 'function') {\n          data = data.toJSON();\n        }\n\n        if (Array.isArray(data)) {\n          writeHeader(4, data.length, writer);\n\n          for (var i = 0; i < data.length; i++) {\n            encodeWriter(data[i], writer);\n          }\n        } else {\n          var keys = Object.keys(data);\n          writeHeader(5, keys.length, writer);\n\n          for (var i = 0; i < keys.length; i++) {\n            const number = parseInt(keys[i]);\n\n            if (isNaN(number)) {\n              encodeWriter(keys[i], writer);\n              encodeWriter(data[keys[i]], writer);\n            } else {\n              encodeWriter(number, writer);\n              encodeWriter(data[keys[i]], writer);\n            }\n          }\n        }\n      } else {\n        throw new Error('CBOR encoding not supported: ' + data);\n      }\n    }\n\n    var readerFunctions = [];\n    var writerFunctions = [];\n    var api = {\n      config: {\n        useToJSON: true\n      },\n      addWriter: function (format, writerFunction) {\n        if (typeof format === 'string') {\n          writerFunctions.push(function (f) {\n            if (format === f) return writerFunction(f);\n          });\n        } else {\n          writerFunctions.push(format);\n        }\n      },\n      addReader: function (format, readerFunction) {\n        if (typeof format === 'string') {\n          readerFunctions.push(function (data, f) {\n            if (format === f) return readerFunction(data, f);\n          });\n        } else {\n          readerFunctions.push(format);\n        }\n      },\n      encode: function (data, format) {\n        for (var i = 0; i < writerFunctions.length; i++) {\n          var func = writerFunctions[i];\n          var writer = func(format);\n\n          if (writer) {\n            encodeWriter(data, writer);\n            return writer.result();\n          }\n        }\n\n        throw new Error('Unsupported output format: ' + format);\n      },\n      encodeDataItem: function (data, format) {\n        for (var i = 0; i < writerFunctions.length; i++) {\n          var func = writerFunctions[i];\n          var writer = func(format);\n\n          if (writer) {\n            if (data.getTag() !== undefined) {\n              encodeWriter(data, writer);\n              return writer.result();\n            } else {\n              encodeWriter(data.getData(), writer);\n              return writer.result();\n            }\n          }\n        }\n\n        throw new Error('Unsupported output format: ' + format);\n      },\n      decode: function (data, format) {\n        for (var i = 0; i < readerFunctions.length; i++) {\n          var func = readerFunctions[i];\n          var reader = func(data, format);\n\n          if (reader) {\n            return decodeReader(reader);\n          }\n        }\n\n        throw new Error('Unsupported input format: ' + format);\n      },\n      decodeToDataItem: function (data, format) {\n        for (var i = 0; i < readerFunctions.length; i++) {\n          var func = readerFunctions[i];\n          var reader = func(data, format);\n\n          if (reader) {\n            const result = decodeReader(reader);\n\n            if (result instanceof DataItem) {\n              return result;\n            } else {\n              return new DataItem(result);\n            }\n          }\n        }\n\n        throw new Error('Unsupported input format: ' + format);\n      },\n      addSemanticEncode: function (tag, fn) {\n        if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {\n          throw new Error('Tag must be a positive integer');\n        }\n\n        semanticEncoders.push({\n          tag: tag,\n          fn: fn\n        });\n        return this;\n      },\n      addSemanticDecode: function (tag, fn) {\n        if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {\n          throw new Error('Tag must be a positive integer');\n        }\n\n        semanticDecoders[tag] = fn;\n        return this;\n      },\n      Reader: Reader,\n      Writer: Writer\n    };\n\n    function BufferReader(buffer) {\n      this.buffer = buffer;\n      this.pos = 0;\n    }\n\n    BufferReader.prototype = Object.create(Reader.prototype);\n\n    BufferReader.prototype.peekByte = function () {\n      return this.buffer[this.pos];\n    };\n\n    BufferReader.prototype.readByte = function () {\n      return this.buffer[this.pos++];\n    };\n\n    BufferReader.prototype.readUint16 = function () {\n      var result = this.buffer.readUInt16BE(this.pos);\n      this.pos += 2;\n      return result;\n    };\n\n    BufferReader.prototype.readUint32 = function () {\n      var result = this.buffer.readUInt32BE(this.pos);\n      this.pos += 4;\n      return result;\n    };\n\n    BufferReader.prototype.readFloat32 = function () {\n      var result = this.buffer.readFloatBE(this.pos);\n      this.pos += 4;\n      return result;\n    };\n\n    BufferReader.prototype.readFloat64 = function () {\n      var result = this.buffer.readDoubleBE(this.pos);\n      this.pos += 8;\n      return result;\n    };\n\n    BufferReader.prototype.readChunk = function (length) {\n      var result = Buffer.alloc(length);\n      this.buffer.copy(result, 0, this.pos, this.pos += length);\n      return result;\n    };\n\n    function BufferWriter(stringFormat) {\n      this.byteLength = 0;\n      this.defaultBufferLength = 16384;\n      this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n      this.latestBufferOffset = 0;\n      this.completeBuffers = [];\n      this.stringFormat = stringFormat;\n    }\n\n    BufferWriter.prototype = Object.create(Writer.prototype);\n\n    BufferWriter.prototype.writeByte = function (value) {\n      this.latestBuffer[this.latestBufferOffset++] = value;\n\n      if (this.latestBufferOffset >= this.latestBuffer.length) {\n        this.completeBuffers.push(this.latestBuffer);\n        this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n        this.latestBufferOffset = 0;\n      }\n\n      this.byteLength++;\n    };\n\n    BufferWriter.prototype.writeFloat32 = function (value) {\n      var buffer = Buffer.alloc(4);\n      buffer.writeFloatBE(value, 0);\n      this.writeBuffer(buffer);\n    };\n\n    BufferWriter.prototype.writeFloat64 = function (value) {\n      var buffer = Buffer.alloc(8);\n      buffer.writeDoubleBE(value, 0);\n      this.writeBuffer(buffer);\n    };\n\n    BufferWriter.prototype.writeString = function (string, lengthFunc) {\n      var buffer = Buffer.from(string, 'utf-8');\n      lengthFunc(buffer.length);\n      this.writeBuffer(buffer);\n    };\n\n    BufferWriter.prototype.canWriteBinary = function (data) {\n      return data instanceof Buffer;\n    };\n\n    BufferWriter.prototype.writeBinary = function (buffer, lengthFunc) {\n      lengthFunc(buffer.length);\n      this.writeBuffer(buffer);\n    };\n\n    BufferWriter.prototype.writeBuffer = function (chunk) {\n      if (!(chunk instanceof Buffer)) throw new TypeError('BufferWriter only accepts Buffers');\n\n      if (!this.latestBufferOffset) {\n        this.completeBuffers.push(chunk);\n      } else if (this.latestBuffer.length - this.latestBufferOffset >= chunk.length) {\n        chunk.copy(this.latestBuffer, this.latestBufferOffset);\n        this.latestBufferOffset += chunk.length;\n\n        if (this.latestBufferOffset >= this.latestBuffer.length) {\n          this.completeBuffers.push(this.latestBuffer);\n          this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n          this.latestBufferOffset = 0;\n        }\n      } else {\n        this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));\n        this.completeBuffers.push(chunk);\n        this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n        this.latestBufferOffset = 0;\n      }\n\n      this.byteLength += chunk.length;\n    };\n\n    BufferWriter.prototype.result = function () {\n      var result = Buffer.alloc(this.byteLength);\n      var offset = 0;\n\n      for (var i = 0; i < this.completeBuffers.length; i++) {\n        var buffer = this.completeBuffers[i];\n        buffer.copy(result, offset, 0, buffer.length);\n        offset += buffer.length;\n      }\n\n      if (this.latestBufferOffset) {\n        this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);\n      }\n\n      if (this.stringFormat) return result.toString(this.stringFormat);\n      return result;\n    };\n\n    if (typeof Buffer === 'function') {\n      api.addReader(function (data, format) {\n        if (data instanceof Buffer) {\n          return new BufferReader(data);\n        }\n\n        if (format === 'hex' || format === 'base64') {\n          var buffer = Buffer.from(data, format);\n          return new BufferReader(buffer);\n        }\n      });\n      api.addWriter(function (format) {\n        if (!format || format === 'buffer') {\n          return new BufferWriter();\n        } else if (format === 'hex' || format === 'base64') {\n          return new BufferWriter(format);\n        }\n      });\n    }\n\n    function HexReader(hex) {\n      this.hex = hex;\n      this.pos = 0;\n    }\n\n    HexReader.prototype = Object.create(Reader.prototype);\n\n    HexReader.prototype.peekByte = function () {\n      var pair = this.hex.substring(this.pos, 2);\n      return parseInt(pair, 16);\n    };\n\n    HexReader.prototype.readByte = function () {\n      var pair = this.hex.substring(this.pos, this.pos + 2);\n      this.pos += 2;\n      return parseInt(pair, 16);\n    };\n\n    HexReader.prototype.readChunk = function (length) {\n      var hex = this.hex.substring(this.pos, this.pos + length * 2);\n      this.pos += length * 2;\n      if (typeof Buffer === 'function') return Buffer.from(hex, 'hex');\n      return new BinaryHex(hex);\n    };\n\n    function HexWriter(finalFormat) {\n      this.$hex = '';\n      this.finalFormat = finalFormat || 'hex';\n    }\n\n    HexWriter.prototype = Object.create(Writer.prototype);\n\n    HexWriter.prototype.writeByte = function (value) {\n      if (value < 0 || value > 255) throw new Error('Byte value out of range: ' + value);\n      var hex = value.toString(16);\n\n      if (hex.length == 1) {\n        hex = '0' + hex;\n      }\n\n      this.$hex += hex;\n    };\n\n    HexWriter.prototype.canWriteBinary = function (chunk) {\n      return chunk instanceof BinaryHex || typeof Buffer === 'function' && chunk instanceof Buffer;\n    };\n\n    HexWriter.prototype.writeBinary = function (chunk, lengthFunction) {\n      if (chunk instanceof BinaryHex) {\n        lengthFunction(chunk.length());\n        this.$hex += chunk.$hex;\n      } else if (typeof Buffer === 'function' && chunk instanceof Buffer) {\n        lengthFunction(chunk.length);\n        this.$hex += chunk.toString('hex');\n      } else {\n        throw new TypeError('HexWriter only accepts BinaryHex or Buffers');\n      }\n    };\n\n    HexWriter.prototype.result = function () {\n      if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {\n        return Buffer.from(this.$hex, 'hex');\n      }\n\n      return new BinaryHex(this.$hex).toString(this.finalFormat);\n    };\n\n    HexWriter.prototype.writeString = function (string, lengthFunction) {\n      var buffer = BinaryHex.fromUtf8String(string);\n      lengthFunction(buffer.length());\n      this.$hex += buffer.$hex;\n    };\n\n    api.addReader(function (data, format) {\n      if (data instanceof BinaryHex || data.$hex) {\n        return new HexReader(data.$hex);\n      }\n\n      if (format === 'hex') {\n        return new HexReader(data);\n      }\n    });\n    api.addWriter(function (format) {\n      if (format === 'hex') {\n        return new HexWriter();\n      }\n    });\n    return api;\n  }();\n\n  CBOR.addSemanticEncode(0, function (data) {\n    if (data instanceof Date) {\n      return data.toISOString();\n    }\n  }).addSemanticDecode(0, function (isoString) {\n    return new Date(isoString);\n  }).addSemanticDecode(1, function (isoString) {\n    return new Date(isoString);\n  });\n  return CBOR;\n});","map":{"version":3,"sources":["../../src/lib/cbor-sync.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    }\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    }\n    else {\n        global.CBOR = factory();\n    }\n})(this, function () {\n    const { DataItem } = require('./DataItem');\n    var CBOR = (function () {\n        function BinaryHex(hex) {\n            this.$hex = hex;\n        }\n        BinaryHex.prototype = {\n            length: function () {\n                return this.$hex.length / 2;\n            },\n            toString: function (format) {\n                if (!format || format === 'hex' || format === 16)\n                    return this.$hex;\n                if (format === 'utf-8') {\n                    var encoded = '';\n                    for (var i = 0; i < this.$hex.length; i += 2) {\n                        encoded += '%' + this.$hex.substring(i, i + 2);\n                    }\n                    return decodeURIComponent(encoded);\n                }\n                if (format === 'latin') {\n                    var encoded = [];\n                    for (var i = 0; i < this.$hex.length; i += 2) {\n                        encoded.push(parseInt(this.$hex.substring(i, i + 2), 16));\n                    }\n                    return String.fromCharCode.apply(String, encoded);\n                }\n                throw new Error('Unrecognised format: ' + format);\n            },\n        };\n        BinaryHex.fromLatinString = function (latinString) {\n            var hex = '';\n            for (var i = 0; i < latinString.length; i++) {\n                var pair = latinString.charCodeAt(i).toString(16);\n                if (pair.length === 1)\n                    pair = '0' + pair;\n                hex += pair;\n            }\n            return new BinaryHex(hex);\n        };\n        BinaryHex.fromUtf8String = function (utf8String) {\n            var encoded = encodeURIComponent(utf8String);\n            var hex = '';\n            for (var i = 0; i < encoded.length; i++) {\n                if (encoded.charAt(i) === '%') {\n                    hex += encoded.substring(i + 1, i + 3);\n                    i += 2;\n                }\n                else {\n                    var hexPair = encoded.charCodeAt(i).toString(16);\n                    if (hexPair.length < 2)\n                        hexPair = '0' + hexPair;\n                    hex += hexPair;\n                }\n            }\n            return new BinaryHex(hex);\n        };\n        var semanticEncoders = [];\n        var semanticDecoders = {};\n        var notImplemented = function (label) {\n            return function () {\n                throw new Error(label + ' not implemented');\n            };\n        };\n        function Reader() { }\n        Reader.prototype = {\n            peekByte: notImplemented('peekByte'),\n            readByte: notImplemented('readByte'),\n            readChunk: notImplemented('readChunk'),\n            readFloat16: function () {\n                var half = this.readUint16();\n                var exponent = (half & 0x7fff) >> 10;\n                var mantissa = half & 0x3ff;\n                var negative = half & 0x8000;\n                if (exponent === 0x1f) {\n                    if (mantissa === 0) {\n                        return negative ? -Infinity : Infinity;\n                    }\n                    return NaN;\n                }\n                var magnitude = exponent\n                    ? Math.pow(2, exponent - 25) * (1024 + mantissa)\n                    : Math.pow(2, -24) * mantissa;\n                return negative ? -magnitude : magnitude;\n            },\n            readFloat32: function () {\n                var intValue = this.readUint32();\n                var exponent = (intValue & 0x7fffffff) >> 23;\n                var mantissa = intValue & 0x7fffff;\n                var negative = intValue & 0x80000000;\n                if (exponent === 0xff) {\n                    if (mantissa === 0) {\n                        return negative ? -Infinity : Infinity;\n                    }\n                    return NaN;\n                }\n                var magnitude = exponent\n                    ? Math.pow(2, exponent - 23 - 127) * (8388608 + mantissa)\n                    : Math.pow(2, -23 - 126) * mantissa;\n                return negative ? -magnitude : magnitude;\n            },\n            readFloat64: function () {\n                var int1 = this.readUint32(), int2 = this.readUint32();\n                var exponent = (int1 >> 20) & 0x7ff;\n                var mantissa = (int1 & 0xfffff) * 4294967296 + int2;\n                var negative = int1 & 0x80000000;\n                if (exponent === 0x7ff) {\n                    if (mantissa === 0) {\n                        return negative ? -Infinity : Infinity;\n                    }\n                    return NaN;\n                }\n                var magnitude = exponent\n                    ? Math.pow(2, exponent - 52 - 1023) * (4503599627370496 + mantissa)\n                    : Math.pow(2, -52 - 1022) * mantissa;\n                return negative ? -magnitude : magnitude;\n            },\n            readUint16: function () {\n                return this.readByte() * 256 + this.readByte();\n            },\n            readUint32: function () {\n                return this.readUint16() * 65536 + this.readUint16();\n            },\n            readUint64: function () {\n                return this.readUint32() * 4294967296 + this.readUint32();\n            },\n        };\n        function Writer() { }\n        Writer.prototype = {\n            writeByte: notImplemented('writeByte'),\n            result: notImplemented('result'),\n            writeFloat16: notImplemented('writeFloat16'),\n            writeFloat32: notImplemented('writeFloat32'),\n            writeFloat64: notImplemented('writeFloat64'),\n            writeUint16: function (value) {\n                this.writeByte((value >> 8) & 0xff);\n                this.writeByte(value & 0xff);\n            },\n            writeUint32: function (value) {\n                this.writeUint16((value >> 16) & 0xffff);\n                this.writeUint16(value & 0xffff);\n            },\n            writeUint64: function (value) {\n                if (value >= 9007199254740992 || value <= -9007199254740992) {\n                    throw new Error('Cannot encode Uint64 of: ' +\n                        value +\n                        ' magnitude to big (floating point errors)');\n                }\n                this.writeUint32(Math.floor(value / 4294967296));\n                this.writeUint32(value % 4294967296);\n            },\n            writeString: notImplemented('writeString'),\n            canWriteBinary: function (chunk) {\n                return false;\n            },\n            writeBinary: notImplemented('writeChunk'),\n        };\n        function readHeaderRaw(reader) {\n            var firstByte = reader.readByte();\n            var majorType = firstByte >> 5, value = firstByte & 0x1f;\n            return { type: majorType, value: value };\n        }\n        function valueFromHeader(header, reader) {\n            var value = header.value;\n            if (value < 24) {\n                return value;\n            }\n            else if (value == 24) {\n                return reader.readByte();\n            }\n            else if (value == 25) {\n                return reader.readUint16();\n            }\n            else if (value == 26) {\n                return reader.readUint32();\n            }\n            else if (value == 27) {\n                return reader.readUint64();\n            }\n            else if (value == 31) {\n                return null;\n            }\n            notImplemented('Additional info: ' + value)();\n        }\n        function writeHeaderRaw(type, value, writer) {\n            writer.writeByte((type << 5) | value);\n        }\n        function writeHeader(type, value, writer) {\n            var firstByte = type << 5;\n            if (value < 24) {\n                writer.writeByte(firstByte | value);\n            }\n            else if (value < 256) {\n                writer.writeByte(firstByte | 24);\n                writer.writeByte(value);\n            }\n            else if (value < 65536) {\n                writer.writeByte(firstByte | 25);\n                writer.writeUint16(value);\n            }\n            else if (value < 4294967296) {\n                writer.writeByte(firstByte | 26);\n                writer.writeUint32(value);\n            }\n            else {\n                writer.writeByte(firstByte | 27);\n                writer.writeUint64(value);\n            }\n        }\n        var stopCode = new Error();\n        function decodeReader(reader) {\n            var header = readHeaderRaw(reader);\n            switch (header.type) {\n                case 0:\n                    return valueFromHeader(header, reader);\n                case 1:\n                    return -1 - valueFromHeader(header, reader);\n                case 2:\n                    return reader.readChunk(valueFromHeader(header, reader));\n                case 3:\n                    var buffer = reader.readChunk(valueFromHeader(header, reader));\n                    return buffer.toString('utf-8');\n                case 4:\n                case 5:\n                    var arrayLength = valueFromHeader(header, reader);\n                    var result = [];\n                    if (arrayLength !== null) {\n                        if (header.type === 5) {\n                            arrayLength *= 2;\n                        }\n                        for (var i = 0; i < arrayLength; i++) {\n                            result[i] = decodeReader(reader);\n                        }\n                    }\n                    else {\n                        var item;\n                        while ((item = decodeReader(reader)) !== stopCode) {\n                            result.push(item);\n                        }\n                    }\n                    if (header.type === 5) {\n                        var objResult = {};\n                        for (var i = 0; i < result.length; i += 2) {\n                            objResult[result[i]] = result[i + 1];\n                        }\n                        return objResult;\n                    }\n                    else {\n                        return result;\n                    }\n                case 6:\n                    var tag = valueFromHeader(header, reader);\n                    var decoder = semanticDecoders[tag];\n                    var result = decodeReader(reader);\n                    return decoder ? decoder(result) : result;\n                case 7:\n                    if (header.value === 25) {\n                        return reader.readFloat16();\n                    }\n                    else if (header.value === 26) {\n                        return reader.readFloat32();\n                    }\n                    else if (header.value === 27) {\n                        return reader.readFloat64();\n                    }\n                    switch (valueFromHeader(header, reader)) {\n                        case 20:\n                            return false;\n                        case 21:\n                            return true;\n                        case 22:\n                            return null;\n                        case 23:\n                            return undefined;\n                        case null:\n                            return stopCode;\n                        default:\n                            throw new Error('Unknown fixed value: ' + header.value);\n                    }\n                default:\n                    throw new Error('Unsupported header: ' + JSON.stringify(header));\n            }\n            throw new Error('not implemented yet');\n        }\n        function encodeWriter(data, writer) {\n            for (var i = 0; i < semanticEncoders.length; i++) {\n                var replacement = semanticEncoders[i].fn(data);\n                if (replacement !== undefined) {\n                    writeHeader(6, semanticEncoders[i].tag, writer);\n                    return encodeWriter(replacement, writer);\n                }\n            }\n            if (data && typeof data.toCBOR === 'function') {\n                data = data.toCBOR();\n            }\n            if (data === false) {\n                writeHeader(7, 20, writer);\n            }\n            else if (data === true) {\n                writeHeader(7, 21, writer);\n            }\n            else if (data === null) {\n                writeHeader(7, 22, writer);\n            }\n            else if (data === undefined) {\n                writeHeader(7, 23, writer);\n            }\n            else if (typeof data === 'number') {\n                if (Math.floor(data) === data &&\n                    data < 9007199254740992 &&\n                    data > -9007199254740992) {\n                    if (data < 0) {\n                        writeHeader(1, -1 - data, writer);\n                    }\n                    else {\n                        writeHeader(0, data, writer);\n                    }\n                }\n                else {\n                    writeHeaderRaw(7, 27, writer);\n                    writer.writeFloat64(data);\n                }\n            }\n            else if (typeof data === 'string') {\n                writer.writeString(data, function (length) {\n                    writeHeader(3, length, writer);\n                });\n            }\n            else if (writer.canWriteBinary(data)) {\n                writer.writeBinary(data, function (length) {\n                    writeHeader(2, length, writer);\n                });\n            }\n            else if (typeof data === 'object') {\n                if (api.config.useToJSON && typeof data.toJSON === 'function') {\n                    data = data.toJSON();\n                }\n                if (Array.isArray(data)) {\n                    writeHeader(4, data.length, writer);\n                    for (var i = 0; i < data.length; i++) {\n                        encodeWriter(data[i], writer);\n                    }\n                }\n                else {\n                    var keys = Object.keys(data);\n                    writeHeader(5, keys.length, writer);\n                    for (var i = 0; i < keys.length; i++) {\n                        const number = parseInt(keys[i]);\n                        if (isNaN(number)) {\n                            encodeWriter(keys[i], writer);\n                            encodeWriter(data[keys[i]], writer);\n                        }\n                        else {\n                            encodeWriter(number, writer);\n                            encodeWriter(data[keys[i]], writer);\n                        }\n                    }\n                }\n            }\n            else {\n                throw new Error('CBOR encoding not supported: ' + data);\n            }\n        }\n        var readerFunctions = [];\n        var writerFunctions = [];\n        var api = {\n            config: {\n                useToJSON: true,\n            },\n            addWriter: function (format, writerFunction) {\n                if (typeof format === 'string') {\n                    writerFunctions.push(function (f) {\n                        if (format === f)\n                            return writerFunction(f);\n                    });\n                }\n                else {\n                    writerFunctions.push(format);\n                }\n            },\n            addReader: function (format, readerFunction) {\n                if (typeof format === 'string') {\n                    readerFunctions.push(function (data, f) {\n                        if (format === f)\n                            return readerFunction(data, f);\n                    });\n                }\n                else {\n                    readerFunctions.push(format);\n                }\n            },\n            encode: function (data, format) {\n                for (var i = 0; i < writerFunctions.length; i++) {\n                    var func = writerFunctions[i];\n                    var writer = func(format);\n                    if (writer) {\n                        encodeWriter(data, writer);\n                        return writer.result();\n                    }\n                }\n                throw new Error('Unsupported output format: ' + format);\n            },\n            encodeDataItem: function (data, format) {\n                for (var i = 0; i < writerFunctions.length; i++) {\n                    var func = writerFunctions[i];\n                    var writer = func(format);\n                    if (writer) {\n                        if (data.getTag() !== undefined) {\n                            encodeWriter(data, writer);\n                            return writer.result();\n                        }\n                        else {\n                            encodeWriter(data.getData(), writer);\n                            return writer.result();\n                        }\n                    }\n                }\n                throw new Error('Unsupported output format: ' + format);\n            },\n            decode: function (data, format) {\n                for (var i = 0; i < readerFunctions.length; i++) {\n                    var func = readerFunctions[i];\n                    var reader = func(data, format);\n                    if (reader) {\n                        return decodeReader(reader);\n                    }\n                }\n                throw new Error('Unsupported input format: ' + format);\n            },\n            decodeToDataItem: function (data, format) {\n                for (var i = 0; i < readerFunctions.length; i++) {\n                    var func = readerFunctions[i];\n                    var reader = func(data, format);\n                    if (reader) {\n                        const result = decodeReader(reader);\n                        if (result instanceof DataItem) {\n                            return result;\n                        }\n                        else {\n                            return new DataItem(result);\n                        }\n                    }\n                }\n                throw new Error('Unsupported input format: ' + format);\n            },\n            addSemanticEncode: function (tag, fn) {\n                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {\n                    throw new Error('Tag must be a positive integer');\n                }\n                semanticEncoders.push({ tag: tag, fn: fn });\n                return this;\n            },\n            addSemanticDecode: function (tag, fn) {\n                if (typeof tag !== 'number' || tag % 1 !== 0 || tag < 0) {\n                    throw new Error('Tag must be a positive integer');\n                }\n                semanticDecoders[tag] = fn;\n                return this;\n            },\n            Reader: Reader,\n            Writer: Writer,\n        };\n        function BufferReader(buffer) {\n            this.buffer = buffer;\n            this.pos = 0;\n        }\n        BufferReader.prototype = Object.create(Reader.prototype);\n        BufferReader.prototype.peekByte = function () {\n            return this.buffer[this.pos];\n        };\n        BufferReader.prototype.readByte = function () {\n            return this.buffer[this.pos++];\n        };\n        BufferReader.prototype.readUint16 = function () {\n            var result = this.buffer.readUInt16BE(this.pos);\n            this.pos += 2;\n            return result;\n        };\n        BufferReader.prototype.readUint32 = function () {\n            var result = this.buffer.readUInt32BE(this.pos);\n            this.pos += 4;\n            return result;\n        };\n        BufferReader.prototype.readFloat32 = function () {\n            var result = this.buffer.readFloatBE(this.pos);\n            this.pos += 4;\n            return result;\n        };\n        BufferReader.prototype.readFloat64 = function () {\n            var result = this.buffer.readDoubleBE(this.pos);\n            this.pos += 8;\n            return result;\n        };\n        BufferReader.prototype.readChunk = function (length) {\n            var result = Buffer.alloc(length);\n            this.buffer.copy(result, 0, this.pos, (this.pos += length));\n            return result;\n        };\n        function BufferWriter(stringFormat) {\n            this.byteLength = 0;\n            this.defaultBufferLength = 16384;\n            this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n            this.latestBufferOffset = 0;\n            this.completeBuffers = [];\n            this.stringFormat = stringFormat;\n        }\n        BufferWriter.prototype = Object.create(Writer.prototype);\n        BufferWriter.prototype.writeByte = function (value) {\n            this.latestBuffer[this.latestBufferOffset++] = value;\n            if (this.latestBufferOffset >= this.latestBuffer.length) {\n                this.completeBuffers.push(this.latestBuffer);\n                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n                this.latestBufferOffset = 0;\n            }\n            this.byteLength++;\n        };\n        BufferWriter.prototype.writeFloat32 = function (value) {\n            var buffer = Buffer.alloc(4);\n            buffer.writeFloatBE(value, 0);\n            this.writeBuffer(buffer);\n        };\n        BufferWriter.prototype.writeFloat64 = function (value) {\n            var buffer = Buffer.alloc(8);\n            buffer.writeDoubleBE(value, 0);\n            this.writeBuffer(buffer);\n        };\n        BufferWriter.prototype.writeString = function (string, lengthFunc) {\n            var buffer = Buffer.from(string, 'utf-8');\n            lengthFunc(buffer.length);\n            this.writeBuffer(buffer);\n        };\n        BufferWriter.prototype.canWriteBinary = function (data) {\n            return data instanceof Buffer;\n        };\n        BufferWriter.prototype.writeBinary = function (buffer, lengthFunc) {\n            lengthFunc(buffer.length);\n            this.writeBuffer(buffer);\n        };\n        BufferWriter.prototype.writeBuffer = function (chunk) {\n            if (!(chunk instanceof Buffer))\n                throw new TypeError('BufferWriter only accepts Buffers');\n            if (!this.latestBufferOffset) {\n                this.completeBuffers.push(chunk);\n            }\n            else if (this.latestBuffer.length - this.latestBufferOffset >=\n                chunk.length) {\n                chunk.copy(this.latestBuffer, this.latestBufferOffset);\n                this.latestBufferOffset += chunk.length;\n                if (this.latestBufferOffset >= this.latestBuffer.length) {\n                    this.completeBuffers.push(this.latestBuffer);\n                    this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n                    this.latestBufferOffset = 0;\n                }\n            }\n            else {\n                this.completeBuffers.push(this.latestBuffer.slice(0, this.latestBufferOffset));\n                this.completeBuffers.push(chunk);\n                this.latestBuffer = Buffer.alloc(this.defaultBufferLength);\n                this.latestBufferOffset = 0;\n            }\n            this.byteLength += chunk.length;\n        };\n        BufferWriter.prototype.result = function () {\n            var result = Buffer.alloc(this.byteLength);\n            var offset = 0;\n            for (var i = 0; i < this.completeBuffers.length; i++) {\n                var buffer = this.completeBuffers[i];\n                buffer.copy(result, offset, 0, buffer.length);\n                offset += buffer.length;\n            }\n            if (this.latestBufferOffset) {\n                this.latestBuffer.copy(result, offset, 0, this.latestBufferOffset);\n            }\n            if (this.stringFormat)\n                return result.toString(this.stringFormat);\n            return result;\n        };\n        if (typeof Buffer === 'function') {\n            api.addReader(function (data, format) {\n                if (data instanceof Buffer) {\n                    return new BufferReader(data);\n                }\n                if (format === 'hex' || format === 'base64') {\n                    var buffer = Buffer.from(data, format);\n                    return new BufferReader(buffer);\n                }\n            });\n            api.addWriter(function (format) {\n                if (!format || format === 'buffer') {\n                    return new BufferWriter();\n                }\n                else if (format === 'hex' || format === 'base64') {\n                    return new BufferWriter(format);\n                }\n            });\n        }\n        function HexReader(hex) {\n            this.hex = hex;\n            this.pos = 0;\n        }\n        HexReader.prototype = Object.create(Reader.prototype);\n        HexReader.prototype.peekByte = function () {\n            var pair = this.hex.substring(this.pos, 2);\n            return parseInt(pair, 16);\n        };\n        HexReader.prototype.readByte = function () {\n            var pair = this.hex.substring(this.pos, this.pos + 2);\n            this.pos += 2;\n            return parseInt(pair, 16);\n        };\n        HexReader.prototype.readChunk = function (length) {\n            var hex = this.hex.substring(this.pos, this.pos + length * 2);\n            this.pos += length * 2;\n            if (typeof Buffer === 'function')\n                return Buffer.from(hex, 'hex');\n            return new BinaryHex(hex);\n        };\n        function HexWriter(finalFormat) {\n            this.$hex = '';\n            this.finalFormat = finalFormat || 'hex';\n        }\n        HexWriter.prototype = Object.create(Writer.prototype);\n        HexWriter.prototype.writeByte = function (value) {\n            if (value < 0 || value > 255)\n                throw new Error('Byte value out of range: ' + value);\n            var hex = value.toString(16);\n            if (hex.length == 1) {\n                hex = '0' + hex;\n            }\n            this.$hex += hex;\n        };\n        HexWriter.prototype.canWriteBinary = function (chunk) {\n            return (chunk instanceof BinaryHex ||\n                (typeof Buffer === 'function' && chunk instanceof Buffer));\n        };\n        HexWriter.prototype.writeBinary = function (chunk, lengthFunction) {\n            if (chunk instanceof BinaryHex) {\n                lengthFunction(chunk.length());\n                this.$hex += chunk.$hex;\n            }\n            else if (typeof Buffer === 'function' && chunk instanceof Buffer) {\n                lengthFunction(chunk.length);\n                this.$hex += chunk.toString('hex');\n            }\n            else {\n                throw new TypeError('HexWriter only accepts BinaryHex or Buffers');\n            }\n        };\n        HexWriter.prototype.result = function () {\n            if (this.finalFormat === 'buffer' && typeof Buffer === 'function') {\n                return Buffer.from(this.$hex, 'hex');\n            }\n            return new BinaryHex(this.$hex).toString(this.finalFormat);\n        };\n        HexWriter.prototype.writeString = function (string, lengthFunction) {\n            var buffer = BinaryHex.fromUtf8String(string);\n            lengthFunction(buffer.length());\n            this.$hex += buffer.$hex;\n        };\n        api.addReader(function (data, format) {\n            if (data instanceof BinaryHex || data.$hex) {\n                return new HexReader(data.$hex);\n            }\n            if (format === 'hex') {\n                return new HexReader(data);\n            }\n        });\n        api.addWriter(function (format) {\n            if (format === 'hex') {\n                return new HexWriter();\n            }\n        });\n        return api;\n    })();\n    CBOR.addSemanticEncode(0, function (data) {\n        if (data instanceof Date) {\n            return data.toISOString();\n        }\n    })\n        .addSemanticDecode(0, function (isoString) {\n        return new Date(isoString);\n    })\n        .addSemanticDecode(1, function (isoString) {\n        return new Date(isoString);\n    });\n    return CBOR;\n});\n//# sourceMappingURL=cbor-sync.js.map"]},"metadata":{},"sourceType":"script"}