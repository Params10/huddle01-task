{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.binanceGetAddress = exports.binanceSignTx = exports.binanceGetAccountPaths = void 0;\n\nconst BinanceMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-binance_pb\"));\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\n\nconst bnbencoding_1 = require(\"./bnbencoding\");\n\nfunction binanceGetAccountPaths(msg) {\n  return [{\n    addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Binance\"), 0x80000000 + msg.accountIdx, 0, 0]\n  }];\n}\n\nexports.binanceGetAccountPaths = binanceGetAccountPaths;\n\nfunction binanceSignTx(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n      if (msg.testnet) throw new Error(\"testnet not supported\");\n      const partialTx = Object.assign({}, msg.tx);\n      if (!partialTx.data) partialTx.data = null;\n      if (!partialTx.memo) partialTx.memo = \"\";\n      if (!partialTx.sequence) partialTx.sequence = \"0\";\n      if (!partialTx.source) partialTx.source = \"0\";\n      if (!partialTx.account_number) throw new Error(\"account_number is required\");\n      if (!partialTx.chain_id) throw new Error(\"chain_id is required\");\n      const tx = partialTx;\n      if (tx.data) throw new Error(\"tx data field not supported\");\n      const signTx = new BinanceMessages.BinanceSignTx();\n      signTx.setAddressNList(msg.addressNList);\n      signTx.setAccountNumber(tx.account_number);\n      signTx.setChainId(tx.chain_id);\n      signTx.setSequence(tx.sequence);\n      if (tx.memo) signTx.setMemo(tx.memo); //verify not a batch tx\n\n      if (msg.tx.msgs.length > 1) throw new Error(\"Binance batch sending not supported!\");\n      let message = msg.tx.msgs[0]; //tell device not a batch tx\n\n      signTx.setMsgCount(1); //tell device im about to send a tx to sign\n\n      let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_BINANCESIGNTX, signTx, core.LONG_TIMEOUT,\n      /*omitLock=*/\n      true);\n      if (resp.message_type === core.Events.FAILURE) throw resp;\n      const outputAmount = new bignumber_js_1.default(message.outputs[0].coins[0].amount);\n      const inputAmount = new bignumber_js_1.default(message.inputs[0].coins[0].amount);\n      if (!outputAmount.isInteger()) throw new Error(\"Output amount must be an integer\");\n      if (!inputAmount.isInteger()) throw new Error(\"Input amount must be an integer\");\n      let coinOut = new BinanceMessages.BinanceTransferMsg.BinanceCoin();\n      coinOut.setAmount(outputAmount.toString());\n      coinOut.setDenom(message.outputs[0].coins[0].denom);\n      let outputs = new BinanceMessages.BinanceTransferMsg.BinanceInputOutput();\n      outputs.setAddress(message.outputs[0].address);\n      outputs.setCoinsList([coinOut]);\n      let coinIn = new BinanceMessages.BinanceTransferMsg.BinanceCoin();\n      coinIn.setAmount(inputAmount.toString());\n      coinIn.setDenom(message.inputs[0].coins[0].denom);\n      let inputs = new BinanceMessages.BinanceTransferMsg.BinanceInputOutput();\n      inputs.setAddress(message.inputs[0].address);\n      inputs.setCoinsList([coinIn]);\n      const send = new BinanceMessages.BinanceTransferMsg();\n      send.addInputs(inputs);\n      send.addOutputs(outputs); //sent tx to device\n\n      resp = yield transport.call(Messages.MessageType.MESSAGETYPE_BINANCETRANSFERMSG, send, core.LONG_TIMEOUT,\n      /*omitLock=*/\n      true);\n      if (resp.message_type === core.Events.FAILURE) throw resp;\n\n      if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_BINANCESIGNEDTX) {\n        throw new Error(`binance: unexpected response ${resp.message_type}`);\n      }\n\n      let signedTx = new BinanceMessages.BinanceSignedTx();\n      signedTx.setSignature(resp.message.signature);\n      signedTx.setPublicKey(resp.message.publicKey);\n      const serialized = bnbencoding_1.encodeBnbTx(tx, Buffer.from(signedTx.getPublicKey_asU8()), Buffer.from(signedTx.getSignature_asU8())).toString(\"hex\");\n      const out = Object.assign(Object.assign({}, tx), {\n        signatures: {\n          pub_key: signedTx.getPublicKey_asB64(),\n          signature: signedTx.getSignature_asB64()\n        },\n        serialized,\n        txid: crypto_js_1.default.SHA256(crypto_js_1.default.enc.Hex.parse(serialized)).toString()\n      });\n      return out;\n    }));\n  });\n}\n\nexports.binanceSignTx = binanceSignTx;\n\nfunction binanceGetAddress(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const getAddr = new BinanceMessages.BinanceGetAddress();\n    getAddr.setAddressNList(msg.addressNList);\n    getAddr.setShowDisplay(msg.showDisplay !== false);\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_BINANCEGETADDRESS, getAddr, core.LONG_TIMEOUT);\n    if (response.message_type === core.Events.FAILURE) throw response;\n    const binanceAddress = response.proto;\n    return core.mustBeDefined(binanceAddress.getAddress());\n  });\n}\n\nexports.binanceGetAddress = binanceGetAddress;","map":{"version":3,"sources":["../src/binance.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binanceGetAddress = exports.binanceSignTx = exports.binanceGetAccountPaths = void 0;\nconst BinanceMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-binance_pb\"));\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nconst bnbencoding_1 = require(\"./bnbencoding\");\nfunction binanceGetAccountPaths(msg) {\n    return [\n        {\n            addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Binance\"), 0x80000000 + msg.accountIdx, 0, 0],\n        },\n    ];\n}\nexports.binanceGetAccountPaths = binanceGetAccountPaths;\nfunction binanceSignTx(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n            if (msg.testnet)\n                throw new Error(\"testnet not supported\");\n            const partialTx = Object.assign({}, msg.tx);\n            if (!partialTx.data)\n                partialTx.data = null;\n            if (!partialTx.memo)\n                partialTx.memo = \"\";\n            if (!partialTx.sequence)\n                partialTx.sequence = \"0\";\n            if (!partialTx.source)\n                partialTx.source = \"0\";\n            if (!partialTx.account_number)\n                throw new Error(\"account_number is required\");\n            if (!partialTx.chain_id)\n                throw new Error(\"chain_id is required\");\n            const tx = partialTx;\n            if (tx.data)\n                throw new Error(\"tx data field not supported\");\n            const signTx = new BinanceMessages.BinanceSignTx();\n            signTx.setAddressNList(msg.addressNList);\n            signTx.setAccountNumber(tx.account_number);\n            signTx.setChainId(tx.chain_id);\n            signTx.setSequence(tx.sequence);\n            if (tx.memo)\n                signTx.setMemo(tx.memo);\n            //verify not a batch tx\n            if (msg.tx.msgs.length > 1)\n                throw new Error(\"Binance batch sending not supported!\");\n            let message = msg.tx.msgs[0];\n            //tell device not a batch tx\n            signTx.setMsgCount(1);\n            //tell device im about to send a tx to sign\n            let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_BINANCESIGNTX, signTx, core.LONG_TIMEOUT, \n            /*omitLock=*/ true);\n            if (resp.message_type === core.Events.FAILURE)\n                throw resp;\n            const outputAmount = new bignumber_js_1.default(message.outputs[0].coins[0].amount);\n            const inputAmount = new bignumber_js_1.default(message.inputs[0].coins[0].amount);\n            if (!outputAmount.isInteger())\n                throw new Error(\"Output amount must be an integer\");\n            if (!inputAmount.isInteger())\n                throw new Error(\"Input amount must be an integer\");\n            let coinOut = new BinanceMessages.BinanceTransferMsg.BinanceCoin();\n            coinOut.setAmount(outputAmount.toString());\n            coinOut.setDenom(message.outputs[0].coins[0].denom);\n            let outputs = new BinanceMessages.BinanceTransferMsg.BinanceInputOutput();\n            outputs.setAddress(message.outputs[0].address);\n            outputs.setCoinsList([coinOut]);\n            let coinIn = new BinanceMessages.BinanceTransferMsg.BinanceCoin();\n            coinIn.setAmount(inputAmount.toString());\n            coinIn.setDenom(message.inputs[0].coins[0].denom);\n            let inputs = new BinanceMessages.BinanceTransferMsg.BinanceInputOutput();\n            inputs.setAddress(message.inputs[0].address);\n            inputs.setCoinsList([coinIn]);\n            const send = new BinanceMessages.BinanceTransferMsg();\n            send.addInputs(inputs);\n            send.addOutputs(outputs);\n            //sent tx to device\n            resp = yield transport.call(Messages.MessageType.MESSAGETYPE_BINANCETRANSFERMSG, send, core.LONG_TIMEOUT, \n            /*omitLock=*/ true);\n            if (resp.message_type === core.Events.FAILURE)\n                throw resp;\n            if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_BINANCESIGNEDTX) {\n                throw new Error(`binance: unexpected response ${resp.message_type}`);\n            }\n            let signedTx = new BinanceMessages.BinanceSignedTx();\n            signedTx.setSignature(resp.message.signature);\n            signedTx.setPublicKey(resp.message.publicKey);\n            const serialized = bnbencoding_1.encodeBnbTx(tx, Buffer.from(signedTx.getPublicKey_asU8()), Buffer.from(signedTx.getSignature_asU8())).toString(\"hex\");\n            const out = Object.assign(Object.assign({}, tx), { signatures: {\n                    pub_key: signedTx.getPublicKey_asB64(),\n                    signature: signedTx.getSignature_asB64(),\n                }, serialized, txid: crypto_js_1.default.SHA256(crypto_js_1.default.enc.Hex.parse(serialized)).toString() });\n            return out;\n        }));\n    });\n}\nexports.binanceSignTx = binanceSignTx;\nfunction binanceGetAddress(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const getAddr = new BinanceMessages.BinanceGetAddress();\n        getAddr.setAddressNList(msg.addressNList);\n        getAddr.setShowDisplay(msg.showDisplay !== false);\n        const response = yield transport.call(Messages.MessageType.MESSAGETYPE_BINANCEGETADDRESS, getAddr, core.LONG_TIMEOUT);\n        if (response.message_type === core.Events.FAILURE)\n            throw response;\n        const binanceAddress = response.proto;\n        return core.mustBeDefined(binanceAddress.getAddress());\n    });\n}\nexports.binanceGetAddress = binanceGetAddress;\n//# sourceMappingURL=binance.js.map"]},"metadata":{},"sourceType":"script"}