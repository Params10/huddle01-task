{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoKeypath = void 0;\n\nconst lib_1 = require(\"./lib\");\n\nconst PathComponent_1 = require(\"./PathComponent\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"components\"] = 1] = \"components\";\n  Keys[Keys[\"source_fingerprint\"] = 2] = \"source_fingerprint\";\n  Keys[Keys[\"depth\"] = 3] = \"depth\";\n})(Keys || (Keys = {}));\n\nclass CryptoKeypath extends RegistryItem_1.RegistryItem {\n  constructor(components = [], sourceFingerprint, depth) {\n    super();\n    this.components = components;\n    this.sourceFingerprint = sourceFingerprint;\n    this.depth = depth;\n\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;\n    };\n\n    this.getPath = () => {\n      if (this.components.length === 0) {\n        return undefined;\n      }\n\n      const components = this.components.map(component => {\n        return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? \"'\" : ''}`;\n      });\n      return components.join('/');\n    };\n\n    this.getComponents = () => this.components;\n\n    this.getSourceFingerprint = () => this.sourceFingerprint;\n\n    this.getDepth = () => this.depth;\n\n    this.toDataItem = () => {\n      const map = {};\n      const components = [];\n      this.components && this.components.forEach(component => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex());\n        }\n\n        components.push(component.isHardened() ? true : false);\n      });\n      map[Keys.components] = components;\n\n      if (this.sourceFingerprint) {\n        map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n      }\n\n      if (this.depth !== undefined) {\n        map[Keys.depth] = this.depth;\n      }\n\n      return new lib_1.DataItem(map);\n    };\n  }\n\n}\n\nexports.CryptoKeypath = CryptoKeypath;\n\nCryptoKeypath.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const pathComponents = [];\n  const components = map[Keys.components];\n\n  if (components) {\n    for (let i = 0; i < components.length; i += 2) {\n      const isHardened = components[i + 1];\n      const path = components[i];\n\n      if (typeof path === 'number') {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          index: path,\n          hardened: isHardened\n        }));\n      } else {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          hardened: isHardened\n        }));\n      }\n    }\n  }\n\n  const _sourceFingerprint = map[Keys.source_fingerprint];\n  let sourceFingerprint;\n\n  if (_sourceFingerprint) {\n    sourceFingerprint = Buffer.alloc(4);\n    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n  }\n\n  const depth = map[Keys.depth];\n  return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n};\n\nCryptoKeypath.fromCBOR = _cborPayload => {\n  const dataItem = lib_1.decodeToDataItem(_cborPayload);\n  return CryptoKeypath.fromDataItem(dataItem);\n};","map":{"version":3,"sources":["../src/CryptoKeypath.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoKeypath = void 0;\nconst lib_1 = require(\"./lib\");\nconst PathComponent_1 = require(\"./PathComponent\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"components\"] = 1] = \"components\";\n    Keys[Keys[\"source_fingerprint\"] = 2] = \"source_fingerprint\";\n    Keys[Keys[\"depth\"] = 3] = \"depth\";\n})(Keys || (Keys = {}));\nclass CryptoKeypath extends RegistryItem_1.RegistryItem {\n    constructor(components = [], sourceFingerprint, depth) {\n        super();\n        this.components = components;\n        this.sourceFingerprint = sourceFingerprint;\n        this.depth = depth;\n        this.getRegistryType = () => {\n            return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;\n        };\n        this.getPath = () => {\n            if (this.components.length === 0) {\n                return undefined;\n            }\n            const components = this.components.map((component) => {\n                return `${component.isWildcard() ? '*' : component.getIndex()}${component.isHardened() ? \"'\" : ''}`;\n            });\n            return components.join('/');\n        };\n        this.getComponents = () => this.components;\n        this.getSourceFingerprint = () => this.sourceFingerprint;\n        this.getDepth = () => this.depth;\n        this.toDataItem = () => {\n            const map = {};\n            const components = [];\n            this.components &&\n                this.components.forEach((component) => {\n                    if (component.isWildcard()) {\n                        components.push([]);\n                    }\n                    else {\n                        components.push(component.getIndex());\n                    }\n                    components.push(component.isHardened() ? true : false);\n                });\n            map[Keys.components] = components;\n            if (this.sourceFingerprint) {\n                map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n            }\n            if (this.depth !== undefined) {\n                map[Keys.depth] = this.depth;\n            }\n            return new lib_1.DataItem(map);\n        };\n    }\n}\nexports.CryptoKeypath = CryptoKeypath;\nCryptoKeypath.fromDataItem = (dataItem) => {\n    const map = dataItem.getData();\n    const pathComponents = [];\n    const components = map[Keys.components];\n    if (components) {\n        for (let i = 0; i < components.length; i += 2) {\n            const isHardened = components[i + 1];\n            const path = components[i];\n            if (typeof path === 'number') {\n                pathComponents.push(new PathComponent_1.PathComponent({ index: path, hardened: isHardened }));\n            }\n            else {\n                pathComponents.push(new PathComponent_1.PathComponent({ hardened: isHardened }));\n            }\n        }\n    }\n    const _sourceFingerprint = map[Keys.source_fingerprint];\n    let sourceFingerprint;\n    if (_sourceFingerprint) {\n        sourceFingerprint = Buffer.alloc(4);\n        sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n    }\n    const depth = map[Keys.depth];\n    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n};\nCryptoKeypath.fromCBOR = (_cborPayload) => {\n    const dataItem = lib_1.decodeToDataItem(_cborPayload);\n    return CryptoKeypath.fromDataItem(dataItem);\n};\n//# sourceMappingURL=CryptoKeypath.js.map"]},"metadata":{},"sourceType":"script"}