{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoHDKey = void 0;\n\nconst bs58check_1 = require(\"bs58check\");\n\nconst CryptoCoinInfo_1 = require(\"./CryptoCoinInfo\");\n\nconst CryptoKeypath_1 = require(\"./CryptoKeypath\");\n\nconst lib_1 = require(\"./lib\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"is_master\"] = 1] = \"is_master\";\n  Keys[Keys[\"is_private\"] = 2] = \"is_private\";\n  Keys[Keys[\"key_data\"] = 3] = \"key_data\";\n  Keys[Keys[\"chain_code\"] = 4] = \"chain_code\";\n  Keys[Keys[\"use_info\"] = 5] = \"use_info\";\n  Keys[Keys[\"origin\"] = 6] = \"origin\";\n  Keys[Keys[\"children\"] = 7] = \"children\";\n  Keys[Keys[\"parent_fingerprint\"] = 8] = \"parent_fingerprint\";\n  Keys[Keys[\"name\"] = 9] = \"name\";\n  Keys[Keys[\"note\"] = 10] = \"note\";\n})(Keys || (Keys = {}));\n\nclass CryptoHDKey extends RegistryItem_1.RegistryItem {\n  constructor(args) {\n    super();\n\n    this.getKey = () => this.key;\n\n    this.getChainCode = () => this.chainCode;\n\n    this.isMaster = () => this.master;\n\n    this.isPrivateKey = () => !!this.privateKey;\n\n    this.getUseInfo = () => this.useInfo;\n\n    this.getOrigin = () => this.origin;\n\n    this.getChildren = () => this.children;\n\n    this.getParentFingerprint = () => this.parentFingerprint;\n\n    this.getName = () => this.name;\n\n    this.getNote = () => this.note;\n\n    this.getBip32Key = () => {\n      let version;\n      let depth;\n      let index;\n      let parentFingerprint = Buffer.alloc(4).fill(0);\n\n      if (this.isMaster()) {\n        version = Buffer.from(\"0488ADE4\", \"hex\");\n        depth = 0;\n        index = 0;\n      } else {\n        depth = this.getOrigin().getComponents().length || this.getOrigin().getDepth();\n        const paths = this.getOrigin().getComponents();\n        const lastPath = paths[paths.length - 1];\n\n        if (lastPath) {\n          index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();\n          parentFingerprint = this.getParentFingerprint();\n        }\n\n        if (this.isPrivateKey()) {\n          version = Buffer.from('0488ADE4', 'hex');\n        } else {\n          version = Buffer.from('0488B21E', 'hex');\n        }\n      }\n\n      const depthBuffer = Buffer.alloc(1);\n      depthBuffer.writeUInt8(depth, 0);\n      const indexBuffer = Buffer.alloc(4);\n      indexBuffer.writeUInt32BE(index, 0);\n      const chainCode = this.getChainCode();\n      const key = this.getKey();\n      return bs58check_1.encode(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));\n    };\n\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;\n    };\n\n    this.setupMasterKey = args => {\n      this.master = true;\n      this.key = args.key;\n      this.chainCode = args.chainCode;\n    };\n\n    this.setupDeriveKey = args => {\n      this.master = false;\n      this.privateKey = args.isPrivateKey;\n      this.key = args.key;\n      this.chainCode = args.chainCode;\n      this.useInfo = args.useInfo;\n      this.origin = args.origin;\n      this.children = args.children;\n      this.parentFingerprint = args.parentFingerprint;\n      this.name = args.name;\n      this.note = args.note;\n    };\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.master) {\n        map[Keys.is_master] = true;\n        map[Keys.key_data] = this.key;\n        map[Keys.chain_code] = this.chainCode;\n      } else {\n        if (this.privateKey !== undefined) {\n          map[Keys.is_private] = this.privateKey;\n        }\n\n        map[Keys.key_data] = this.key;\n\n        if (this.chainCode) {\n          map[Keys.chain_code] = this.chainCode;\n        }\n\n        if (this.useInfo) {\n          const useInfo = this.useInfo.toDataItem();\n          useInfo.setTag(this.useInfo.getRegistryType().getTag());\n          map[Keys.use_info] = useInfo;\n        }\n\n        if (this.origin) {\n          const origin = this.origin.toDataItem();\n          origin.setTag(this.origin.getRegistryType().getTag());\n          map[Keys.origin] = origin;\n        }\n\n        if (this.children) {\n          const children = this.children.toDataItem();\n          children.setTag(this.children.getRegistryType().getTag());\n          map[Keys.children] = children;\n        }\n\n        if (this.parentFingerprint) {\n          map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);\n        }\n\n        if (this.name !== undefined) {\n          map[Keys.name] = this.name;\n        }\n\n        if (this.note !== undefined) {\n          map[Keys.note] = this.note;\n        }\n      }\n\n      return new lib_1.DataItem(map);\n    };\n\n    if (args.isMaster) {\n      this.setupMasterKey(args);\n    } else {\n      this.setupDeriveKey(args);\n    }\n  }\n\n}\n\nexports.CryptoHDKey = CryptoHDKey;\n\nCryptoHDKey.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const isMaster = !!map[Keys.is_master];\n  const isPrivateKey = map[Keys.is_private];\n  const key = map[Keys.key_data];\n  const chainCode = map[Keys.chain_code];\n  const useInfo = map[Keys.use_info] ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info]) : undefined;\n  const origin = map[Keys.origin] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin]) : undefined;\n  const children = map[Keys.children] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children]) : undefined;\n  let _parentFingerprint = map[Keys.parent_fingerprint];\n  let parentFingerprint;\n\n  if (_parentFingerprint) {\n    parentFingerprint = Buffer.alloc(4);\n    parentFingerprint.writeUInt32BE(_parentFingerprint, 0);\n  }\n\n  const name = map[Keys.name];\n  const note = map[Keys.note];\n  return new CryptoHDKey({\n    isMaster,\n    isPrivateKey,\n    key,\n    chainCode,\n    useInfo,\n    origin,\n    children,\n    parentFingerprint,\n    name,\n    note\n  });\n};\n\nCryptoHDKey.fromCBOR = _cborPayload => {\n  const dataItem = lib_1.decodeToDataItem(_cborPayload);\n  return CryptoHDKey.fromDataItem(dataItem);\n};","map":{"version":3,"sources":["../src/CryptoHDKey.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoHDKey = void 0;\nconst bs58check_1 = require(\"bs58check\");\nconst CryptoCoinInfo_1 = require(\"./CryptoCoinInfo\");\nconst CryptoKeypath_1 = require(\"./CryptoKeypath\");\nconst lib_1 = require(\"./lib\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"is_master\"] = 1] = \"is_master\";\n    Keys[Keys[\"is_private\"] = 2] = \"is_private\";\n    Keys[Keys[\"key_data\"] = 3] = \"key_data\";\n    Keys[Keys[\"chain_code\"] = 4] = \"chain_code\";\n    Keys[Keys[\"use_info\"] = 5] = \"use_info\";\n    Keys[Keys[\"origin\"] = 6] = \"origin\";\n    Keys[Keys[\"children\"] = 7] = \"children\";\n    Keys[Keys[\"parent_fingerprint\"] = 8] = \"parent_fingerprint\";\n    Keys[Keys[\"name\"] = 9] = \"name\";\n    Keys[Keys[\"note\"] = 10] = \"note\";\n})(Keys || (Keys = {}));\nclass CryptoHDKey extends RegistryItem_1.RegistryItem {\n    constructor(args) {\n        super();\n        this.getKey = () => this.key;\n        this.getChainCode = () => this.chainCode;\n        this.isMaster = () => this.master;\n        this.isPrivateKey = () => !!this.privateKey;\n        this.getUseInfo = () => this.useInfo;\n        this.getOrigin = () => this.origin;\n        this.getChildren = () => this.children;\n        this.getParentFingerprint = () => this.parentFingerprint;\n        this.getName = () => this.name;\n        this.getNote = () => this.note;\n        this.getBip32Key = () => {\n            let version;\n            let depth;\n            let index;\n            let parentFingerprint = Buffer.alloc(4).fill(0);\n            if (this.isMaster()) {\n                version = Buffer.from(\"0488ADE4\", \"hex\");\n                depth = 0;\n                index = 0;\n            }\n            else {\n                depth = this.getOrigin().getComponents().length || this.getOrigin().getDepth();\n                const paths = this.getOrigin().getComponents();\n                const lastPath = paths[paths.length - 1];\n                if (lastPath) {\n                    index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();\n                    parentFingerprint = this.getParentFingerprint();\n                }\n                if (this.isPrivateKey()) {\n                    version = Buffer.from('0488ADE4', 'hex');\n                }\n                else {\n                    version = Buffer.from('0488B21E', 'hex');\n                }\n            }\n            const depthBuffer = Buffer.alloc(1);\n            depthBuffer.writeUInt8(depth, 0);\n            const indexBuffer = Buffer.alloc(4);\n            indexBuffer.writeUInt32BE(index, 0);\n            const chainCode = this.getChainCode();\n            const key = this.getKey();\n            return bs58check_1.encode(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));\n        };\n        this.getRegistryType = () => {\n            return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;\n        };\n        this.setupMasterKey = (args) => {\n            this.master = true;\n            this.key = args.key;\n            this.chainCode = args.chainCode;\n        };\n        this.setupDeriveKey = (args) => {\n            this.master = false;\n            this.privateKey = args.isPrivateKey;\n            this.key = args.key;\n            this.chainCode = args.chainCode;\n            this.useInfo = args.useInfo;\n            this.origin = args.origin;\n            this.children = args.children;\n            this.parentFingerprint = args.parentFingerprint;\n            this.name = args.name;\n            this.note = args.note;\n        };\n        this.toDataItem = () => {\n            const map = {};\n            if (this.master) {\n                map[Keys.is_master] = true;\n                map[Keys.key_data] = this.key;\n                map[Keys.chain_code] = this.chainCode;\n            }\n            else {\n                if (this.privateKey !== undefined) {\n                    map[Keys.is_private] = this.privateKey;\n                }\n                map[Keys.key_data] = this.key;\n                if (this.chainCode) {\n                    map[Keys.chain_code] = this.chainCode;\n                }\n                if (this.useInfo) {\n                    const useInfo = this.useInfo.toDataItem();\n                    useInfo.setTag(this.useInfo.getRegistryType().getTag());\n                    map[Keys.use_info] = useInfo;\n                }\n                if (this.origin) {\n                    const origin = this.origin.toDataItem();\n                    origin.setTag(this.origin.getRegistryType().getTag());\n                    map[Keys.origin] = origin;\n                }\n                if (this.children) {\n                    const children = this.children.toDataItem();\n                    children.setTag(this.children.getRegistryType().getTag());\n                    map[Keys.children] = children;\n                }\n                if (this.parentFingerprint) {\n                    map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);\n                }\n                if (this.name !== undefined) {\n                    map[Keys.name] = this.name;\n                }\n                if (this.note !== undefined) {\n                    map[Keys.note] = this.note;\n                }\n            }\n            return new lib_1.DataItem(map);\n        };\n        if (args.isMaster) {\n            this.setupMasterKey(args);\n        }\n        else {\n            this.setupDeriveKey(args);\n        }\n    }\n}\nexports.CryptoHDKey = CryptoHDKey;\nCryptoHDKey.fromDataItem = (dataItem) => {\n    const map = dataItem.getData();\n    const isMaster = !!map[Keys.is_master];\n    const isPrivateKey = map[Keys.is_private];\n    const key = map[Keys.key_data];\n    const chainCode = map[Keys.chain_code];\n    const useInfo = map[Keys.use_info]\n        ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info])\n        : undefined;\n    const origin = map[Keys.origin]\n        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin])\n        : undefined;\n    const children = map[Keys.children]\n        ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children])\n        : undefined;\n    let _parentFingerprint = map[Keys.parent_fingerprint];\n    let parentFingerprint;\n    if (_parentFingerprint) {\n        parentFingerprint = Buffer.alloc(4);\n        parentFingerprint.writeUInt32BE(_parentFingerprint, 0);\n    }\n    const name = map[Keys.name];\n    const note = map[Keys.note];\n    return new CryptoHDKey({\n        isMaster,\n        isPrivateKey,\n        key,\n        chainCode,\n        useInfo,\n        origin,\n        children,\n        parentFingerprint,\n        name,\n        note,\n    });\n};\nCryptoHDKey.fromCBOR = (_cborPayload) => {\n    const dataItem = lib_1.decodeToDataItem(_cborPayload);\n    return CryptoHDKey.fromDataItem(dataItem);\n};\n//# sourceMappingURL=CryptoHDKey.js.map"]},"metadata":{},"sourceType":"script"}