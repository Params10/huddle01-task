{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoECKey = void 0;\n\nconst lib_1 = require(\"./lib\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"curve\"] = 1] = \"curve\";\n  Keys[Keys[\"private\"] = 2] = \"private\";\n  Keys[Keys[\"data\"] = 3] = \"data\";\n})(Keys || (Keys = {}));\n\nclass CryptoECKey extends RegistryItem_1.RegistryItem {\n  constructor(args) {\n    super();\n\n    this.getCurve = () => this.curve || 0;\n\n    this.isPrivateKey = () => this.privateKey || false;\n\n    this.getData = () => this.data;\n\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;\n    };\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.curve) {\n        map[Keys.curve] = this.curve;\n      }\n\n      if (this.privateKey !== undefined) {\n        map[Keys.private] = this.privateKey;\n      }\n\n      map[Keys.data] = this.data;\n      return new lib_1.DataItem(map);\n    };\n\n    this.data = args.data;\n    this.curve = args.curve;\n    this.privateKey = args.privateKey;\n  }\n\n}\n\nexports.CryptoECKey = CryptoECKey;\n\nCryptoECKey.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const curve = map[Keys.curve];\n  const privateKey = map[Keys.private];\n  const data = map[Keys.data];\n\n  if (!data) {\n    throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);\n  }\n\n  return new CryptoECKey({\n    data,\n    curve,\n    privateKey\n  });\n};\n\nCryptoECKey.fromCBOR = _cborPayload => {\n  const dataItem = lib_1.decodeToDataItem(_cborPayload);\n  return CryptoECKey.fromDataItem(dataItem);\n};","map":{"version":3,"sources":["../src/CryptoECKey.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,KAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAK,IAAL;;AAAA,CAAA,UAAK,IAAL,EAAS;AACP,EAAA,IAAA,CAAA,IAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACD,CAJD,EAAK,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAT;;AAMA,MAAa,WAAb,SAAiC,cAAA,CAAA,YAAjC,CAA6C;AAI3C,EAAA,WAAA,CAAY,IAAZ,EAAwE;AACtE;;AAMK,SAAA,QAAA,GAAW,MAAM,KAAK,KAAL,IAAc,CAA/B;;AACA,SAAA,YAAA,GAAe,MAAM,KAAK,UAAL,IAAmB,KAAxC;;AACA,SAAA,OAAA,GAAU,MAAM,KAAK,IAArB;;AAEP,SAAA,eAAA,GAAkB,MAAK;AACrB,aAAO,cAAA,CAAA,aAAA,CAAc,YAArB;AACD,KAFD;;AAIA,SAAA,UAAA,GAAa,MAAK;AAChB,YAAM,GAAG,GAAG,EAAZ;;AACA,UAAI,KAAK,KAAT,EAAgB;AACd,QAAA,GAAG,CAAC,IAAI,CAAC,KAAN,CAAH,GAAkB,KAAK,KAAvB;AACD;;AACD,UAAI,KAAK,UAAL,KAAoB,SAAxB,EAAmC;AACjC,QAAA,GAAG,CAAC,IAAI,CAAC,OAAN,CAAH,GAAoB,KAAK,UAAzB;AACD;;AACD,MAAA,GAAG,CAAC,IAAI,CAAC,IAAN,CAAH,GAAiB,KAAK,IAAtB;AACA,aAAO,IAAI,KAAA,CAAA,QAAJ,CAAa,GAAb,CAAP;AACD,KAVD;;AAbE,SAAK,IAAL,GAAY,IAAI,CAAC,IAAjB;AACA,SAAK,KAAL,GAAa,IAAI,CAAC,KAAlB;AACA,SAAK,UAAL,GAAkB,IAAI,CAAC,UAAvB;AACD;;AAT0C;;AAA7C,OAAA,CAAA,WAAA,GAAA,WAAA;;AA+BS,WAAA,CAAA,YAAA,GAAgB,QAAD,IAAuB;AAC3C,QAAM,GAAG,GAAG,QAAQ,CAAC,OAAT,EAAZ;AACA,QAAM,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,KAAN,CAAjB;AACA,QAAM,UAAU,GAAG,GAAG,CAAC,IAAI,CAAC,OAAN,CAAtB;AACA,QAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAN,CAAhB;;AACA,MAAI,CAAC,IAAL,EAAW;AACT,UAAM,IAAI,KAAJ,CACJ,8FAA8F,QAAQ,EADlG,CAAN;AAGD;;AACD,SAAO,IAAI,WAAJ,CAAgB;AAAE,IAAA,IAAF;AAAQ,IAAA,KAAR;AAAe,IAAA;AAAf,GAAhB,CAAP;AACD,CAXM;;AAaO,WAAA,CAAA,QAAA,GAAY,YAAD,IAAyB;AAChD,QAAM,QAAQ,GAAG,KAAA,CAAA,gBAAA,CAAiB,YAAjB,CAAjB;AACA,SAAO,WAAW,CAAC,YAAZ,CAAyB,QAAzB,CAAP;AACD,CAHa","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoECKey = void 0;\nconst lib_1 = require(\"./lib\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"curve\"] = 1] = \"curve\";\n    Keys[Keys[\"private\"] = 2] = \"private\";\n    Keys[Keys[\"data\"] = 3] = \"data\";\n})(Keys || (Keys = {}));\nclass CryptoECKey extends RegistryItem_1.RegistryItem {\n    constructor(args) {\n        super();\n        this.getCurve = () => this.curve || 0;\n        this.isPrivateKey = () => this.privateKey || false;\n        this.getData = () => this.data;\n        this.getRegistryType = () => {\n            return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;\n        };\n        this.toDataItem = () => {\n            const map = {};\n            if (this.curve) {\n                map[Keys.curve] = this.curve;\n            }\n            if (this.privateKey !== undefined) {\n                map[Keys.private] = this.privateKey;\n            }\n            map[Keys.data] = this.data;\n            return new lib_1.DataItem(map);\n        };\n        this.data = args.data;\n        this.curve = args.curve;\n        this.privateKey = args.privateKey;\n    }\n}\nexports.CryptoECKey = CryptoECKey;\nCryptoECKey.fromDataItem = (dataItem) => {\n    const map = dataItem.getData();\n    const curve = map[Keys.curve];\n    const privateKey = map[Keys.private];\n    const data = map[Keys.data];\n    if (!data) {\n        throw new Error(`#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`);\n    }\n    return new CryptoECKey({ data, curve, privateKey });\n};\nCryptoECKey.fromCBOR = (_cborPayload) => {\n    const dataItem = lib_1.decodeToDataItem(_cborPayload);\n    return CryptoECKey.fromDataItem(dataItem);\n};\n//# sourceMappingURL=CryptoECKey.js.map"]},"metadata":{},"sourceType":"script"}