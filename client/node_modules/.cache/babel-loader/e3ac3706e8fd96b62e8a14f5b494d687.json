{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeUR = void 0;\n\nvar miniCbor_1 = require(\"./miniCbor\");\n\nvar bc_bech32_1 = require(\"@cvbb/bc-bech32\");\n\nvar utils_1 = require(\"./utils\");\n\nvar composeUR = function (payload, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  return \"ur:\" + type + \"/\" + payload;\n};\n\nvar composeDigest = function (payload, digest) {\n  return digest + \"/\" + payload;\n};\n\nvar composeSequencing = function (payload, index, total) {\n  return index + 1 + \"of\" + total + \"/\" + payload;\n};\n\nvar composeHeadersToFragments = function (fragments, digest, type) {\n  if (type === void 0) {\n    type = 'bytes';\n  }\n\n  if (fragments.length === 1) {\n    return [composeUR(fragments[0])];\n  } else {\n    return fragments.map(function (f, index) {\n      return utils_1.compose3(function (payload) {\n        return composeUR(payload, type);\n      }, function (payload) {\n        return composeSequencing(payload, index, fragments.length);\n      }, function (payload) {\n        return composeDigest(payload, digest);\n      })(f);\n    });\n  }\n};\n\nvar encodeUR = function (payload, fragmentCapacity) {\n  if (fragmentCapacity === void 0) {\n    fragmentCapacity = 200;\n  }\n\n  var cborPayload = miniCbor_1.encodeSimpleCBOR(payload);\n  var bc32Payload = bc_bech32_1.encodeBc32Data(cborPayload);\n  var digest = utils_1.sha256Hash(Buffer.from(cborPayload, 'hex')).toString('hex');\n  var bc32Digest = bc_bech32_1.encodeBc32Data(digest);\n  var fragments = bc32Payload.match(new RegExp('.{1,' + fragmentCapacity + '}', 'g'));\n\n  if (!fragments) {\n    throw new Error('Unexpected error when encoding');\n  }\n\n  return composeHeadersToFragments(fragments, bc32Digest, 'bytes').map(function (str) {\n    return str.toUpperCase();\n  });\n};\n\nexports.encodeUR = encodeUR;","map":{"version":3,"sources":["../src/encodeUR.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,IAAM,SAAS,GAAG,UAAC,OAAD,EAAkB,IAAlB,EAAgC;AAAd,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,OAAA;AAAc;;AAC9C,SAAO,QAAM,IAAN,GAAU,GAAV,GAAc,OAArB;AACH,CAFD;;AAIA,IAAM,aAAa,GAAG,UAAC,OAAD,EAAkB,MAAlB,EAAgC;AAClD,SAAU,MAAM,GAAA,GAAN,GAAU,OAApB;AACH,CAFD;;AAIA,IAAM,iBAAiB,GAAG,UAAC,OAAD,EAAkB,KAAlB,EAAiC,KAAjC,EAA8C;AACpE,SAAU,KAAK,GAAG,CAAR,GAAS,IAAT,GAAc,KAAd,GAAmB,GAAnB,GAAuB,OAAjC;AACH,CAFD;;AAIA,IAAM,yBAAyB,GAAG,UAAC,SAAD,EAAsB,MAAtB,EAAsC,IAAtC,EAAoD;AAAd,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,OAAA;AAAc;;AAClF,MAAI,SAAS,CAAC,MAAV,KAAqB,CAAzB,EAA4B;AACxB,WAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAD,CAAV,CAAV,CAAP;AACH,GAFD,MAEO;AACH,WAAO,SAAS,CAAC,GAAV,CAAc,UAAC,CAAD,EAAI,KAAJ,EAAS;AAC1B,aAAO,OAAA,CAAA,QAAA,CACH,UAAC,OAAD,EAAgB;AAAK,eAAA,SAAS,CAAC,OAAD,EAAT,IAAS,CAAT;AAAwB,OAD1C,EAEH,UAAC,OAAD,EAAgB;AAAK,eAAA,iBAAiB,CAAC,OAAD,EAAU,KAAV,EAAiB,SAAS,CAA3C,MAAiB,CAAjB;AAAmD,OAFrE,EAGH,UAAC,OAAD,EAAgB;AAAK,eAAA,aAAa,CAAC,OAAD,EAAb,MAAa,CAAb;AAA8B,OAHhD,EAIL,CAJK,CAAP;AAKH,KANM,CAAP;AAOH;AACJ,CAZD;;AAcO,IAAM,QAAQ,GAAG,UAAC,OAAD,EAAkB,gBAAlB,EAAwC;AAAtB,MAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,gBAAA,GAAA,GAAA;AAAsB;;AAC5D,MAAM,WAAW,GAAG,UAAA,CAAA,gBAAA,CAAiB,OAAjB,CAApB;AACA,MAAM,WAAW,GAAG,WAAA,CAAA,cAAA,CAAe,WAAf,CAApB;AACA,MAAM,MAAM,GAAG,OAAA,CAAA,UAAA,CAAW,MAAM,CAAC,IAAP,CAAY,WAAZ,EAAyB,KAAzB,CAAX,EAA4C,QAA5C,CAAqD,KAArD,CAAf;AACA,MAAM,UAAU,GAAG,WAAA,CAAA,cAAA,CAAe,MAAf,CAAnB;AACA,MAAM,SAAS,GAAG,WAAW,CAAC,KAAZ,CAAkB,IAAI,MAAJ,CAAW,SAAS,gBAAT,GAA4B,GAAvC,EAA4C,GAA5C,CAAlB,CAAlB;;AACA,MAAI,CAAC,SAAL,EAAgB;AACZ,UAAM,IAAI,KAAJ,CAAU,gCAAV,CAAN;AACH;;AACD,SAAO,yBAAyB,CAAC,SAAD,EAAY,UAAZ,EAAwB,OAAxB,CAAzB,CAA0D,GAA1D,CAA8D,UAAC,GAAD,EAAI;AAAK,WAAA,GAAG,CAAH,WAAA,EAAA;AAAiB,GAAxF,CAAP;AACH,CAVM;;AAAM,OAAA,CAAA,QAAA,GAAQ,QAAR","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeUR = void 0;\nvar miniCbor_1 = require(\"./miniCbor\");\nvar bc_bech32_1 = require(\"@cvbb/bc-bech32\");\nvar utils_1 = require(\"./utils\");\nvar composeUR = function (payload, type) {\n    if (type === void 0) { type = 'bytes'; }\n    return \"ur:\" + type + \"/\" + payload;\n};\nvar composeDigest = function (payload, digest) {\n    return digest + \"/\" + payload;\n};\nvar composeSequencing = function (payload, index, total) {\n    return index + 1 + \"of\" + total + \"/\" + payload;\n};\nvar composeHeadersToFragments = function (fragments, digest, type) {\n    if (type === void 0) { type = 'bytes'; }\n    if (fragments.length === 1) {\n        return [composeUR(fragments[0])];\n    }\n    else {\n        return fragments.map(function (f, index) {\n            return utils_1.compose3(function (payload) { return composeUR(payload, type); }, function (payload) { return composeSequencing(payload, index, fragments.length); }, function (payload) { return composeDigest(payload, digest); })(f);\n        });\n    }\n};\nvar encodeUR = function (payload, fragmentCapacity) {\n    if (fragmentCapacity === void 0) { fragmentCapacity = 200; }\n    var cborPayload = miniCbor_1.encodeSimpleCBOR(payload);\n    var bc32Payload = bc_bech32_1.encodeBc32Data(cborPayload);\n    var digest = utils_1.sha256Hash(Buffer.from(cborPayload, 'hex')).toString('hex');\n    var bc32Digest = bc_bech32_1.encodeBc32Data(digest);\n    var fragments = bc32Payload.match(new RegExp('.{1,' + fragmentCapacity + '}', 'g'));\n    if (!fragments) {\n        throw new Error('Unexpected error when encoding');\n    }\n    return composeHeadersToFragments(fragments, bc32Digest, 'bytes').map(function (str) { return str.toUpperCase(); });\n};\nexports.encodeUR = encodeUR;\n//# sourceMappingURL=encodeUR.js.map"]},"metadata":{},"sourceType":"script"}