{"ast":null,"code":"// Util for Bitcoin-specific functionality\nconst bech32 = require('bech32').bech32;\n\nconst bs58check = require('bs58check');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst constants = require('./constants');\n\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst DEFAULT_SIGHASH_BUFFER = Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01\n\nconst {\n  HARDENED_OFFSET\n} = require('./constants');\n\nconst DEFAULT_CHANGE = [44 + HARDENED_OFFSET, HARDENED_OFFSET, HARDENED_OFFSET, 1, 0];\nconst OP = {\n  ZERO: 0x00,\n  HASH160: 0xa9,\n  DUP: 0x76,\n  EQUAL: 0x87,\n  EQUALVERIFY: 0x88,\n  CHECKSIG: 0xac\n};\nconst addressVersion = {\n  'LEGACY': 0x00,\n  'SEGWIT': 0x05,\n  'TESTNET': 0x6F,\n  'SEGWIT_TESTNET': 0xC4,\n  'SEGWIT_NATIVE_V0': 0xD0,\n  'SEGWIT_NATIVE_V0_TESTNET': 0xF0\n};\nexports.addressVersion = addressVersion; // Bitcoin script types -- defined by the Lattice protocol spec\n// NOTE: Only certain script types are supported for the spender, but all are supported for recipient\n\nconst scriptTypes = {\n  P2PKH: 0x01,\n  // Supported spender type\n  P2SH: 0x02,\n  P2SH_P2WPKH: 0x03,\n  // Supported spender type\n  P2WPKH_V0: 0x04\n};\nexports.scriptTypes = scriptTypes; // We need to build two different objects here:\n// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction\n//    with the returned signatures to build and serialize the transaction before\n//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones\n//    we get from the Lattice\n// 2. The serialized Lattice request, which includes data (outlined in the specification)\n//    that is needed to sign all of the inputs and build a change output. \n// @inputs (contained in `data`)\n// `prevOuts`: an array of objects with the following properties:\n//           a. txHash\n//           b. value\n//           c. index          -- the index of the output in the transaction\n//           d. signerPath -- the path of the address in our wallet that is signing this input\n// `recipient`: Receiving address, which must be converted to a pubkeyhash\n// `value`:     Number of satoshis to send the recipient\n// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)\n//              already based on the number of inputs plus two outputs\n// `version`:   Transaction version of the inputs. All inputs must be of the same version! \n// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb\n\nexports.buildBitcoinTxRequest = function (data) {\n  try {\n    const {\n      prevOuts,\n      recipient,\n      value,\n      changePath = DEFAULT_CHANGE,\n      fee,\n      isSegwit = null,\n      changeVersion = 'SEGWIT',\n      spenderScriptType = null\n    } = data;\n    if (changePath.length !== 5) throw new Error('Please provide a full change path.'); // Serialize the request\n\n    const payload = Buffer.alloc(59 + 69 * prevOuts.length);\n    let off = 0; // Change version byte (a.k.a. address format byte)\n\n    if (addressVersion[changeVersion] === undefined) throw new Error('Invalid change version specified.');\n    payload.writeUInt8(addressVersion[changeVersion]);\n    off++; // Build the change data\n\n    payload.writeUInt32LE(changePath.length, off);\n    off += 4;\n\n    for (let i = 0; i < changePath.length; i++) {\n      payload.writeUInt32LE(changePath[i], off);\n      off += 4;\n    } // Fee is a param\n\n\n    payload.writeUInt32LE(fee, off);\n    off += 4;\n    const dec = decodeAddress(recipient); // Parameterize the recipient output\n\n    payload.writeUInt8(dec.versionByte, off);\n    off++;\n    dec.pkh.copy(payload, off);\n    off += dec.pkh.length;\n    writeUInt64LE(value, payload, off);\n    off += 8; // Build the inputs from the previous outputs\n\n    payload.writeUInt8(prevOuts.length, off);\n    off++;\n    let inputSum = 0;\n    let spenderScriptTypeToUse;\n\n    if (spenderScriptType !== null && scriptTypes[spenderScriptType]) {\n      // For newer versions we use the input scriptType\n      spenderScriptTypeToUse = scriptTypes[spenderScriptType];\n    } else if (isSegwit !== null) {\n      // For legacy callers we use the boolean `isSegwit` to denote if we are spending\n      // *wrapped* segwit inputs\n      spenderScriptTypeToUse = isSegwit === true ? scriptTypes.P2SH_P2WPKH : scriptTypes.P2PKH;\n    } else {\n      throw new Error('Unsupported spender script type or none provided.');\n    }\n\n    prevOuts.forEach(input => {\n      if (!input.signerPath || input.signerPath.length !== 5) {\n        throw new Error('Full recipient path not specified ');\n      }\n\n      payload.writeUInt32LE(input.signerPath.length, off);\n      off += 4;\n\n      for (let i = 0; i < input.signerPath.length; i++) {\n        payload.writeUInt32LE(input.signerPath[i], off);\n        off += 4;\n      }\n\n      payload.writeUInt32LE(input.index, off);\n      off += 4;\n      writeUInt64LE(input.value, payload, off);\n      off += 8;\n      inputSum += input.value;\n      payload.writeUInt8(spenderScriptTypeToUse, off);\n      off++;\n      if (!Buffer.isBuffer(input.txHash)) input.txHash = Buffer.from(input.txHash, 'hex');\n      input.txHash.copy(payload, off);\n      off += input.txHash.length;\n    }); // Send them back!\n\n    return {\n      payload,\n      spenderScriptType: spenderScriptTypeToUse,\n      schema: constants.signingSchema.BTC_TRANSFER,\n      origData: data,\n      // We will need the original data for serializing the tx\n      changeData: {\n        // This data helps fill in the change output\n        changeVersion,\n        value: inputSum - (value + fee)\n      }\n    };\n  } catch (err) {\n    return {\n      err\n    };\n  }\n}; // Serialize a transaction consisting of inputs, outputs, and some\n// metadata\n// -- inputs  = { hash, index, sig, pubkey }\n// -- outputs = { value, recipient }  // expects an address string for `recipient`\n// -- isSegwitSpend = true if the inputs are being spent using segwit\n//                    (NOTE: either ALL are being spent, or none are)\n// -- network = Name of network, used to determine transaction version\n// -- lockTime = Will probably always be 0\n\n\nexports.serializeTx = function (data) {\n  const {\n    inputs,\n    outputs,\n    spenderScriptType,\n    lockTime = 0,\n    crypto\n  } = data;\n  let payload = Buffer.alloc(4);\n  let off = 0; // Always use version 2\n\n  const version = 2;\n  payload.writeUInt32LE(version, off);\n  off += 4;\n\n  if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {\n    payload = concat(payload, Buffer.from('00', 'hex')); // marker = 0x00\n\n    payload = concat(payload, Buffer.from('01', 'hex')); // flag = 0x01\n  } // Serialize signed inputs\n\n\n  const numInputs = getVarInt(inputs.length);\n  payload = concat(payload, numInputs);\n  off += numInputs.length;\n  inputs.forEach(input => {\n    payload = concat(payload, input.hash.reverse());\n    off += input.hash.length;\n    const index = getU32LE(input.index);\n    payload = concat(payload, index);\n    off += index.length;\n\n    if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {\n      // Build a vector (varSlice of varSlice) containing the redeemScript\n      const redeemScript = buildRedeemScript(input.pubkey, crypto);\n      const redeemScriptLen = getVarInt(redeemScript.length);\n      const slice = Buffer.concat([redeemScriptLen, redeemScript]);\n      const sliceLen = getVarInt(slice.length);\n      payload = concat(payload, sliceLen);\n      off += sliceLen.length;\n      payload = concat(payload, slice);\n      off += slice.length;\n    } else {\n      // Build the signature + pubkey script to spend this input\n      const slice = buildSig(input.sig, input.pubkey);\n      payload = concat(payload, slice);\n      off += slice.length;\n    } // Use the default sequence for all transactions\n\n\n    const sequence = getU32LE(DEFAULT_SEQUENCE);\n    payload = concat(payload, sequence);\n    off += sequence.length;\n  }); // Serialize outputs\n\n  const numOutputs = getVarInt(outputs.length);\n  payload = concat(payload, numOutputs);\n  off += numOutputs.length;\n  outputs.forEach(output => {\n    const value = getU64LE(output.value);\n    payload = concat(payload, value);\n    off += value.length; // Build the output locking script and write it as a var slice\n\n    const script = buildLockingScript(output.recipient);\n    const scriptLen = getVarInt(script.length);\n    payload = concat(payload, scriptLen);\n    off += scriptLen.length;\n    payload = concat(payload, script);\n    off += script.length;\n  }); // Add witness data if needed\n\n  if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {\n    const sigs = [];\n    const pubkeys = [];\n\n    for (let i = 0; i < inputs.length; i++) {\n      sigs.push(inputs[i].sig);\n      pubkeys.push(inputs[i].pubkey);\n    }\n\n    const witnessSlice = buildWitness(sigs, pubkeys);\n    payload = concat(payload, witnessSlice);\n    off += witnessSlice.length;\n  } // Finish with locktime\n\n\n  return Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');\n}; // Convert a pubkeyhash to a bitcoin base58check address with a version byte\n\n\nexports.getBitcoinAddress = function (pubkeyhash, version) {\n  return bs58check.encode(Buffer.concat([Buffer.from([version]), pubkeyhash]));\n}; // Builder utils\n//-----------------------\n\n\nfunction buildRedeemScript(pubkey, crypto) {\n  const redeemScript = Buffer.alloc(22);\n  const shaHash = crypto.createHash('sha256').update(pubkey).digest();\n  const pubkeyhash = crypto.createHash('rmd160').update(shaHash).digest();\n  redeemScript.writeUInt8(OP.ZERO);\n  redeemScript.writeUInt8(pubkeyhash.length, 1);\n  pubkeyhash.copy(redeemScript, 2);\n  return redeemScript;\n} // Var slice of signature + var slice of pubkey\n\n\nfunction buildSig(sig, pubkey) {\n  sig = Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER]);\n  const sigLen = getVarInt(sig.length);\n  const pubkeyLen = getVarInt(pubkey.length);\n  const slice = Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);\n  const len = getVarInt(slice.length);\n  return Buffer.concat([len, slice]);\n} // Witness is written as a \"vector\", which is a list of varSlices\n// prefixed by the number of items\n\n\nfunction buildWitness(sigs, pubkeys) {\n  let witness = Buffer.alloc(0); // Two items in each vector (sig, pubkey)\n\n  const len = Buffer.alloc(1);\n  len.writeUInt8(2);\n\n  for (let i = 0; i < sigs.length; i++) {\n    const sig = Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);\n    const sigLen = getVarInt(sig.length);\n    const pubkey = pubkeys[i];\n    const pubkeyLen = getVarInt(pubkey.length);\n    witness = Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);\n  }\n\n  return witness;\n} // Locking script buiders\n//-----------------------\n\n\nfunction buildLockingScript(address) {\n  const dec = decodeAddress(address);\n\n  switch (dec.versionByte) {\n    case addressVersion.SEGWIT_NATIVE_V0:\n    case addressVersion.SEGWIT_NATIVE_V0_TESTNET:\n      return buildP2wpkhLockingScript(dec.pkh);\n\n    case addressVersion.SEGWIT:\n    case addressVersion.SEGWIT_TESTNET:\n      return buildP2shLockingScript(dec.pkh);\n\n    case addressVersion.LEGACY:\n    case addressVersion.TESTNET:\n      return buildP2pkhLockingScript(dec.pkh);\n\n    default:\n      throw new Error(`Unknown version byte: ${dec.versionByte}. Cannot build BTC transaction.`);\n  }\n}\n\nfunction buildP2pkhLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(5 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.DUP, off);\n  off++;\n  out.writeUInt8(OP.HASH160, off);\n  off++;\n  out.writeUInt8(pubkeyhash.length, off);\n  off++;\n  pubkeyhash.copy(out, off);\n  off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUALVERIFY, off);\n  off++;\n  out.writeUInt8(OP.CHECKSIG, off);\n  off++;\n  return out;\n}\n\nfunction buildP2shLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(3 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.HASH160, off);\n  off++;\n  out.writeUInt8(pubkeyhash.length, off);\n  off++;\n  pubkeyhash.copy(out, off);\n  off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUAL, off);\n  off++;\n  return out;\n}\n\nfunction buildP2wpkhLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(2 + pubkeyhash.length);\n  out.writeUInt8(OP.ZERO, 0);\n  out.writeUInt8(pubkeyhash.length, 1);\n  pubkeyhash.copy(out, 2);\n  return out;\n} // Static Utils\n//----------------------\n\n\nfunction concat(base, addition) {\n  return Buffer.concat([base, addition]);\n}\n\nfunction getU64LE(x) {\n  const buffer = Buffer.alloc(8);\n  writeUInt64LE(x, buffer, 0);\n  return buffer;\n}\n\nfunction getU32LE(x) {\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32LE(x);\n  return buffer;\n}\n\nfunction getVarInt(x) {\n  let buffer;\n\n  if (x < 0xfd) {\n    buffer = Buffer.alloc(1);\n    buffer.writeUInt8(x);\n  } else if (x <= 0xffff) {\n    buffer = Buffer.alloc(3);\n    buffer.writeUInt8(0xfd, 0);\n    buffer.writeUInt16LE(x, 1);\n  } else if (x < 0xffffffff) {\n    buffer = Buffer.alloc(5);\n    buffer.writeUInt8(0xfe, 0);\n    buffer.writeUInt32LE(x, 1);\n  } else {\n    buffer = Buffer.alloc(9);\n    buffer.writeUInt8(0xff, 0);\n    buffer.writeUInt32LE(x >>> 0, 1);\n    buffer.writeUInt32LE(x / 0x100000000 | 0, 5);\n  }\n\n  return buffer;\n}\n\nfunction writeUInt64LE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.reverse().copy(preBuf, 0);\n  preBuf.copy(buf, off);\n  return preBuf;\n}\n\nfunction decodeAddress(address) {\n  let versionByte, pkh;\n\n  try {\n    versionByte = bs58check.decode(address)[0];\n    pkh = bs58check.decode(address).slice(1);\n  } catch (err) {\n    try {\n      const bech32Dec = bech32.decode(address);\n      if (bech32Dec.prefix === 'bc') versionByte = 0xD0;else if (bech32Dec.prefix === 'tb') versionByte = 0xF0;else throw new Error('Unsupported prefix: must be bc or tb.');\n      if (bech32Dec.words[0] !== 0) throw new Error(`Unsupported segwit version: must be 0, got ${bech32Dec.words[0]}`);\n      pkh = Buffer.from(bech32.fromWords(bech32Dec.words.slice(1)));\n    } catch (err) {\n      throw new Error(`Unable to decode address: ${address}: ${err.message}`);\n    }\n  }\n\n  return {\n    versionByte,\n    pkh\n  };\n}","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/gridplus-sdk/src/bitcoin.js"],"names":["bech32","require","bs58check","Buffer","constants","DEFAULT_SEQUENCE","DEFAULT_SIGHASH_BUFFER","from","HARDENED_OFFSET","DEFAULT_CHANGE","OP","ZERO","HASH160","DUP","EQUAL","EQUALVERIFY","CHECKSIG","addressVersion","exports","scriptTypes","P2PKH","P2SH","P2SH_P2WPKH","P2WPKH_V0","buildBitcoinTxRequest","data","prevOuts","recipient","value","changePath","fee","isSegwit","changeVersion","spenderScriptType","length","Error","payload","alloc","off","undefined","writeUInt8","writeUInt32LE","i","dec","decodeAddress","versionByte","pkh","copy","writeUInt64LE","inputSum","spenderScriptTypeToUse","forEach","input","signerPath","index","isBuffer","txHash","schema","signingSchema","BTC_TRANSFER","origData","changeData","err","serializeTx","inputs","outputs","lockTime","crypto","version","concat","numInputs","getVarInt","hash","reverse","getU32LE","redeemScript","buildRedeemScript","pubkey","redeemScriptLen","slice","sliceLen","buildSig","sig","sequence","numOutputs","output","getU64LE","script","buildLockingScript","scriptLen","sigs","pubkeys","push","witnessSlice","buildWitness","toString","getBitcoinAddress","pubkeyhash","encode","shaHash","createHash","update","digest","sigLen","pubkeyLen","len","witness","address","SEGWIT_NATIVE_V0","SEGWIT_NATIVE_V0_TESTNET","buildP2wpkhLockingScript","SEGWIT","SEGWIT_TESTNET","buildP2shLockingScript","LEGACY","TESTNET","buildP2pkhLockingScript","out","base","addition","x","buffer","writeUInt16LE","n","buf","preBuf","nStr","nBuf","decode","bech32Dec","prefix","words","fromWords","message"],"mappings":"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","sourcesContent":["// Util for Bitcoin-specific functionality\nconst bech32 = require('bech32').bech32;\nconst bs58check = require('bs58check');\nconst Buffer = require('buffer/').Buffer;\nconst constants = require('./constants')\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst DEFAULT_SIGHASH_BUFFER = Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01\nconst { HARDENED_OFFSET } = require('./constants');\nconst DEFAULT_CHANGE = [44 + HARDENED_OFFSET, HARDENED_OFFSET, HARDENED_OFFSET, 1, 0];\n\nconst OP = {\n  ZERO: 0x00,\n  HASH160: 0xa9,\n  DUP: 0x76,\n  EQUAL: 0x87,\n  EQUALVERIFY: 0x88,\n  CHECKSIG: 0xac,\n}\n\nconst addressVersion = {\n  'LEGACY': 0x00,\n  'SEGWIT': 0x05,\n  'TESTNET': 0x6F,\n  'SEGWIT_TESTNET': 0xC4,\n  'SEGWIT_NATIVE_V0': 0xD0,\n  'SEGWIT_NATIVE_V0_TESTNET': 0xF0,\n}\nexports.addressVersion = addressVersion;\n\n// Bitcoin script types -- defined by the Lattice protocol spec\n// NOTE: Only certain script types are supported for the spender, but all are supported for recipient\nconst scriptTypes = {\n  P2PKH: 0x01, // Supported spender type\n  P2SH: 0x02,\n  P2SH_P2WPKH: 0x03, // Supported spender type\n  P2WPKH_V0: 0x04,\n}\nexports.scriptTypes = scriptTypes\n\n// We need to build two different objects here:\n// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction\n//    with the returned signatures to build and serialize the transaction before\n//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones\n//    we get from the Lattice\n// 2. The serialized Lattice request, which includes data (outlined in the specification)\n//    that is needed to sign all of the inputs and build a change output. \n// @inputs (contained in `data`)\n// `prevOuts`: an array of objects with the following properties:\n//           a. txHash\n//           b. value\n//           c. index          -- the index of the output in the transaction\n//           d. signerPath -- the path of the address in our wallet that is signing this input\n// `recipient`: Receiving address, which must be converted to a pubkeyhash\n// `value`:     Number of satoshis to send the recipient\n// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)\n//              already based on the number of inputs plus two outputs\n// `version`:   Transaction version of the inputs. All inputs must be of the same version! \n// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb\nexports.buildBitcoinTxRequest = function(data) {\n  try {\n    const { \n      prevOuts, recipient, value, changePath=DEFAULT_CHANGE, \n      fee, isSegwit=null, changeVersion='SEGWIT', spenderScriptType=null \n    } = data;\n    if (changePath.length !== 5) throw new Error('Please provide a full change path.')\n    // Serialize the request\n    const payload = Buffer.alloc(59 + (69 * prevOuts.length));\n    let off = 0;\n    // Change version byte (a.k.a. address format byte)\n    if (addressVersion[changeVersion] === undefined)\n      throw new Error('Invalid change version specified.');\n    payload.writeUInt8(addressVersion[changeVersion]); off++;\n\n    // Build the change data\n    payload.writeUInt32LE(changePath.length, off); off += 4;\n    for (let i = 0; i < changePath.length; i++) {\n      payload.writeUInt32LE(changePath[i], off); off += 4;\n    }    \n\n    // Fee is a param\n    payload.writeUInt32LE(fee, off); off += 4;\n    const dec = decodeAddress(recipient);\n    // Parameterize the recipient output\n    payload.writeUInt8(dec.versionByte, off); off++;\n    dec.pkh.copy(payload, off); off += dec.pkh.length;\n    writeUInt64LE(value, payload, off); off += 8;\n\n    // Build the inputs from the previous outputs\n    payload.writeUInt8(prevOuts.length, off); off++;\n    let inputSum = 0;\n\n    let spenderScriptTypeToUse;\n    if (spenderScriptType !== null && scriptTypes[spenderScriptType]) {\n      // For newer versions we use the input scriptType\n      spenderScriptTypeToUse = scriptTypes[spenderScriptType];\n    } else if (isSegwit !== null) {\n      // For legacy callers we use the boolean `isSegwit` to denote if we are spending\n      // *wrapped* segwit inputs\n      spenderScriptTypeToUse = isSegwit === true ? scriptTypes.P2SH_P2WPKH : scriptTypes.P2PKH;\n    } else {\n      throw new Error('Unsupported spender script type or none provided.')\n    }\n    prevOuts.forEach((input) => {\n      if (!input.signerPath || input.signerPath.length !== 5) {\n        throw new Error('Full recipient path not specified ')\n      }\n      payload.writeUInt32LE(input.signerPath.length, off); off += 4;\n      for (let i = 0; i < input.signerPath.length; i++) {\n        payload.writeUInt32LE(input.signerPath[i], off); off += 4;\n      }\n      payload.writeUInt32LE(input.index, off); off += 4;\n      writeUInt64LE(input.value, payload, off); off += 8;\n      inputSum += input.value;\n      payload.writeUInt8(spenderScriptTypeToUse, off); off++;\n      if (!Buffer.isBuffer(input.txHash)) input.txHash = Buffer.from(input.txHash, 'hex');\n      input.txHash.copy(payload, off); off += input.txHash.length;\n    })\n    // Send them back!\n    return {\n      payload,\n      spenderScriptType: spenderScriptTypeToUse,\n      schema: constants.signingSchema.BTC_TRANSFER,\n      origData: data,   // We will need the original data for serializing the tx\n      changeData: {     // This data helps fill in the change output\n        changeVersion,\n        value: inputSum - (value + fee),\n      }\n    };\n  } catch (err) {\n    return { err };\n  }\n}\n\n// Serialize a transaction consisting of inputs, outputs, and some\n// metadata\n// -- inputs  = { hash, index, sig, pubkey }\n// -- outputs = { value, recipient }  // expects an address string for `recipient`\n// -- isSegwitSpend = true if the inputs are being spent using segwit\n//                    (NOTE: either ALL are being spent, or none are)\n// -- network = Name of network, used to determine transaction version\n// -- lockTime = Will probably always be 0\nexports.serializeTx = function(data) {\n  const { inputs, outputs, spenderScriptType, lockTime=0, crypto } = data;\n  let payload = Buffer.alloc(4);\n  let off = 0;\n  // Always use version 2\n  const version = 2;\n  payload.writeUInt32LE(version, off); off += 4;\n  if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {\n    payload = concat(payload, Buffer.from('00', 'hex')); // marker = 0x00\n    payload = concat(payload, Buffer.from('01', 'hex')); // flag = 0x01\n  }\n  // Serialize signed inputs\n  const numInputs = getVarInt(inputs.length);\n  payload = concat(payload, numInputs); off += numInputs.length;\n  inputs.forEach((input) => {\n    payload = concat(payload, input.hash.reverse()); off += input.hash.length;\n    const index = getU32LE(input.index);\n    payload = concat(payload, index); off += index.length;\n    if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {\n      // Build a vector (varSlice of varSlice) containing the redeemScript\n      const redeemScript = buildRedeemScript(input.pubkey, crypto);\n      const redeemScriptLen = getVarInt(redeemScript.length);\n      const slice = Buffer.concat([redeemScriptLen, redeemScript]);\n      const sliceLen = getVarInt(slice.length);\n      payload = concat(payload, sliceLen); off += sliceLen.length;\n      payload = concat(payload, slice); off += slice.length;\n    } else {\n      // Build the signature + pubkey script to spend this input\n      const slice = buildSig(input.sig, input.pubkey);\n      payload = concat(payload, slice); off += slice.length;\n    }\n    // Use the default sequence for all transactions\n    const sequence = getU32LE(DEFAULT_SEQUENCE);\n    payload = concat(payload, sequence); off += sequence.length;\n  })\n  // Serialize outputs\n  const numOutputs = getVarInt(outputs.length);\n  payload = concat(payload, numOutputs); off += numOutputs.length;\n  outputs.forEach((output) => {\n    const value = getU64LE(output.value);\n    payload = concat(payload, value); off += value.length;\n    // Build the output locking script and write it as a var slice\n    const script = buildLockingScript(output.recipient);\n    const scriptLen = getVarInt(script.length);\n    payload = concat(payload, scriptLen); off += scriptLen.length;\n    payload = concat(payload, script); off += script.length;\n  })\n  // Add witness data if needed\n  if (spenderScriptType === scriptTypes.P2SH_P2WPKH) {\n    const sigs = [];\n    const pubkeys = [];\n    for (let i = 0; i < inputs.length; i++) {\n      sigs.push(inputs[i].sig);\n      pubkeys.push(inputs[i].pubkey);\n    }\n    const witnessSlice = buildWitness(sigs, pubkeys);\n    payload = concat(payload, witnessSlice); off += witnessSlice.length;\n  }\n  // Finish with locktime\n  return Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');\n}\n\n// Convert a pubkeyhash to a bitcoin base58check address with a version byte\nexports.getBitcoinAddress = function(pubkeyhash, version) {\n  return bs58check.encode(Buffer.concat([Buffer.from([version]), pubkeyhash]));\n}\n\n\n// Builder utils\n//-----------------------\nfunction buildRedeemScript(pubkey, crypto) {\n  const redeemScript = Buffer.alloc(22);\n  const shaHash = crypto.createHash('sha256').update(pubkey).digest();\n  const pubkeyhash = crypto.createHash('rmd160').update(shaHash).digest();\n  redeemScript.writeUInt8(OP.ZERO);\n  redeemScript.writeUInt8(pubkeyhash.length, 1);\n  pubkeyhash.copy(redeemScript, 2);\n  return redeemScript;\n}\n\n// Var slice of signature + var slice of pubkey\nfunction buildSig(sig, pubkey) {\n  sig = Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER])\n  const sigLen = getVarInt(sig.length);\n  const pubkeyLen = getVarInt(pubkey.length);\n  const slice = Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);\n  const len = getVarInt(slice.length);\n  return Buffer.concat([len, slice]);\n}\n\n// Witness is written as a \"vector\", which is a list of varSlices\n// prefixed by the number of items\nfunction buildWitness(sigs, pubkeys) {\n  let witness = Buffer.alloc(0);\n  // Two items in each vector (sig, pubkey)\n  const len = Buffer.alloc(1); len.writeUInt8(2);\n  for (let i = 0; i < sigs.length; i++) {\n    const sig = Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);\n    const sigLen = getVarInt(sig.length);\n    const pubkey = pubkeys[i];\n    const pubkeyLen = getVarInt(pubkey.length);\n    witness = Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);\n  }\n  return witness;\n}\n\n// Locking script buiders\n//-----------------------\nfunction buildLockingScript(address) {\n  const dec = decodeAddress(address);\n  switch (dec.versionByte) {\n    case addressVersion.SEGWIT_NATIVE_V0:\n    case addressVersion.SEGWIT_NATIVE_V0_TESTNET:\n      return buildP2wpkhLockingScript(dec.pkh);\n    case addressVersion.SEGWIT:\n    case addressVersion.SEGWIT_TESTNET:\n      return buildP2shLockingScript(dec.pkh);\n    case addressVersion.LEGACY:\n    case addressVersion.TESTNET:\n      return buildP2pkhLockingScript(dec.pkh);\n    default:\n      throw new Error(`Unknown version byte: ${dec.versionByte}. Cannot build BTC transaction.`);\n  }\n}\n\nfunction buildP2pkhLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(5 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.DUP, off); off++;\n  out.writeUInt8(OP.HASH160, off); off++;\n  out.writeUInt8(pubkeyhash.length, off); off++;\n  pubkeyhash.copy(out, off); off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUALVERIFY, off); off++;\n  out.writeUInt8(OP.CHECKSIG, off); off++;\n  return out;\n}\n\nfunction buildP2shLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(3 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.HASH160, off); off++;\n  out.writeUInt8(pubkeyhash.length, off); off++;\n  pubkeyhash.copy(out, off); off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUAL, off); off++;\n  return out;\n}\n\nfunction buildP2wpkhLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(2 + pubkeyhash.length);\n  out.writeUInt8(OP.ZERO, 0);\n  out.writeUInt8(pubkeyhash.length, 1);\n  pubkeyhash.copy(out, 2);\n  return out;  \n}\n\n// Static Utils\n//----------------------\nfunction concat(base, addition) {\n  return Buffer.concat([base, addition]);\n}\n\nfunction getU64LE(x) {\n  const buffer = Buffer.alloc(8);\n  writeUInt64LE(x, buffer, 0);\n  return buffer;\n}\n\nfunction getU32LE(x) {\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32LE(x);\n  return buffer;\n}\n\nfunction getVarInt (x) {\n  let buffer;\n  if (x < 0xfd) {\n    buffer = Buffer.alloc(1);\n    buffer.writeUInt8(x);\n  } else if (x <= 0xffff) {\n    buffer = Buffer.alloc(3);\n    buffer.writeUInt8(0xfd, 0);\n    buffer.writeUInt16LE(x, 1);\n  } else if (x < 0xffffffff) {\n    buffer = Buffer.alloc(5);\n    buffer.writeUInt8(0xfe, 0);\n    buffer.writeUInt32LE(x, 1);\n  } else {\n    buffer = Buffer.alloc(9);\n    buffer.writeUInt8(0xff, 0);\n    buffer.writeUInt32LE(x >>> 0, 1);\n    buffer.writeUInt32LE((x / 0x100000000) | 0, 5);\n  }\n  return buffer;\n}\n\nfunction writeUInt64LE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.reverse().copy(preBuf, 0);\n  preBuf.copy(buf, off);\n  return preBuf;\n}\n\nfunction decodeAddress(address) {\nlet versionByte, pkh;\n  try {\n    versionByte = bs58check.decode(address)[0];\n    pkh = bs58check.decode(address).slice(1);\n  } catch (err) {\n    try {\n      const bech32Dec = bech32.decode(address);\n      if (bech32Dec.prefix === 'bc')\n        versionByte = 0xD0;\n      else if (bech32Dec.prefix === 'tb')\n        versionByte = 0xF0;\n      else\n        throw new Error('Unsupported prefix: must be bc or tb.');\n      if (bech32Dec.words[0] !== 0)\n        throw new Error(`Unsupported segwit version: must be 0, got ${bech32Dec.words[0]}`);\n      pkh = Buffer.from(bech32.fromWords(bech32Dec.words.slice(1)));\n    } catch (err) {\n      throw new Error(`Unable to decode address: ${address}: ${err.message}`)\n    }\n  }\n  return {versionByte, pkh};\n}"]},"metadata":{},"sourceType":"script"}