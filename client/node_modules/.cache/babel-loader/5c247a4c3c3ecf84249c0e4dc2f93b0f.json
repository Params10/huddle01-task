{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeSimpleCBOR = exports.encodeSimpleCBOR = exports.composeHeader = void 0;\n/*\n    this an simple cbor implementation which is just using\n    on BCR-05\n*/\n\nvar composeHeader = function (length) {\n  var header;\n\n  if (length > 0 && length <= 23) {\n    header = Buffer.from([0x40 + length]);\n  } else if (length >= 24 && length <= 255) {\n    var headerLength = Buffer.alloc(1);\n    headerLength.writeUInt8(length, 0);\n    header = Buffer.concat([Buffer.from([0x58]), headerLength]);\n  } else if (length >= 256 && length <= 65535) {\n    var headerLength = Buffer.alloc(2);\n    headerLength.writeUInt16BE(length, 0);\n    header = Buffer.concat([Buffer.from([0x59]), headerLength]);\n  } else if (length >= 65536 && length <= Math.pow(2, 32) - 1) {\n    var headerLength = Buffer.alloc(4);\n    headerLength.writeUInt32BE(length, 0);\n    header = Buffer.concat([Buffer.from([0x60]), headerLength]);\n  } else {\n    throw new Error('length exceeded');\n  }\n\n  return header;\n};\n\nexports.composeHeader = composeHeader;\n\nvar encodeSimpleCBOR = function (data) {\n  var bufferData = Buffer.from(data, 'hex');\n\n  if (bufferData.length <= 0 || bufferData.length >= Math.pow(2, 32)) {\n    throw new Error('data is too large');\n  }\n\n  var header = exports.composeHeader(bufferData.length);\n  var endcoded = Buffer.concat([header, bufferData]);\n  return endcoded.toString('hex');\n};\n\nexports.encodeSimpleCBOR = encodeSimpleCBOR;\n\nvar decodeSimpleCBOR = function (data) {\n  var dataBuffer = Buffer.from(data, 'hex');\n\n  if (dataBuffer.length <= 0) {\n    throw new Error('invalid input');\n  }\n\n  var header = dataBuffer[0];\n\n  if (header < 0x58) {\n    var dataLength = header - 0x40;\n    return dataBuffer.slice(1, 1 + dataLength).toString('hex');\n  } else if (header == 0x58) {\n    var dataLength = dataBuffer.slice(1, 2).readUInt8(0);\n    return dataBuffer.slice(2, 2 + dataLength).toString('hex');\n  } else if (header == 0x59) {\n    var dataLength = dataBuffer.slice(1, 3).readUInt16BE(0);\n    return dataBuffer.slice(3, 3 + dataLength).toString('hex');\n  } else if (header == 0x60) {\n    var dataLength = dataBuffer.slice(1, 5).readUInt32BE(0);\n    return dataBuffer.slice(5, 5 + dataLength).toString('hex');\n  } else {\n    throw new Error('invalid input');\n  }\n};\n\nexports.decodeSimpleCBOR = decodeSimpleCBOR;","map":{"version":3,"sources":["../src/miniCbor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeSimpleCBOR = exports.encodeSimpleCBOR = exports.composeHeader = void 0;\n/*\n    this an simple cbor implementation which is just using\n    on BCR-05\n*/\nvar composeHeader = function (length) {\n    var header;\n    if (length > 0 && length <= 23) {\n        header = Buffer.from([0x40 + length]);\n    }\n    else if (length >= 24 && length <= 255) {\n        var headerLength = Buffer.alloc(1);\n        headerLength.writeUInt8(length, 0);\n        header = Buffer.concat([Buffer.from([0x58]), headerLength]);\n    }\n    else if (length >= 256 && length <= 65535) {\n        var headerLength = Buffer.alloc(2);\n        headerLength.writeUInt16BE(length, 0);\n        header = Buffer.concat([Buffer.from([0x59]), headerLength]);\n    }\n    else if (length >= 65536 && length <= Math.pow(2, 32) - 1) {\n        var headerLength = Buffer.alloc(4);\n        headerLength.writeUInt32BE(length, 0);\n        header = Buffer.concat([Buffer.from([0x60]), headerLength]);\n    }\n    else {\n        throw new Error('length exceeded');\n    }\n    return header;\n};\nexports.composeHeader = composeHeader;\nvar encodeSimpleCBOR = function (data) {\n    var bufferData = Buffer.from(data, 'hex');\n    if (bufferData.length <= 0 || bufferData.length >= Math.pow(2, 32)) {\n        throw new Error('data is too large');\n    }\n    var header = exports.composeHeader(bufferData.length);\n    var endcoded = Buffer.concat([header, bufferData]);\n    return endcoded.toString('hex');\n};\nexports.encodeSimpleCBOR = encodeSimpleCBOR;\nvar decodeSimpleCBOR = function (data) {\n    var dataBuffer = Buffer.from(data, 'hex');\n    if (dataBuffer.length <= 0) {\n        throw new Error('invalid input');\n    }\n    var header = dataBuffer[0];\n    if (header < 0x58) {\n        var dataLength = header - 0x40;\n        return dataBuffer.slice(1, 1 + dataLength).toString('hex');\n    }\n    else if (header == 0x58) {\n        var dataLength = dataBuffer.slice(1, 2).readUInt8(0);\n        return dataBuffer.slice(2, 2 + dataLength).toString('hex');\n    }\n    else if (header == 0x59) {\n        var dataLength = dataBuffer.slice(1, 3).readUInt16BE(0);\n        return dataBuffer.slice(3, 3 + dataLength).toString('hex');\n    }\n    else if (header == 0x60) {\n        var dataLength = dataBuffer.slice(1, 5).readUInt32BE(0);\n        return dataBuffer.slice(5, 5 + dataLength).toString('hex');\n    }\n    else {\n        throw new Error('invalid input');\n    }\n};\nexports.decodeSimpleCBOR = decodeSimpleCBOR;\n//# sourceMappingURL=miniCbor.js.map"]},"metadata":{},"sourceType":"script"}