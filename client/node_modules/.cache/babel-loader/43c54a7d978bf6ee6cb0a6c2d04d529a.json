{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.btcIsSameAccount = exports.btcGetAccountPaths = exports.btcVerifyMessage = exports.btcSignMessage = exports.btcSupportsNativeShapeShift = exports.btcSupportsSecureTransfer = exports.btcSignTx = exports.btcGetAddress = exports.btcSupportsScriptType = exports.btcSupportsCoin = void 0;\n\nconst Exchange = __importStar(require(\"@keepkey/device-protocol/lib/exchange_pb\"));\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst Types = __importStar(require(\"@keepkey/device-protocol/lib/types_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst utils_1 = require(\"./utils\"); // FIXME: load this from the device's coin table, or from some static features\n// table... instead of, you know, adding another God-forsaken coin table.\n// :facepalm:\n\n\nconst supportedCoins = [\"Bitcoin\", \"Testnet\", \"BitcoinCash\", \"BitcoinGold\", \"Litecoin\", \"Dash\", \"DigiByte\", \"Dogecoin\"];\nconst segwitCoins = [\"Bitcoin\", \"Testnet\", \"BitcoinGold\", \"Litecoin\"];\n\nfunction legacyAccount(coin, slip44, accountIdx) {\n  return {\n    coin,\n    scriptType: core.BTCInputScriptType.SpendAddress,\n    addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + accountIdx]\n  };\n}\n\nfunction segwitAccount(coin, slip44, accountIdx) {\n  return {\n    coin,\n    scriptType: core.BTCInputScriptType.SpendP2SHWitness,\n    addressNList: [0x80000000 + 49, 0x80000000 + slip44, 0x80000000 + accountIdx]\n  };\n}\n\nfunction segwitNativeAccount(coin, slip44, accountIdx) {\n  return {\n    coin,\n    scriptType: core.BTCInputScriptType.SpendWitness,\n    addressNList: [0x80000000 + 84, 0x80000000 + slip44, 0x80000000 + accountIdx]\n  };\n}\n\nfunction packVarint(n) {\n  if (n < 253) return n.toString(16).padStart(2, \"0\");else if (n < 0xffff) return \"FD\" + n.toString(16).padStart(4, \"0\");else if (n < 0xffffffff) return \"FE\" + n.toString(16).padStart(8, \"0\");else return \"FF\" + n.toString(16).padStart(16, \"0\");\n}\n\nfunction prepareSignTx(coin, inputs, outputs) {\n  const unsignedTx = new Types.TransactionType();\n  unsignedTx.setInputsCnt(inputs.length);\n  unsignedTx.setOutputsCnt(outputs.length);\n  inputs.forEach((input, i) => {\n    const utxo = new Types.TxInputType();\n    utxo.setPrevHash(core.fromHexString(input.txid));\n    utxo.setPrevIndex(input.vout);\n    if (input.sequence !== undefined) utxo.setSequence(input.sequence);\n    utxo.setScriptType(utils_1.translateInputScriptType(input.scriptType));\n    utxo.setAddressNList(input.addressNList);\n    utxo.setAmount(Number(input.amount));\n    unsignedTx.addInputs(utxo, i);\n  });\n  outputs.forEach((o, k) => {\n    var _a, _b;\n\n    const output = o;\n    const newOutput = new Types.TxOutputType();\n    newOutput.setAmount(Number(output.amount));\n\n    if (output.exchangeType) {\n      // BTCSignTxOutputExchange\n      // convert the base64 encoded signedExchangeResponse message into the correct object\n      const signedHex = core.base64toHEX(output.exchangeType.signedExchangeResponse);\n      const signedExchange = Exchange.SignedExchangeResponse.deserializeBinary(core.arrayify(signedHex)); // decode the deposit amount from a little-endian Uint8Array into an unsigned uint64\n\n      let depAmt = core.mustBeDefined(signedExchange.getResponsev2()).getDepositAmount_asU8();\n      let val = 0;\n\n      for (let jj = depAmt.length - 1; jj >= 0; jj--) {\n        val += depAmt[jj] * Math.pow(2, 8 * (depAmt.length - jj - 1)); // TODO validate is uint64\n      }\n\n      const outExchangeType = new Types.ExchangeType();\n      outExchangeType.setSignedExchangeResponse(signedExchange);\n      outExchangeType.setWithdrawalCoinName(output.exchangeType.withdrawalCoinName);\n      outExchangeType.setWithdrawalAddressNList(output.exchangeType.withdrawalAddressNList);\n      outExchangeType.setWithdrawalScriptType(utils_1.translateInputScriptType(output.exchangeType.withdrawalScriptType || core.BTCInputScriptType.SpendAddress));\n      outExchangeType.setReturnAddressNList(output.exchangeType.returnAddressNList);\n      outExchangeType.setReturnScriptType(utils_1.translateInputScriptType(output.exchangeType.returnScriptType || core.BTCInputScriptType.SpendAddress));\n      newOutput.setAmount(val);\n      newOutput.setAddress(core.mustBeDefined((_b = (_a = signedExchange.toObject().responsev2) === null || _a === void 0 ? void 0 : _a.depositAddress) === null || _b === void 0 ? void 0 : _b.address));\n      newOutput.setScriptType(Types.OutputScriptType.PAYTOADDRESS);\n      newOutput.setAddressType(Types.OutputAddressType.EXCHANGE);\n      newOutput.setExchangeType(outExchangeType);\n    } else if (output.isChange || output.addressType === core.BTCOutputAddressType.Transfer) {\n      // BTCSignTxOutputTranfer ||  BTCSignTxOutputChange\n      newOutput.setScriptType(utils_1.translateOutputScriptType(output.scriptType));\n      newOutput.setAddressNList(output.addressNList);\n      newOutput.setAddressType(output.isChange ? Types.OutputAddressType.CHANGE : Types.OutputAddressType.TRANSFER);\n    } else if (output.opReturnData !== undefined && output.opReturnData !== null) {\n      // BTCSignTxOutputMemo\n      newOutput.setScriptType(Types.OutputScriptType.PAYTOOPRETURN);\n      newOutput.setAddressType(Types.OutputAddressType.SPEND);\n      newOutput.setOpReturnData(output.opReturnData);\n    } else {\n      // BTCSignTxOutputSpend\n      newOutput.setScriptType(Types.OutputScriptType.PAYTOADDRESS);\n      newOutput.setAddress(output.address);\n      newOutput.setAddressType(Types.OutputAddressType.SPEND);\n    }\n\n    unsignedTx.addOutputs(newOutput, k);\n  });\n  const txmap = {}; // Create a map of transactions by txid needed for the KeepKey signing flow.\n\n  txmap[\"unsigned\"] = unsignedTx;\n  const forceBip143Coins = [\"BitcoinGold\", \"BitcoinCash\", \"BitcoinSV\"];\n  if (forceBip143Coins.includes(coin)) return txmap;\n  inputs.forEach(inputTx => {\n    if (inputTx.txid in txmap) return;\n    if (inputTx.scriptType === core.BTCInputScriptType.SpendP2SHWitness || inputTx.scriptType === core.BTCInputScriptType.SpendWitness || inputTx.scriptType === core.BTCInputScriptType.External) return;\n    if (!inputTx.tx) throw new Error(\"non-segwit inputs must have the associated prev tx\");\n    const tx = new Types.TransactionType();\n    tx.setVersion(inputTx.tx.version);\n    tx.setLockTime(inputTx.tx.locktime);\n    tx.setInputsCnt(inputTx.tx.vin.length);\n    tx.setOutputsCnt(inputTx.tx.vout.length);\n    inputTx.tx.vin.forEach((vin, i) => {\n      const txInput = new Types.TxInputType();\n\n      if (\"coinbase\" in vin) {\n        txInput.setPrevHash(core.fromHexString(\"\\0\".repeat(64)));\n        txInput.setPrevIndex(0xffffffff);\n        txInput.setScriptSig(core.fromHexString(core.mustBeDefined(vin.coinbase)));\n        txInput.setSequence(vin.sequence);\n      } else {\n        txInput.setPrevHash(core.fromHexString(vin.txid));\n        txInput.setPrevIndex(vin.vout);\n        txInput.setScriptSig(core.fromHexString(vin.scriptSig.hex));\n        txInput.setSequence(vin.sequence);\n      }\n\n      tx.addInputs(txInput, i);\n    });\n    inputTx.tx.vout.forEach((vout, i) => {\n      const txOutput = new Types.TxOutputBinType();\n      txOutput.setAmount(core.satsFromStr(vout.value));\n      txOutput.setScriptPubkey(core.fromHexString(vout.scriptPubKey.hex));\n      tx.addBinOutputs(txOutput, i);\n    });\n\n    if (coin === \"Dash\") {\n      let dip2_type = inputTx.tx.type || 0; // DIP2 Special Tx with payload\n\n      if (inputTx.tx.version === 3 && dip2_type !== 0) {\n        if (!inputTx.tx.extraPayload) throw new Error(\"Payload missing in DIP2 transaction\");\n        tx.setExtraData(core.fromHexString(packVarint(inputTx.tx.extraPayload.length * 2) + inputTx.tx.extraPayload));\n      } // Trezor (and therefore KeepKey) firmware doesn't understand the\n      // split of version and type, so let's mimic the old serialization\n      // format\n\n\n      tx.setVersion(inputTx.tx.version | dip2_type << 16);\n    }\n\n    txmap[inputTx.txid] = tx;\n  });\n  return txmap;\n}\n\nfunction ensureCoinSupport(wallet, coin) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!supportedCoins.includes(coin)) throw new Error(`'${coin}' not yet supported in HDWalletKeepKey`);\n    if (!wallet.btcSupportsCoin(coin)) throw new Error(`'${coin} is not supported in this firmware version`);\n  });\n}\n\nfunction validateVoutOrdering(msg) {\n  // From THORChain specification:\n\n  /* ignoreTx checks if we can already ignore a tx according to preset rules\n    \n     we expect array of \"vout\" for a BTC to have this format\n     OP_RETURN is mandatory only on inbound tx\n     vout:0 is our vault\n     vout:1 is any any change back to themselves\n     vout:2 is OP_RETURN (first 80 bytes)\n     vout:3 is OP_RETURN (next 80 bytes)\n    \n     Rules to ignore a tx are:\n     - vout:0 doesn't have coins (value)\n     - vout:0 doesn't have address\n     - count vouts > 4\n     - count vouts with coins (value) > 2\n  */\n  var _a; // Check that vout:0 contains the vault address\n\n\n  if (msg.outputs[0].address != msg.vaultAddress) {\n    return false;\n  } // Check that vout:1 is change address\n\n\n  if (msg.outputs[1].addressType != core.BTCOutputAddressType.Change) {\n    return false;\n  } // Check and make sure vout:2 has OP_RETURN data\n\n\n  if (!(msg.outputs[2] && ((_a = msg.outputs[2]) === null || _a === void 0 ? void 0 : _a.opReturnData))) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction btcSupportsCoin(coin) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // FIXME: inspect the CoinTable to determine which coins are actually supported by the device.\n    return supportedCoins.includes(coin);\n  });\n}\n\nexports.btcSupportsCoin = btcSupportsCoin;\n\nfunction btcSupportsScriptType(coin, scriptType) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!supportedCoins.includes(coin)) return false;\n    if (!segwitCoins.includes(coin) && scriptType === core.BTCInputScriptType.SpendP2SHWitness) return false;\n    if (!segwitCoins.includes(coin) && scriptType === core.BTCInputScriptType.SpendWitness) return false;\n    return true;\n  });\n}\n\nexports.btcSupportsScriptType = btcSupportsScriptType;\n\nfunction btcGetAddress(wallet, transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ensureCoinSupport(wallet, msg.coin);\n    const addr = new Messages.GetAddress();\n    addr.setAddressNList(msg.addressNList);\n    addr.setCoinName(msg.coin);\n    addr.setShowDisplay(msg.showDisplay || false);\n    addr.setScriptType(utils_1.translateInputScriptType(msg.scriptType || core.BTCInputScriptType.SpendAddress));\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_GETADDRESS, addr, core.LONG_TIMEOUT);\n    if (response.message_type === core.Events.FAILURE) throw response;\n    if (response.message_type === core.Events.CANCEL) throw response;\n    const btcAddress = response.proto;\n    return core.mustBeDefined(btcAddress.getAddress());\n  });\n}\n\nexports.btcGetAddress = btcGetAddress;\n\nfunction btcSignTx(wallet, transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n      yield ensureCoinSupport(wallet, msg.coin);\n\n      if (msg.opReturnData) {\n        if (msg.opReturnData.length > 80) {\n          throw new Error(\"OP_RETURN output character count is too damn high.\");\n        }\n\n        msg.outputs.push({\n          addressType: core.BTCOutputAddressType.Spend,\n          opReturnData: Buffer.from(msg.opReturnData).toString('base64'),\n          amount: \"0\",\n          isChange: false\n        });\n      } // If this is a THORChain transaction, validate the vout ordering\n\n\n      if (msg.vaultAddress && !validateVoutOrdering(msg)) {\n        throw new Error(\"Improper vout ordering for BTC Thorchain transaction\");\n      }\n\n      const txmap = prepareSignTx(msg.coin, msg.inputs, msg.outputs); // Prepare and send initial message\n\n      const tx = new Messages.SignTx();\n      tx.setInputsCount(msg.inputs.length);\n      tx.setOutputsCount(msg.outputs.length);\n      tx.setCoinName(msg.coin);\n      if (msg.version !== undefined) tx.setVersion(msg.version);\n      tx.setLockTime(msg.locktime || 0);\n      let responseType;\n      let response;\n      const {\n        message_enum,\n        proto\n      } = yield transport.call(Messages.MessageType.MESSAGETYPE_SIGNTX, tx, core.LONG_TIMEOUT,\n      /*omitLock=*/\n      true); // 5 Minute timeout\n\n      responseType = message_enum;\n      response = proto; // Prepare structure for signatures\n\n      const signatures = new Array(msg.inputs.length).fill(null);\n      let serializedTx = \"\";\n\n      try {\n        // Begin callback loop\n        while (true) {\n          if (responseType === Messages.MessageType.MESSAGETYPE_FAILURE) {\n            const errorResponse = response;\n            throw new Error(`Signing failed: ${errorResponse.getMessage()}`);\n          }\n\n          if (responseType !== Messages.MessageType.MESSAGETYPE_TXREQUEST) {\n            throw new Error(`Unexpected message type: ${responseType}`);\n          }\n\n          let txRequest = response; // If there's some part of signed transaction, add it\n\n          if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {\n            serializedTx += core.toHexString(txRequest.getSerialized().getSerializedTx_asU8());\n          }\n\n          if (txRequest.hasSerialized() && txRequest.getSerialized().hasSignatureIndex()) {\n            const sigIdx = txRequest.getSerialized().getSignatureIndex();\n\n            if (signatures[sigIdx] !== null) {\n              throw new Error(`Signature for index ${sigIdx} already filled`);\n            }\n\n            signatures[sigIdx] = core.toHexString(txRequest.getSerialized().getSignature_asU8());\n          }\n\n          if (txRequest.getRequestType() === Types.RequestType.TXFINISHED) {\n            // Device didn't ask for more information, finish workflow\n            break;\n          }\n\n          let currentTx;\n          let msg;\n          let txAck; // Device asked for one more information, let's process it.\n\n          if (!txRequest.hasDetails()) throw new Error(\"expected details\");\n          const reqDetails = txRequest.getDetails();\n\n          if (!reqDetails.hasTxHash()) {\n            currentTx = txmap[\"unsigned\"];\n          } else {\n            currentTx = txmap[core.toHexString(reqDetails.getTxHash_asU8())];\n          }\n\n          if (txRequest.getRequestType() === Types.RequestType.TXMETA) {\n            msg = new Types.TransactionType();\n            if (currentTx.hasVersion()) msg.setVersion(currentTx.getVersion());\n            if (currentTx.hasLockTime()) msg.setLockTime(currentTx.getLockTime());\n            if (currentTx.hasInputsCnt()) msg.setInputsCnt(currentTx.getInputsCnt());\n\n            if (reqDetails.hasTxHash()) {\n              msg.setOutputsCnt(currentTx.getBinOutputsList().length);\n            } else {\n              msg.setOutputsCnt(currentTx.getOutputsList().length);\n            }\n\n            if (currentTx.hasExtraData()) {\n              msg.setExtraDataLen(currentTx.getExtraData_asU8().length);\n            } else {\n              msg.setExtraDataLen(0);\n            }\n\n            txAck = new Messages.TxAck();\n            txAck.setTx(msg);\n            let message = yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT,\n            /*omitLock=*/\n            true); // 5 Minute timeout\n\n            responseType = message.message_enum;\n            response = message.proto;\n            continue;\n          }\n\n          if (txRequest.getRequestType() === Types.RequestType.TXINPUT) {\n            if (!reqDetails.hasRequestIndex()) throw new Error(\"expected request index\");\n            const reqIndex = reqDetails.getRequestIndex();\n            msg = new Types.TransactionType();\n            msg.setInputsList([currentTx.getInputsList()[reqIndex]]);\n            txAck = new Messages.TxAck();\n            txAck.setTx(msg);\n            let message = yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT,\n            /*omitLock=*/\n            true); // 5 Minute timeout\n\n            responseType = message.message_enum;\n            response = message.proto;\n            continue;\n          }\n\n          if (txRequest.getRequestType() === Types.RequestType.TXOUTPUT) {\n            if (!reqDetails.hasRequestIndex()) throw new Error(\"expected request index\");\n            const reqIndex = reqDetails.getRequestIndex();\n            msg = new Types.TransactionType();\n\n            if (reqDetails.hasTxHash()) {\n              msg.setBinOutputsList([currentTx.getBinOutputsList()[reqIndex]]);\n            } else {\n              msg.setOutputsList([currentTx.getOutputsList()[reqIndex]]);\n              msg.setOutputsCnt(1);\n            }\n\n            txAck = new Messages.TxAck();\n            txAck.setTx(msg);\n            let message = yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT,\n            /*omitLock=*/\n            true); // 5 Minute timeout\n\n            responseType = message.message_enum;\n            response = message.proto;\n            continue;\n          }\n\n          if (txRequest.getRequestType() === Types.RequestType.TXEXTRADATA) {\n            if (!reqDetails.hasExtraDataOffset() || !reqDetails.hasExtraDataLen()) throw new Error(\"missing extra data offset and length\");\n            let offset = reqDetails.getExtraDataOffset();\n            let length = reqDetails.getExtraDataLen();\n            msg = new Types.TransactionType();\n            msg.setExtraData(currentTx.getExtraData_asU8().slice(offset, offset + length));\n            txAck = new Messages.TxAck();\n            txAck.setTx(msg);\n            let message = yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT,\n            /*omitLock=*/\n            true); // 5 Minute timeout\n\n            responseType = message.message_enum;\n            response = message.proto;\n            continue;\n          }\n        }\n      } catch (error) {\n        console.error({\n          error\n        });\n        throw new Error(\"Failed to sign BTC transaction\");\n      }\n\n      if (signatures.includes(null)) {\n        throw new Error(\"Some signatures are missing!\");\n      }\n\n      return {\n        signatures: signatures,\n        serializedTx: serializedTx\n      };\n    }));\n  });\n}\n\nexports.btcSignTx = btcSignTx;\n\nfunction btcSupportsSecureTransfer() {\n  return __awaiter(this, void 0, void 0, function* () {\n    return true;\n  });\n}\n\nexports.btcSupportsSecureTransfer = btcSupportsSecureTransfer;\n\nfunction btcSupportsNativeShapeShift() {\n  return true;\n}\n\nexports.btcSupportsNativeShapeShift = btcSupportsNativeShapeShift;\n\nfunction btcSignMessage(wallet, transport, msg) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ensureCoinSupport(wallet, msg.coin);\n    const sign = new Messages.SignMessage();\n    sign.setAddressNList(msg.addressNList);\n    sign.setMessage(utils_1.toUTF8Array(msg.message));\n    sign.setCoinName(msg.coin || \"Bitcoin\");\n    sign.setScriptType(utils_1.translateInputScriptType((_a = msg.scriptType) !== null && _a !== void 0 ? _a : core.BTCInputScriptType.SpendAddress));\n    const event = yield transport.call(Messages.MessageType.MESSAGETYPE_SIGNMESSAGE, sign, core.LONG_TIMEOUT);\n    const messageSignature = event.proto;\n    const address = messageSignature.getAddress();\n    if (!address) throw new Error(\"btcSignMessage failed\");\n    return {\n      address,\n      signature: core.toHexString(messageSignature.getSignature_asU8())\n    };\n  });\n}\n\nexports.btcSignMessage = btcSignMessage;\n\nfunction btcVerifyMessage(wallet, transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield ensureCoinSupport(wallet, msg.coin);\n    const verify = new Messages.VerifyMessage();\n    verify.setAddress(msg.address);\n    verify.setSignature(core.arrayify(\"0x\" + msg.signature));\n    verify.setMessage(utils_1.toUTF8Array(msg.message));\n    verify.setCoinName(msg.coin);\n    let event = yield transport.call(Messages.MessageType.MESSAGETYPE_VERIFYMESSAGE, verify);\n\n    if (event.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n      return false;\n    }\n\n    const success = event.proto;\n    return success.getMessage() === \"Message verified\";\n  });\n}\n\nexports.btcVerifyMessage = btcVerifyMessage;\n\nfunction btcGetAccountPaths(msg) {\n  var _a;\n\n  const slip44 = core.slip44ByCoin(msg.coin);\n  if (slip44 === undefined) return [];\n  const bip44 = legacyAccount(msg.coin, slip44, msg.accountIdx);\n  const bip49 = segwitAccount(msg.coin, slip44, msg.accountIdx);\n  const bip84 = segwitNativeAccount(msg.coin, slip44, msg.accountIdx); // For BTC Forks\n\n  const btcLegacy = legacyAccount(msg.coin, core.slip44ByCoin(\"Bitcoin\"), msg.accountIdx);\n  const btcSegwit = segwitAccount(msg.coin, core.slip44ByCoin(\"Bitcoin\"), msg.accountIdx);\n  const btcSegwitNative = segwitNativeAccount(msg.coin, core.slip44ByCoin(\"Bitcoin\"), msg.accountIdx); // For BCH Forks\n\n  const bchLegacy = legacyAccount(msg.coin, core.slip44ByCoin(\"BitcoinCash\"), msg.accountIdx);\n  let paths = (_a = {\n    Bitcoin: [bip44, bip49, bip84],\n    Litecoin: [bip44, bip49, bip84],\n    Dash: [bip44],\n    DigiByte: [bip44, bip49, bip84],\n    Dogecoin: [bip44],\n    Testnet: [bip44, bip49, bip84],\n    BitcoinCash: [bip44, btcLegacy],\n    BitcoinSV: [bip44, bchLegacy, btcLegacy],\n    BitcoinGold: [bip44, bip49, bip84, btcLegacy, btcSegwit, btcSegwitNative]\n  }[msg.coin]) !== null && _a !== void 0 ? _a : [];\n  if (msg.scriptType !== undefined) paths = paths.filter(path => {\n    return path.scriptType === msg.scriptType;\n  });\n  return paths;\n}\n\nexports.btcGetAccountPaths = btcGetAccountPaths;\n\nfunction btcIsSameAccount(msg) {\n  if (msg.length < 1) return false;\n  if (msg.length > 3) return false;\n  const account0 = msg[0];\n  if (account0.addressNList.length != 3) return false; // Make sure Purpose and ScriptType match\n\n  const purpose = account0.addressNList[0];\n  const purposeForScriptType = {\n    [core.BTCInputScriptType.SpendAddress]: 0x80000000 + 44,\n    [core.BTCInputScriptType.SpendP2SHWitness]: 0x80000000 + 49,\n    [core.BTCInputScriptType.SpendWitness]: 0x80000000 + 84\n  };\n  if (purposeForScriptType[account0.scriptType] !== purpose) return false; // Coin must be hardened\n\n  const slip44 = account0.addressNList[1];\n  if (slip44 < 0x80000000) return false; // Account Idx must be hardened\n\n  const idx = account0.addressNList[2];\n  if (idx < 0x80000000) return false; // Accounts must have the same SLIP44 and Account Idx, but may have differing\n  // purpose fields (so long as they're BIP44/BIP49/BIP84)\n\n  if (msg.find(path => {\n    if (path.addressNList.length != 3) return true;\n    if (![0x80000000 + 44, 0x80000000 + 49, 0x80000000 + 84].includes(path.addressNList[0])) return true;\n    if (purposeForScriptType[path.scriptType] !== path.addressNList[0]) return true;\n    if (path.addressNList[1] != slip44) return true;\n    if (path.addressNList[2] != idx) return true;\n  })) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.btcIsSameAccount = btcIsSameAccount;","map":{"version":3,"sources":["../src/bitcoin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.btcIsSameAccount = exports.btcGetAccountPaths = exports.btcVerifyMessage = exports.btcSignMessage = exports.btcSupportsNativeShapeShift = exports.btcSupportsSecureTransfer = exports.btcSignTx = exports.btcGetAddress = exports.btcSupportsScriptType = exports.btcSupportsCoin = void 0;\nconst Exchange = __importStar(require(\"@keepkey/device-protocol/lib/exchange_pb\"));\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\nconst Types = __importStar(require(\"@keepkey/device-protocol/lib/types_pb\"));\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst utils_1 = require(\"./utils\");\n// FIXME: load this from the device's coin table, or from some static features\n// table... instead of, you know, adding another God-forsaken coin table.\n// :facepalm:\nconst supportedCoins = [\"Bitcoin\", \"Testnet\", \"BitcoinCash\", \"BitcoinGold\", \"Litecoin\", \"Dash\", \"DigiByte\", \"Dogecoin\"];\nconst segwitCoins = [\"Bitcoin\", \"Testnet\", \"BitcoinGold\", \"Litecoin\"];\nfunction legacyAccount(coin, slip44, accountIdx) {\n    return {\n        coin,\n        scriptType: core.BTCInputScriptType.SpendAddress,\n        addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + accountIdx],\n    };\n}\nfunction segwitAccount(coin, slip44, accountIdx) {\n    return {\n        coin,\n        scriptType: core.BTCInputScriptType.SpendP2SHWitness,\n        addressNList: [0x80000000 + 49, 0x80000000 + slip44, 0x80000000 + accountIdx],\n    };\n}\nfunction segwitNativeAccount(coin, slip44, accountIdx) {\n    return {\n        coin,\n        scriptType: core.BTCInputScriptType.SpendWitness,\n        addressNList: [0x80000000 + 84, 0x80000000 + slip44, 0x80000000 + accountIdx],\n    };\n}\nfunction packVarint(n) {\n    if (n < 253)\n        return n.toString(16).padStart(2, \"0\");\n    else if (n < 0xffff)\n        return \"FD\" + n.toString(16).padStart(4, \"0\");\n    else if (n < 0xffffffff)\n        return \"FE\" + n.toString(16).padStart(8, \"0\");\n    else\n        return \"FF\" + n.toString(16).padStart(16, \"0\");\n}\nfunction prepareSignTx(coin, inputs, outputs) {\n    const unsignedTx = new Types.TransactionType();\n    unsignedTx.setInputsCnt(inputs.length);\n    unsignedTx.setOutputsCnt(outputs.length);\n    inputs.forEach((input, i) => {\n        const utxo = new Types.TxInputType();\n        utxo.setPrevHash(core.fromHexString(input.txid));\n        utxo.setPrevIndex(input.vout);\n        if (input.sequence !== undefined)\n            utxo.setSequence(input.sequence);\n        utxo.setScriptType(utils_1.translateInputScriptType(input.scriptType));\n        utxo.setAddressNList(input.addressNList);\n        utxo.setAmount(Number(input.amount));\n        unsignedTx.addInputs(utxo, i);\n    });\n    outputs.forEach((o, k) => {\n        var _a, _b;\n        const output = o;\n        const newOutput = new Types.TxOutputType();\n        newOutput.setAmount(Number(output.amount));\n        if (output.exchangeType) {\n            // BTCSignTxOutputExchange\n            // convert the base64 encoded signedExchangeResponse message into the correct object\n            const signedHex = core.base64toHEX(output.exchangeType.signedExchangeResponse);\n            const signedExchange = Exchange.SignedExchangeResponse.deserializeBinary(core.arrayify(signedHex));\n            // decode the deposit amount from a little-endian Uint8Array into an unsigned uint64\n            let depAmt = core.mustBeDefined(signedExchange.getResponsev2()).getDepositAmount_asU8();\n            let val = 0;\n            for (let jj = depAmt.length - 1; jj >= 0; jj--) {\n                val += depAmt[jj] * Math.pow(2, 8 * (depAmt.length - jj - 1));\n                // TODO validate is uint64\n            }\n            const outExchangeType = new Types.ExchangeType();\n            outExchangeType.setSignedExchangeResponse(signedExchange);\n            outExchangeType.setWithdrawalCoinName(output.exchangeType.withdrawalCoinName);\n            outExchangeType.setWithdrawalAddressNList(output.exchangeType.withdrawalAddressNList);\n            outExchangeType.setWithdrawalScriptType(utils_1.translateInputScriptType(output.exchangeType.withdrawalScriptType || core.BTCInputScriptType.SpendAddress));\n            outExchangeType.setReturnAddressNList(output.exchangeType.returnAddressNList);\n            outExchangeType.setReturnScriptType(utils_1.translateInputScriptType(output.exchangeType.returnScriptType || core.BTCInputScriptType.SpendAddress));\n            newOutput.setAmount(val);\n            newOutput.setAddress(core.mustBeDefined((_b = (_a = signedExchange.toObject().responsev2) === null || _a === void 0 ? void 0 : _a.depositAddress) === null || _b === void 0 ? void 0 : _b.address));\n            newOutput.setScriptType(Types.OutputScriptType.PAYTOADDRESS);\n            newOutput.setAddressType(Types.OutputAddressType.EXCHANGE);\n            newOutput.setExchangeType(outExchangeType);\n        }\n        else if (output.isChange || output.addressType === core.BTCOutputAddressType.Transfer) {\n            // BTCSignTxOutputTranfer ||  BTCSignTxOutputChange\n            newOutput.setScriptType(utils_1.translateOutputScriptType(output.scriptType));\n            newOutput.setAddressNList(output.addressNList);\n            newOutput.setAddressType(output.isChange ? Types.OutputAddressType.CHANGE : Types.OutputAddressType.TRANSFER);\n        }\n        else if (output.opReturnData !== undefined && output.opReturnData !== null) {\n            // BTCSignTxOutputMemo\n            newOutput.setScriptType(Types.OutputScriptType.PAYTOOPRETURN);\n            newOutput.setAddressType(Types.OutputAddressType.SPEND);\n            newOutput.setOpReturnData(output.opReturnData);\n        }\n        else {\n            // BTCSignTxOutputSpend\n            newOutput.setScriptType(Types.OutputScriptType.PAYTOADDRESS);\n            newOutput.setAddress(output.address);\n            newOutput.setAddressType(Types.OutputAddressType.SPEND);\n        }\n        unsignedTx.addOutputs(newOutput, k);\n    });\n    const txmap = {}; // Create a map of transactions by txid needed for the KeepKey signing flow.\n    txmap[\"unsigned\"] = unsignedTx;\n    const forceBip143Coins = [\"BitcoinGold\", \"BitcoinCash\", \"BitcoinSV\"];\n    if (forceBip143Coins.includes(coin))\n        return txmap;\n    inputs.forEach((inputTx) => {\n        if (inputTx.txid in txmap)\n            return;\n        if (inputTx.scriptType === core.BTCInputScriptType.SpendP2SHWitness ||\n            inputTx.scriptType === core.BTCInputScriptType.SpendWitness ||\n            inputTx.scriptType === core.BTCInputScriptType.External)\n            return;\n        if (!inputTx.tx)\n            throw new Error(\"non-segwit inputs must have the associated prev tx\");\n        const tx = new Types.TransactionType();\n        tx.setVersion(inputTx.tx.version);\n        tx.setLockTime(inputTx.tx.locktime);\n        tx.setInputsCnt(inputTx.tx.vin.length);\n        tx.setOutputsCnt(inputTx.tx.vout.length);\n        inputTx.tx.vin.forEach((vin, i) => {\n            const txInput = new Types.TxInputType();\n            if (\"coinbase\" in vin) {\n                txInput.setPrevHash(core.fromHexString(\"\\0\".repeat(64)));\n                txInput.setPrevIndex(0xffffffff);\n                txInput.setScriptSig(core.fromHexString(core.mustBeDefined(vin.coinbase)));\n                txInput.setSequence(vin.sequence);\n            }\n            else {\n                txInput.setPrevHash(core.fromHexString(vin.txid));\n                txInput.setPrevIndex(vin.vout);\n                txInput.setScriptSig(core.fromHexString(vin.scriptSig.hex));\n                txInput.setSequence(vin.sequence);\n            }\n            tx.addInputs(txInput, i);\n        });\n        inputTx.tx.vout.forEach((vout, i) => {\n            const txOutput = new Types.TxOutputBinType();\n            txOutput.setAmount(core.satsFromStr(vout.value));\n            txOutput.setScriptPubkey(core.fromHexString(vout.scriptPubKey.hex));\n            tx.addBinOutputs(txOutput, i);\n        });\n        if (coin === \"Dash\") {\n            let dip2_type = inputTx.tx.type || 0;\n            // DIP2 Special Tx with payload\n            if (inputTx.tx.version === 3 && dip2_type !== 0) {\n                if (!inputTx.tx.extraPayload)\n                    throw new Error(\"Payload missing in DIP2 transaction\");\n                tx.setExtraData(core.fromHexString(packVarint(inputTx.tx.extraPayload.length * 2) + inputTx.tx.extraPayload));\n            }\n            // Trezor (and therefore KeepKey) firmware doesn't understand the\n            // split of version and type, so let's mimic the old serialization\n            // format\n            tx.setVersion(inputTx.tx.version | (dip2_type << 16));\n        }\n        txmap[inputTx.txid] = tx;\n    });\n    return txmap;\n}\nfunction ensureCoinSupport(wallet, coin) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!supportedCoins.includes(coin))\n            throw new Error(`'${coin}' not yet supported in HDWalletKeepKey`);\n        if (!wallet.btcSupportsCoin(coin))\n            throw new Error(`'${coin} is not supported in this firmware version`);\n    });\n}\nfunction validateVoutOrdering(msg) {\n    // From THORChain specification:\n    /* ignoreTx checks if we can already ignore a tx according to preset rules\n      \n       we expect array of \"vout\" for a BTC to have this format\n       OP_RETURN is mandatory only on inbound tx\n       vout:0 is our vault\n       vout:1 is any any change back to themselves\n       vout:2 is OP_RETURN (first 80 bytes)\n       vout:3 is OP_RETURN (next 80 bytes)\n      \n       Rules to ignore a tx are:\n       - vout:0 doesn't have coins (value)\n       - vout:0 doesn't have address\n       - count vouts > 4\n       - count vouts with coins (value) > 2\n    */\n    var _a;\n    // Check that vout:0 contains the vault address\n    if (msg.outputs[0].address != msg.vaultAddress) {\n        return false;\n    }\n    // Check that vout:1 is change address\n    if (msg.outputs[1].addressType != core.BTCOutputAddressType.Change) {\n        return false;\n    }\n    // Check and make sure vout:2 has OP_RETURN data\n    if (!(msg.outputs[2] && ((_a = msg.outputs[2]) === null || _a === void 0 ? void 0 : _a.opReturnData))) {\n        return false;\n    }\n    return true;\n}\nfunction btcSupportsCoin(coin) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // FIXME: inspect the CoinTable to determine which coins are actually supported by the device.\n        return supportedCoins.includes(coin);\n    });\n}\nexports.btcSupportsCoin = btcSupportsCoin;\nfunction btcSupportsScriptType(coin, scriptType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!supportedCoins.includes(coin))\n            return false;\n        if (!segwitCoins.includes(coin) && scriptType === core.BTCInputScriptType.SpendP2SHWitness)\n            return false;\n        if (!segwitCoins.includes(coin) && scriptType === core.BTCInputScriptType.SpendWitness)\n            return false;\n        return true;\n    });\n}\nexports.btcSupportsScriptType = btcSupportsScriptType;\nfunction btcGetAddress(wallet, transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ensureCoinSupport(wallet, msg.coin);\n        const addr = new Messages.GetAddress();\n        addr.setAddressNList(msg.addressNList);\n        addr.setCoinName(msg.coin);\n        addr.setShowDisplay(msg.showDisplay || false);\n        addr.setScriptType(utils_1.translateInputScriptType(msg.scriptType || core.BTCInputScriptType.SpendAddress));\n        const response = (yield transport.call(Messages.MessageType.MESSAGETYPE_GETADDRESS, addr, core.LONG_TIMEOUT));\n        if (response.message_type === core.Events.FAILURE)\n            throw response;\n        if (response.message_type === core.Events.CANCEL)\n            throw response;\n        const btcAddress = response.proto;\n        return core.mustBeDefined(btcAddress.getAddress());\n    });\n}\nexports.btcGetAddress = btcGetAddress;\nfunction btcSignTx(wallet, transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n            yield ensureCoinSupport(wallet, msg.coin);\n            if (msg.opReturnData) {\n                if (msg.opReturnData.length > 80) {\n                    throw new Error(\"OP_RETURN output character count is too damn high.\");\n                }\n                msg.outputs.push({\n                    addressType: core.BTCOutputAddressType.Spend,\n                    opReturnData: Buffer.from(msg.opReturnData).toString('base64'),\n                    amount: \"0\",\n                    isChange: false,\n                });\n            }\n            // If this is a THORChain transaction, validate the vout ordering\n            if (msg.vaultAddress && !validateVoutOrdering(msg)) {\n                throw new Error(\"Improper vout ordering for BTC Thorchain transaction\");\n            }\n            const txmap = prepareSignTx(msg.coin, msg.inputs, msg.outputs);\n            // Prepare and send initial message\n            const tx = new Messages.SignTx();\n            tx.setInputsCount(msg.inputs.length);\n            tx.setOutputsCount(msg.outputs.length);\n            tx.setCoinName(msg.coin);\n            if (msg.version !== undefined)\n                tx.setVersion(msg.version);\n            tx.setLockTime(msg.locktime || 0);\n            let responseType;\n            let response;\n            const { message_enum, proto } = (yield transport.call(Messages.MessageType.MESSAGETYPE_SIGNTX, tx, core.LONG_TIMEOUT, \n            /*omitLock=*/ true)); // 5 Minute timeout\n            responseType = message_enum;\n            response = proto;\n            // Prepare structure for signatures\n            const signatures = new Array(msg.inputs.length).fill(null);\n            let serializedTx = \"\";\n            try {\n                // Begin callback loop\n                while (true) {\n                    if (responseType === Messages.MessageType.MESSAGETYPE_FAILURE) {\n                        const errorResponse = response;\n                        throw new Error(`Signing failed: ${errorResponse.getMessage()}`);\n                    }\n                    if (responseType !== Messages.MessageType.MESSAGETYPE_TXREQUEST) {\n                        throw new Error(`Unexpected message type: ${responseType}`);\n                    }\n                    let txRequest = response;\n                    // If there's some part of signed transaction, add it\n                    if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {\n                        serializedTx += core.toHexString(txRequest.getSerialized().getSerializedTx_asU8());\n                    }\n                    if (txRequest.hasSerialized() && txRequest.getSerialized().hasSignatureIndex()) {\n                        const sigIdx = txRequest.getSerialized().getSignatureIndex();\n                        if (signatures[sigIdx] !== null) {\n                            throw new Error(`Signature for index ${sigIdx} already filled`);\n                        }\n                        signatures[sigIdx] = core.toHexString(txRequest.getSerialized().getSignature_asU8());\n                    }\n                    if (txRequest.getRequestType() === Types.RequestType.TXFINISHED) {\n                        // Device didn't ask for more information, finish workflow\n                        break;\n                    }\n                    let currentTx;\n                    let msg;\n                    let txAck;\n                    // Device asked for one more information, let's process it.\n                    if (!txRequest.hasDetails())\n                        throw new Error(\"expected details\");\n                    const reqDetails = txRequest.getDetails();\n                    if (!reqDetails.hasTxHash()) {\n                        currentTx = txmap[\"unsigned\"];\n                    }\n                    else {\n                        currentTx = txmap[core.toHexString(reqDetails.getTxHash_asU8())];\n                    }\n                    if (txRequest.getRequestType() === Types.RequestType.TXMETA) {\n                        msg = new Types.TransactionType();\n                        if (currentTx.hasVersion())\n                            msg.setVersion(currentTx.getVersion());\n                        if (currentTx.hasLockTime())\n                            msg.setLockTime(currentTx.getLockTime());\n                        if (currentTx.hasInputsCnt())\n                            msg.setInputsCnt(currentTx.getInputsCnt());\n                        if (reqDetails.hasTxHash()) {\n                            msg.setOutputsCnt(currentTx.getBinOutputsList().length);\n                        }\n                        else {\n                            msg.setOutputsCnt(currentTx.getOutputsList().length);\n                        }\n                        if (currentTx.hasExtraData()) {\n                            msg.setExtraDataLen(currentTx.getExtraData_asU8().length);\n                        }\n                        else {\n                            msg.setExtraDataLen(0);\n                        }\n                        txAck = new Messages.TxAck();\n                        txAck.setTx(msg);\n                        let message = (yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT, \n                        /*omitLock=*/ true)); // 5 Minute timeout\n                        responseType = message.message_enum;\n                        response = message.proto;\n                        continue;\n                    }\n                    if (txRequest.getRequestType() === Types.RequestType.TXINPUT) {\n                        if (!reqDetails.hasRequestIndex())\n                            throw new Error(\"expected request index\");\n                        const reqIndex = reqDetails.getRequestIndex();\n                        msg = new Types.TransactionType();\n                        msg.setInputsList([currentTx.getInputsList()[reqIndex]]);\n                        txAck = new Messages.TxAck();\n                        txAck.setTx(msg);\n                        let message = (yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT, \n                        /*omitLock=*/ true)); // 5 Minute timeout\n                        responseType = message.message_enum;\n                        response = message.proto;\n                        continue;\n                    }\n                    if (txRequest.getRequestType() === Types.RequestType.TXOUTPUT) {\n                        if (!reqDetails.hasRequestIndex())\n                            throw new Error(\"expected request index\");\n                        const reqIndex = reqDetails.getRequestIndex();\n                        msg = new Types.TransactionType();\n                        if (reqDetails.hasTxHash()) {\n                            msg.setBinOutputsList([currentTx.getBinOutputsList()[reqIndex]]);\n                        }\n                        else {\n                            msg.setOutputsList([currentTx.getOutputsList()[reqIndex]]);\n                            msg.setOutputsCnt(1);\n                        }\n                        txAck = new Messages.TxAck();\n                        txAck.setTx(msg);\n                        let message = (yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT, \n                        /*omitLock=*/ true)); // 5 Minute timeout\n                        responseType = message.message_enum;\n                        response = message.proto;\n                        continue;\n                    }\n                    if (txRequest.getRequestType() === Types.RequestType.TXEXTRADATA) {\n                        if (!reqDetails.hasExtraDataOffset() || !reqDetails.hasExtraDataLen())\n                            throw new Error(\"missing extra data offset and length\");\n                        let offset = reqDetails.getExtraDataOffset();\n                        let length = reqDetails.getExtraDataLen();\n                        msg = new Types.TransactionType();\n                        msg.setExtraData(currentTx.getExtraData_asU8().slice(offset, offset + length));\n                        txAck = new Messages.TxAck();\n                        txAck.setTx(msg);\n                        let message = (yield transport.call(Messages.MessageType.MESSAGETYPE_TXACK, txAck, core.LONG_TIMEOUT, \n                        /*omitLock=*/ true)); // 5 Minute timeout\n                        responseType = message.message_enum;\n                        response = message.proto;\n                        continue;\n                    }\n                }\n            }\n            catch (error) {\n                console.error({ error });\n                throw new Error(\"Failed to sign BTC transaction\");\n            }\n            if (signatures.includes(null)) {\n                throw new Error(\"Some signatures are missing!\");\n            }\n            return {\n                signatures: signatures,\n                serializedTx: serializedTx,\n            };\n        }));\n    });\n}\nexports.btcSignTx = btcSignTx;\nfunction btcSupportsSecureTransfer() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return true;\n    });\n}\nexports.btcSupportsSecureTransfer = btcSupportsSecureTransfer;\nfunction btcSupportsNativeShapeShift() {\n    return true;\n}\nexports.btcSupportsNativeShapeShift = btcSupportsNativeShapeShift;\nfunction btcSignMessage(wallet, transport, msg) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ensureCoinSupport(wallet, msg.coin);\n        const sign = new Messages.SignMessage();\n        sign.setAddressNList(msg.addressNList);\n        sign.setMessage(utils_1.toUTF8Array(msg.message));\n        sign.setCoinName(msg.coin || \"Bitcoin\");\n        sign.setScriptType(utils_1.translateInputScriptType((_a = msg.scriptType) !== null && _a !== void 0 ? _a : core.BTCInputScriptType.SpendAddress));\n        const event = (yield transport.call(Messages.MessageType.MESSAGETYPE_SIGNMESSAGE, sign, core.LONG_TIMEOUT));\n        const messageSignature = event.proto;\n        const address = messageSignature.getAddress();\n        if (!address)\n            throw new Error(\"btcSignMessage failed\");\n        return {\n            address,\n            signature: core.toHexString(messageSignature.getSignature_asU8()),\n        };\n    });\n}\nexports.btcSignMessage = btcSignMessage;\nfunction btcVerifyMessage(wallet, transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield ensureCoinSupport(wallet, msg.coin);\n        const verify = new Messages.VerifyMessage();\n        verify.setAddress(msg.address);\n        verify.setSignature(core.arrayify(\"0x\" + msg.signature));\n        verify.setMessage(utils_1.toUTF8Array(msg.message));\n        verify.setCoinName(msg.coin);\n        let event = yield transport.call(Messages.MessageType.MESSAGETYPE_VERIFYMESSAGE, verify);\n        if (event.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n            return false;\n        }\n        const success = event.proto;\n        return success.getMessage() === \"Message verified\";\n    });\n}\nexports.btcVerifyMessage = btcVerifyMessage;\nfunction btcGetAccountPaths(msg) {\n    var _a;\n    const slip44 = core.slip44ByCoin(msg.coin);\n    if (slip44 === undefined)\n        return [];\n    const bip44 = legacyAccount(msg.coin, slip44, msg.accountIdx);\n    const bip49 = segwitAccount(msg.coin, slip44, msg.accountIdx);\n    const bip84 = segwitNativeAccount(msg.coin, slip44, msg.accountIdx);\n    // For BTC Forks\n    const btcLegacy = legacyAccount(msg.coin, core.slip44ByCoin(\"Bitcoin\"), msg.accountIdx);\n    const btcSegwit = segwitAccount(msg.coin, core.slip44ByCoin(\"Bitcoin\"), msg.accountIdx);\n    const btcSegwitNative = segwitNativeAccount(msg.coin, core.slip44ByCoin(\"Bitcoin\"), msg.accountIdx);\n    // For BCH Forks\n    const bchLegacy = legacyAccount(msg.coin, core.slip44ByCoin(\"BitcoinCash\"), msg.accountIdx);\n    let paths = (_a = {\n        Bitcoin: [bip44, bip49, bip84],\n        Litecoin: [bip44, bip49, bip84],\n        Dash: [bip44],\n        DigiByte: [bip44, bip49, bip84],\n        Dogecoin: [bip44],\n        Testnet: [bip44, bip49, bip84],\n        BitcoinCash: [bip44, btcLegacy],\n        BitcoinSV: [bip44, bchLegacy, btcLegacy],\n        BitcoinGold: [bip44, bip49, bip84, btcLegacy, btcSegwit, btcSegwitNative],\n    }[msg.coin]) !== null && _a !== void 0 ? _a : [];\n    if (msg.scriptType !== undefined)\n        paths = paths.filter((path) => {\n            return path.scriptType === msg.scriptType;\n        });\n    return paths;\n}\nexports.btcGetAccountPaths = btcGetAccountPaths;\nfunction btcIsSameAccount(msg) {\n    if (msg.length < 1)\n        return false;\n    if (msg.length > 3)\n        return false;\n    const account0 = msg[0];\n    if (account0.addressNList.length != 3)\n        return false;\n    // Make sure Purpose and ScriptType match\n    const purpose = account0.addressNList[0];\n    const purposeForScriptType = {\n        [core.BTCInputScriptType.SpendAddress]: 0x80000000 + 44,\n        [core.BTCInputScriptType.SpendP2SHWitness]: 0x80000000 + 49,\n        [core.BTCInputScriptType.SpendWitness]: 0x80000000 + 84,\n    };\n    if (purposeForScriptType[account0.scriptType] !== purpose)\n        return false;\n    // Coin must be hardened\n    const slip44 = account0.addressNList[1];\n    if (slip44 < 0x80000000)\n        return false;\n    // Account Idx must be hardened\n    const idx = account0.addressNList[2];\n    if (idx < 0x80000000)\n        return false;\n    // Accounts must have the same SLIP44 and Account Idx, but may have differing\n    // purpose fields (so long as they're BIP44/BIP49/BIP84)\n    if (msg.find((path) => {\n        if (path.addressNList.length != 3)\n            return true;\n        if (![0x80000000 + 44, 0x80000000 + 49, 0x80000000 + 84].includes(path.addressNList[0]))\n            return true;\n        if (purposeForScriptType[path.scriptType] !== path.addressNList[0])\n            return true;\n        if (path.addressNList[1] != slip44)\n            return true;\n        if (path.addressNList[2] != idx)\n            return true;\n    })) {\n        return false;\n    }\n    return true;\n}\nexports.btcIsSameAccount = btcIsSameAccount;\n//# sourceMappingURL=bitcoin.js.map"]},"metadata":{},"sourceType":"script"}