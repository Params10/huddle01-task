{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst errors_1 = require(\"./errors\");\n\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n\n  get indexes() {\n    return this._indexes;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n\n}\n\nexports.FountainDecoderPart = FountainDecoderPart;\n\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    } // This part should be processed\n\n\n    return true;\n  }\n\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(({\n      value: mixedPart\n    }) => this.reducePartByPart(mixedPart, part)).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex); // If we've received all the parts\n\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(({\n        value\n      }) => value).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({\n      key: indexes\n    }) => utils_1.arraysEqual(indexes, part.indexes))) {\n      return;\n    } // Reduce this part by all the others\n\n\n    let p2 = this.simpleParts.reduce((acc, {\n      value: p\n    }) => this.reducePartByPart(acc, p), part);\n    p2 = this.mixedParts.reduce((acc, {\n      value: p\n    }) => this.reducePartByPart(acc, p), p2); // If the part is now simple\n\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift();\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n\n  isFailure() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    } // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n\n\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n\n}\n\nexports.default = FountainDecoder;\n\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"sources":["../src/fountainDecoder.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAa,mBAAb,CAAgC;AAC9B,EAAA,WAAA,CACU,QADV,EAEU,SAFV,EAE2B;AADjB,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACL;;AAEM,MAAP,OAAO,GAAA;AAAK,WAAO,KAAK,QAAZ;AAAuB;;AAC3B,MAAR,QAAQ,GAAA;AAAK,WAAO,KAAK,SAAZ;AAAwB;;AAEZ,SAAf,eAAe,CAAC,WAAD,EAAiC;AAC5D,UAAM,OAAO,GAAG,eAAA,CAAA,eAAA,CAAgB,WAAW,CAAC,MAA5B,EAAoC,WAAW,CAAC,SAAhD,EAA2D,WAAW,CAAC,QAAvE,CAAhB;AACA,UAAM,QAAQ,GAAG,WAAW,CAAC,QAA7B;AAEA,WAAO,IAAI,mBAAJ,CAAwB,OAAxB,EAAiC,QAAjC,CAAP;AACD;;AAEM,EAAA,QAAQ,GAAA;AACb,WAAO,KAAK,OAAL,CAAa,MAAb,KAAwB,CAA/B;AACD;;AAlB6B;;AAAhC,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AA2BA,MAAqB,eAArB,CAAoC;AAApC,EAAA,WAAA,GAAA;AAEU,SAAA,MAAA,GAA6B,SAA7B;AACA,SAAA,qBAAA,GAAgC,CAAhC;AACA,SAAA,gBAAA,GAA2B,CAA3B;AACA,SAAA,sBAAA,GAAiC,CAAjC;AACA,SAAA,mBAAA,GAA8B,CAA9B;AACA,SAAA,mBAAA,GAAmC,EAAnC;AACA,SAAA,eAAA,GAA+B,EAA/B;AACA,SAAA,WAAA,GAAqC,EAArC;AACA,SAAA,mBAAA,GAAmC,EAAnC;AACA,SAAA,UAAA,GAAyB,EAAzB;AACA,SAAA,WAAA,GAA0B,EAA1B;AA8NT;;AA3NS,EAAA,YAAY,CAAC,IAAD,EAA0B;AAC5C;AACA,QAAI,KAAK,mBAAL,CAAyB,MAAzB,KAAoC,CAAxC,EAA2C;AACzC;AACA,OAAC,GAAG,IAAI,KAAJ,CAAU,IAAI,CAAC,SAAf,CAAJ,EACG,OADH,CACW,CAAC,CAAD,EAAI,KAAJ,KAAc,KAAK,mBAAL,CAAyB,IAAzB,CAA8B,KAA9B,CADzB;AAGA,WAAK,qBAAL,GAA6B,IAAI,CAAC,aAAlC;AACA,WAAK,gBAAL,GAAwB,IAAI,CAAC,QAA7B;AACA,WAAK,sBAAL,GAA8B,IAAI,CAAC,QAAL,CAAc,MAA5C;AACD,KARD,MASK;AACH;AACA,UAAI,KAAK,mBAAL,CAAyB,MAAzB,KAAoC,IAAI,CAAC,SAA7C,EAAwD;AACtD,eAAO,KAAP;AACD;;AACD,UAAI,KAAK,qBAAL,KAA+B,IAAI,CAAC,aAAxC,EAAuD;AACrD,eAAO,KAAP;AACD;;AACD,UAAI,KAAK,gBAAL,KAA0B,IAAI,CAAC,QAAnC,EAA6C;AAC3C,eAAO,KAAP;AACD;;AACD,UAAI,KAAK,sBAAL,KAAgC,IAAI,CAAC,QAAL,CAAc,MAAlD,EAA0D;AACxD,eAAO,KAAP;AACD;AACF,KAzB2C,CA2B5C;;;AACA,WAAO,IAAP;AACD;;AAEO,EAAA,gBAAgB,CAAC,CAAD,EAAyB,CAAzB,EAA+C;AACrE;AACA,QAAI,OAAA,CAAA,aAAA,CAAc,CAAC,CAAC,OAAhB,EAAyB,CAAC,CAAC,OAA3B,CAAJ,EAAyC;AACvC,YAAM,UAAU,GAAG,OAAA,CAAA,aAAA,CAAc,CAAC,CAAC,OAAhB,EAAyB,CAAC,CAAC,OAA3B,CAAnB;AACA,YAAM,WAAW,GAAG,OAAA,CAAA,SAAA,CAAU,CAAC,CAAC,QAAZ,EAAsB,CAAC,CAAC,QAAxB,CAApB;AAEA,aAAO,IAAI,mBAAJ,CAAwB,UAAxB,EAAoC,WAApC,CAAP;AACD,KALD,MAKO;AACL;AACA,aAAO,CAAP;AACD;AACF;;AAEO,EAAA,aAAa,CAAC,IAAD,EAA0B;AAC7C,UAAM,QAAQ,GAAe,EAA7B;AAEA,SAAK,UAAL,CACG,GADH,CACO,CAAC;AAAE,MAAA,KAAK,EAAE;AAAT,KAAD,KAA0B,KAAK,gBAAL,CAAsB,SAAtB,EAAiC,IAAjC,CADjC,EAEG,OAFH,CAEW,WAAW,IAAG;AACrB,UAAI,WAAW,CAAC,QAAZ,EAAJ,EAA4B;AAC1B,aAAK,WAAL,CAAiB,IAAjB,CAAsB,WAAtB;AACD,OAFD,MAEO;AACL,QAAA,QAAQ,CAAC,IAAT,CAAc;AAAE,UAAA,GAAG,EAAE,WAAW,CAAC,OAAnB;AAA4B,UAAA,KAAK,EAAE;AAAnC,SAAd;AACD;AACF,KARH;AAUA,SAAK,UAAL,GAAkB,QAAlB;AACD;;AAEO,EAAA,iBAAiB,CAAC,IAAD,EAA0B;AACjD;AACA,UAAM,aAAa,GAAG,IAAI,CAAC,OAAL,CAAa,CAAb,CAAtB;;AAEA,QAAI,KAAK,mBAAL,CAAyB,QAAzB,CAAkC,aAAlC,CAAJ,EAAsD;AACpD;AACD;;AAED,SAAK,WAAL,CAAiB,IAAjB,CAAsB;AAAE,MAAA,GAAG,EAAE,IAAI,CAAC,OAAZ;AAAqB,MAAA,KAAK,EAAE;AAA5B,KAAtB;AACA,SAAK,mBAAL,CAAyB,IAAzB,CAA8B,aAA9B,EATiD,CAWjD;;AACA,QAAI,OAAA,CAAA,WAAA,CAAY,KAAK,mBAAjB,EAAsC,KAAK,mBAA3C,CAAJ,EAAqE;AACnE;AACA,YAAM,WAAW,GAAG,KAAK,WAAL,CACjB,GADiB,CACb,CAAC;AAAE,QAAA;AAAF,OAAD,KAAe,KADF,EAEjB,IAFiB,CAEZ,CAAC,CAAD,EAAI,CAAJ,KAAW,CAAC,CAAC,OAAF,CAAU,CAAV,IAAe,CAAC,CAAC,OAAF,CAAU,CAAV,CAFd,CAApB;AAGA,YAAM,OAAO,GAAG,eAAe,CAAC,aAAhB,CAA8B,WAAW,CAAC,GAAZ,CAAgB,IAAI,IAAI,IAAI,CAAC,QAA7B,CAA9B,EAAsE,KAAK,qBAA3E,CAAhB;AACA,YAAM,QAAQ,GAAG,OAAA,CAAA,MAAA,CAAO,OAAP,CAAjB;;AAEA,UAAI,QAAQ,KAAK,KAAK,gBAAtB,EAAwC;AACtC,aAAK,MAAL,GAAc,OAAd;AACD,OAFD,MAEO;AACL,aAAK,KAAL,GAAa,IAAI,QAAA,CAAA,oBAAJ,EAAb;AACD;AACF,KAbD,MAcK;AACH,WAAK,aAAL,CAAmB,IAAnB;AACD;AACF;;AAEO,EAAA,gBAAgB,CAAC,IAAD,EAA0B;AAChD;AACA,QAAI,KAAK,UAAL,CAAgB,IAAhB,CAAqB,CAAC;AAAE,MAAA,GAAG,EAAE;AAAP,KAAD,KAAsB,OAAA,CAAA,WAAA,CAAY,OAAZ,EAAqB,IAAI,CAAC,OAA1B,CAA3C,CAAJ,EAAoF;AAClF;AACD,KAJ+C,CAMhD;;;AACA,QAAI,EAAE,GAAG,KAAK,WAAL,CAAiB,MAAjB,CAAwB,CAAC,GAAD,EAAM;AAAE,MAAA,KAAK,EAAE;AAAT,KAAN,KAAuB,KAAK,gBAAL,CAAsB,GAAtB,EAA2B,CAA3B,CAA/C,EAA8E,IAA9E,CAAT;AACA,IAAA,EAAE,GAAG,KAAK,UAAL,CAAgB,MAAhB,CAAuB,CAAC,GAAD,EAAM;AAAE,MAAA,KAAK,EAAE;AAAT,KAAN,KAAuB,KAAK,gBAAL,CAAsB,GAAtB,EAA2B,CAA3B,CAA9C,EAA6E,EAA7E,CAAL,CARgD,CAUhD;;AACA,QAAI,EAAE,CAAC,QAAH,EAAJ,EAAmB;AACjB;AACA,WAAK,WAAL,CAAiB,IAAjB,CAAsB,EAAtB;AACD,KAHD,MAGO;AACL,WAAK,aAAL,CAAmB,EAAnB;AAEA,WAAK,UAAL,CAAgB,IAAhB,CAAqB;AAAE,QAAA,GAAG,EAAE,EAAE,CAAC,OAAV;AAAmB,QAAA,KAAK,EAAE;AAA1B,OAArB;AACD;AACF;;AAEO,EAAA,iBAAiB,GAAA;AACvB,QAAI,KAAK,WAAL,CAAiB,MAAjB,KAA4B,CAAhC,EAAmC;AACjC;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,WAAL,CAAiB,KAAjB,EAAb;;AAEA,QAAI,IAAI,CAAC,QAAL,EAAJ,EAAqB;AACnB,WAAK,iBAAL,CAAuB,IAAvB;AACD,KAFD,MAEO;AACL,WAAK,gBAAL,CAAsB,IAAtB;AACD;AACF;;AAMM,EAAA,WAAW,CAAC,WAAD,EAAiC;AACjD,QAAI,KAAK,UAAL,EAAJ,EAAuB;AACrB,aAAO,KAAP;AACD;;AAED,QAAI,CAAC,KAAK,YAAL,CAAkB,WAAlB,CAAL,EAAqC;AACnC,aAAO,KAAP;AACD;;AAED,UAAM,WAAW,GAAG,mBAAmB,CAAC,eAApB,CAAoC,WAApC,CAApB;AAEA,SAAK,eAAL,GAAuB,WAAW,CAAC,OAAnC;AACA,SAAK,WAAL,CAAiB,IAAjB,CAAsB,WAAtB;;AAEA,WAAO,CAAC,KAAK,UAAL,EAAD,IAAsB,KAAK,WAAL,CAAiB,MAAjB,GAA0B,CAAvD,EAA0D;AACxD,WAAK,iBAAL;AACD;;AAAA;AAED,SAAK,mBAAL,IAA4B,CAA5B;AAEA,WAAO,IAAP;AACD;;AAEM,EAAA,UAAU,GAAA;AACf,WAAO,OAAO,CAAC,KAAK,MAAL,KAAgB,SAAhB,IAA6B,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAnD,CAAd;AACD;;AAEM,EAAA,SAAS,GAAA;AACd,WAAO,OAAO,CAAC,KAAK,KAAL,KAAe,SAAf,IAA4B,KAAK,UAAL,EAA7B,CAAd;AACD;;AAEM,EAAA,aAAa,GAAA;AAClB,WAAO,KAAK,SAAL,KAAmB,KAAK,MAAxB,GAAkC,MAAM,CAAC,IAAP,CAAY,EAAZ,CAAzC;AACD;;AAEM,EAAA,SAAS,GAAA;AACd,WAAO,KAAK,KAAL,KAAe,SAAtB;AACD;;AAEM,EAAA,WAAW,GAAA;AAChB,WAAO,KAAK,KAAL,GAAa,KAAK,KAAL,CAAW,OAAxB,GAAkC,EAAzC;AACD;;AAEM,EAAA,iBAAiB,GAAA;AACtB,WAAO,KAAK,mBAAL,CAAyB,MAAhC;AACD;;AAEM,EAAA,sBAAsB,GAAA;AAC3B,WAAO,CAAC,GAAG,KAAK,mBAAT,CAAP;AACD;;AAEM,EAAA,sBAAsB,GAAA;AAC3B,WAAO,CAAC,GAAG,KAAK,mBAAT,CAAP;AACD;;AAEM,EAAA,kBAAkB,GAAA;AACvB,WAAO,CAAC,GAAG,KAAK,eAAT,CAAP;AACD;;AAEM,EAAA,wBAAwB,GAAA;AAC7B,QAAI,KAAK,UAAL,EAAJ,EAAuB;AACrB,aAAO,CAAP;AACD;;AAED,UAAM,iBAAiB,GAAG,KAAK,iBAAL,EAA1B;;AAEA,QAAI,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B,aAAO,CAAP;AACD,KAT4B,CAW7B;AACA;AACA;;;AACA,WAAO,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,KAAK,mBAAL,IAA4B,iBAAiB,GAAG,IAAhD,CAAf,CAAP;AACD;;AAEM,EAAA,WAAW,GAAA;AAChB,QAAI,KAAK,UAAL,EAAJ,EAAuB;AACrB,aAAO,CAAP;AACD;;AAED,UAAM,iBAAiB,GAAG,KAAK,iBAAL,EAA1B;;AAEA,QAAI,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B,aAAO,CAAP;AACD;;AAED,WAAO,KAAK,mBAAL,CAAyB,MAAzB,GAAkC,iBAAzC;AACD;;AAzOiC;;AAApC,OAAA,CAAA,OAAA,GAAA,eAAA;;AA6IgB,eAAA,CAAA,aAAA,GAAgB,CAAC,SAAD,EAAsB,aAAtB,KAA+C;AAC3E,SAAO,MAAM,CAAC,MAAP,CAAc,SAAd,EAAyB,KAAzB,CAA+B,CAA/B,EAAkC,aAAlC,CAAP;AACD,CAFa","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FountainDecoderPart = void 0;\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst errors_1 = require(\"./errors\");\nclass FountainDecoderPart {\n    constructor(_indexes, _fragment) {\n        this._indexes = _indexes;\n        this._fragment = _fragment;\n    }\n    get indexes() { return this._indexes; }\n    get fragment() { return this._fragment; }\n    static fromEncoderPart(encoderPart) {\n        const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n        const fragment = encoderPart.fragment;\n        return new FountainDecoderPart(indexes, fragment);\n    }\n    isSimple() {\n        return this.indexes.length === 1;\n    }\n}\nexports.FountainDecoderPart = FountainDecoderPart;\nclass FountainDecoder {\n    constructor() {\n        this.result = undefined;\n        this.expectedMessageLength = 0;\n        this.expectedChecksum = 0;\n        this.expectedFragmentLength = 0;\n        this.processedPartsCount = 0;\n        this.expectedPartIndexes = [];\n        this.lastPartIndexes = [];\n        this.queuedParts = [];\n        this.receivedPartIndexes = [];\n        this.mixedParts = [];\n        this.simpleParts = [];\n    }\n    validatePart(part) {\n        // If this is the first part we've seen\n        if (this.expectedPartIndexes.length === 0) {\n            // Record the things that all the other parts we see will have to match to be valid.\n            [...new Array(part.seqLength)]\n                .forEach((_, index) => this.expectedPartIndexes.push(index));\n            this.expectedMessageLength = part.messageLength;\n            this.expectedChecksum = part.checksum;\n            this.expectedFragmentLength = part.fragment.length;\n        }\n        else {\n            // If this part's values don't match the first part's values, throw away the part\n            if (this.expectedPartIndexes.length !== part.seqLength) {\n                return false;\n            }\n            if (this.expectedMessageLength !== part.messageLength) {\n                return false;\n            }\n            if (this.expectedChecksum !== part.checksum) {\n                return false;\n            }\n            if (this.expectedFragmentLength !== part.fragment.length) {\n                return false;\n            }\n        }\n        // This part should be processed\n        return true;\n    }\n    reducePartByPart(a, b) {\n        // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n        if (utils_1.arrayContains(a.indexes, b.indexes)) {\n            const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n            const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n            return new FountainDecoderPart(newIndexes, newFragment);\n        }\n        else {\n            // `a` is not reducable by `b`, so return a\n            return a;\n        }\n    }\n    reduceMixedBy(part) {\n        const newMixed = [];\n        this.mixedParts\n            .map(({ value: mixedPart }) => this.reducePartByPart(mixedPart, part))\n            .forEach(reducedPart => {\n            if (reducedPart.isSimple()) {\n                this.queuedParts.push(reducedPart);\n            }\n            else {\n                newMixed.push({ key: reducedPart.indexes, value: reducedPart });\n            }\n        });\n        this.mixedParts = newMixed;\n    }\n    processSimplePart(part) {\n        // Don't process duplicate parts\n        const fragmentIndex = part.indexes[0];\n        if (this.receivedPartIndexes.includes(fragmentIndex)) {\n            return;\n        }\n        this.simpleParts.push({ key: part.indexes, value: part });\n        this.receivedPartIndexes.push(fragmentIndex);\n        // If we've received all the parts\n        if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n            // Reassemble the message from its fragments\n            const sortedParts = this.simpleParts\n                .map(({ value }) => value)\n                .sort((a, b) => (a.indexes[0] - b.indexes[0]));\n            const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n            const checksum = utils_1.getCRC(message);\n            if (checksum === this.expectedChecksum) {\n                this.result = message;\n            }\n            else {\n                this.error = new errors_1.InvalidChecksumError();\n            }\n        }\n        else {\n            this.reduceMixedBy(part);\n        }\n    }\n    processMixedPart(part) {\n        // Don't process duplicate parts\n        if (this.mixedParts.some(({ key: indexes }) => utils_1.arraysEqual(indexes, part.indexes))) {\n            return;\n        }\n        // Reduce this part by all the others\n        let p2 = this.simpleParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), part);\n        p2 = this.mixedParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), p2);\n        // If the part is now simple\n        if (p2.isSimple()) {\n            // Add it to the queue\n            this.queuedParts.push(p2);\n        }\n        else {\n            this.reduceMixedBy(p2);\n            this.mixedParts.push({ key: p2.indexes, value: p2 });\n        }\n    }\n    processQueuedItem() {\n        if (this.queuedParts.length === 0) {\n            return;\n        }\n        const part = this.queuedParts.shift();\n        if (part.isSimple()) {\n            this.processSimplePart(part);\n        }\n        else {\n            this.processMixedPart(part);\n        }\n    }\n    receivePart(encoderPart) {\n        if (this.isComplete()) {\n            return false;\n        }\n        if (!this.validatePart(encoderPart)) {\n            return false;\n        }\n        const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n        this.lastPartIndexes = decoderPart.indexes;\n        this.queuedParts.push(decoderPart);\n        while (!this.isComplete() && this.queuedParts.length > 0) {\n            this.processQueuedItem();\n        }\n        ;\n        this.processedPartsCount += 1;\n        return true;\n    }\n    isComplete() {\n        return Boolean(this.result !== undefined && this.result.length > 0);\n    }\n    isSuccess() {\n        return Boolean(this.error === undefined && this.isComplete());\n    }\n    resultMessage() {\n        return this.isSuccess() ? this.result : Buffer.from([]);\n    }\n    isFailure() {\n        return this.error !== undefined;\n    }\n    resultError() {\n        return this.error ? this.error.message : '';\n    }\n    expectedPartCount() {\n        return this.expectedPartIndexes.length;\n    }\n    getExpectedPartIndexes() {\n        return [...this.expectedPartIndexes];\n    }\n    getReceivedPartIndexes() {\n        return [...this.receivedPartIndexes];\n    }\n    getLastPartIndexes() {\n        return [...this.lastPartIndexes];\n    }\n    estimatedPercentComplete() {\n        if (this.isComplete()) {\n            return 1;\n        }\n        const expectedPartCount = this.expectedPartCount();\n        if (expectedPartCount === 0) {\n            return 0;\n        }\n        // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n        // that `this.processedPartsCount` also tracks the duplicate parts that have been\n        // processeed.\n        return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n    }\n    getProgress() {\n        if (this.isComplete()) {\n            return 1;\n        }\n        const expectedPartCount = this.expectedPartCount();\n        if (expectedPartCount === 0) {\n            return 0;\n        }\n        return this.receivedPartIndexes.length / expectedPartCount;\n    }\n}\nexports.default = FountainDecoder;\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n    return Buffer.concat(fragments).slice(0, messageLength);\n};\n//# sourceMappingURL=fountainDecoder.js.map"]},"metadata":{},"sourceType":"script"}