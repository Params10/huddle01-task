{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transport = void 0;\n\nconst awaitqueue_1 = require(\"awaitqueue\");\n\nconst Logger_1 = require(\"./Logger\");\n\nconst EnhancedEventEmitter_1 = require(\"./EnhancedEventEmitter\");\n\nconst errors_1 = require(\"./errors\");\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst ortc = __importStar(require(\"./ortc\"));\n\nconst Producer_1 = require(\"./Producer\");\n\nconst Consumer_1 = require(\"./Consumer\");\n\nconst DataProducer_1 = require(\"./DataProducer\");\n\nconst DataConsumer_1 = require(\"./DataConsumer\");\n\nconst logger = new Logger_1.Logger('Transport');\n\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n  /**\n   * @emits connect - (transportLocalParameters: any, callback: Function, errback: Function)\n   * @emits connectionstatechange - (connectionState: ConnectionState)\n   * @emits produce - (producerLocalParameters: any, callback: Function, errback: Function)\n   * @emits producedata - (dataProducerLocalParameters: any, callback: Function, errback: Function)\n   */\n  constructor({\n    direction,\n    id,\n    iceParameters,\n    iceCandidates,\n    dtlsParameters,\n    sctpParameters,\n    iceServers,\n    iceTransportPolicy,\n    additionalSettings,\n    proprietaryConstraints,\n    appData,\n    handlerFactory,\n    extendedRtpCapabilities,\n    canProduceByKind\n  }) {\n    super(); // Closed flag.\n\n    this._closed = false; // Transport connection state.\n\n    this._connectionState = 'new'; // Map of Producers indexed by id.\n\n    this._producers = new Map(); // Map of Consumers indexed by id.\n\n    this._consumers = new Map(); // Map of DataProducers indexed by id.\n\n    this._dataProducers = new Map(); // Map of DataConsumers indexed by id.\n\n    this._dataConsumers = new Map(); // Whether the Consumer for RTP probation has been created.\n\n    this._probatorConsumerCreated = false; // AwaitQueue instance to make async tasks happen sequentially.\n\n    this._awaitQueue = new awaitqueue_1.AwaitQueue({\n      ClosedErrorClass: errors_1.InvalidStateError\n    }); // Observer instance.\n\n    this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n    logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n    this._id = id;\n    this._direction = direction;\n    this._extendedRtpCapabilities = extendedRtpCapabilities;\n    this._canProduceByKind = canProduceByKind;\n    this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null; // Clone and sanitize additionalSettings.\n\n    additionalSettings = utils.clone(additionalSettings, {});\n    delete additionalSettings.iceServers;\n    delete additionalSettings.iceTransportPolicy;\n    delete additionalSettings.bundlePolicy;\n    delete additionalSettings.rtcpMuxPolicy;\n    delete additionalSettings.sdpSemantics;\n    this._handler = handlerFactory();\n\n    this._handler.run({\n      direction,\n      iceParameters,\n      iceCandidates,\n      dtlsParameters,\n      sctpParameters,\n      iceServers,\n      iceTransportPolicy,\n      additionalSettings,\n      proprietaryConstraints,\n      extendedRtpCapabilities\n    });\n\n    this._appData = appData;\n\n    this._handleHandler();\n  }\n  /**\n   * Transport id.\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * Whether the Transport is closed.\n   */\n\n\n  get closed() {\n    return this._closed;\n  }\n  /**\n   * Transport direction.\n   */\n\n\n  get direction() {\n    return this._direction;\n  }\n  /**\n   * RTC handler instance.\n   */\n\n\n  get handler() {\n    return this._handler;\n  }\n  /**\n   * Connection state.\n   */\n\n\n  get connectionState() {\n    return this._connectionState;\n  }\n  /**\n   * App custom data.\n   */\n\n\n  get appData() {\n    return this._appData;\n  }\n  /**\n   * Invalid setter.\n   */\n\n\n  set appData(appData) {\n    throw new Error('cannot override appData object');\n  }\n  /**\n   * Observer.\n   *\n   * @emits close\n   * @emits newproducer - (producer: Producer)\n   * @emits newconsumer - (producer: Producer)\n   * @emits newdataproducer - (dataProducer: DataProducer)\n   * @emits newdataconsumer - (dataProducer: DataProducer)\n   */\n\n\n  get observer() {\n    return this._observer;\n  }\n  /**\n   * Close the Transport.\n   */\n\n\n  close() {\n    if (this._closed) return;\n    logger.debug('close()');\n    this._closed = true; // Close the AwaitQueue.\n\n    this._awaitQueue.close(); // Close the handler.\n\n\n    this._handler.close(); // Close all Producers.\n\n\n    for (const producer of this._producers.values()) {\n      producer.transportClosed();\n    }\n\n    this._producers.clear(); // Close all Consumers.\n\n\n    for (const consumer of this._consumers.values()) {\n      consumer.transportClosed();\n    }\n\n    this._consumers.clear(); // Close all DataProducers.\n\n\n    for (const dataProducer of this._dataProducers.values()) {\n      dataProducer.transportClosed();\n    }\n\n    this._dataProducers.clear(); // Close all DataConsumers.\n\n\n    for (const dataConsumer of this._dataConsumers.values()) {\n      dataConsumer.transportClosed();\n    }\n\n    this._dataConsumers.clear(); // Emit observer event.\n\n\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Get associated Transport (RTCPeerConnection) stats.\n   *\n   * @returns {RTCStatsReport}\n   */\n\n\n  async getStats() {\n    if (this._closed) throw new errors_1.InvalidStateError('closed');\n    return this._handler.getTransportStats();\n  }\n  /**\n   * Restart ICE connection.\n   */\n\n\n  async restartIce({\n    iceParameters\n  }) {\n    logger.debug('restartIce()');\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (!iceParameters) throw new TypeError('missing iceParameters'); // Enqueue command.\n\n    return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters), 'transport.restartIce()');\n  }\n  /**\n   * Update ICE servers.\n   */\n\n\n  async updateIceServers({\n    iceServers\n  } = {}) {\n    logger.debug('updateIceServers()');\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (!Array.isArray(iceServers)) throw new TypeError('missing iceServers'); // Enqueue command.\n\n    return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n  }\n  /**\n   * Create a Producer.\n   */\n\n\n  async produce({\n    track,\n    encodings,\n    codecOptions,\n    codec,\n    stopTracks = true,\n    disableTrackOnPause = true,\n    zeroRtpOnPause = false,\n    appData = {}\n  } = {}) {\n    logger.debug('produce() [track:%o]', track);\n    if (!track) throw new TypeError('missing track');else if (this._direction !== 'send') throw new errors_1.UnsupportedError('not a sending Transport');else if (!this._canProduceByKind[track.kind]) throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);else if (track.readyState === 'ended') throw new errors_1.InvalidStateError('track ended');else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (this.listenerCount('produce') === 0) throw new TypeError('no \"produce\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object'); // Enqueue command.\n\n    return this._awaitQueue.push(async () => {\n      let normalizedEncodings;\n\n      if (encodings && !Array.isArray(encodings)) {\n        throw TypeError('encodings must be an array');\n      } else if (encodings && encodings.length === 0) {\n        normalizedEncodings = undefined;\n      } else if (encodings) {\n        normalizedEncodings = encodings.map(encoding => {\n          const normalizedEncoding = {\n            active: true\n          };\n          if (encoding.active === false) normalizedEncoding.active = false;\n          if (typeof encoding.dtx === 'boolean') normalizedEncoding.dtx = encoding.dtx;\n          if (typeof encoding.scalabilityMode === 'string') normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n          if (typeof encoding.scaleResolutionDownBy === 'number') normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n          if (typeof encoding.maxBitrate === 'number') normalizedEncoding.maxBitrate = encoding.maxBitrate;\n          if (typeof encoding.maxFramerate === 'number') normalizedEncoding.maxFramerate = encoding.maxFramerate;\n          if (typeof encoding.adaptivePtime === 'boolean') normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n          if (typeof encoding.priority === 'string') normalizedEncoding.priority = encoding.priority;\n          if (typeof encoding.networkPriority === 'string') normalizedEncoding.networkPriority = encoding.networkPriority;\n          return normalizedEncoding;\n        });\n      }\n\n      const {\n        localId,\n        rtpParameters,\n        rtpSender\n      } = await this._handler.send({\n        track,\n        encodings: normalizedEncodings,\n        codecOptions,\n        codec\n      });\n\n      try {\n        // This will fill rtpParameters's missing fields with default values.\n        ortc.validateRtpParameters(rtpParameters);\n        const {\n          id\n        } = await this.safeEmitAsPromise('produce', {\n          kind: track.kind,\n          rtpParameters,\n          appData\n        });\n        const producer = new Producer_1.Producer({\n          id,\n          localId,\n          rtpSender,\n          track,\n          rtpParameters,\n          stopTracks,\n          disableTrackOnPause,\n          zeroRtpOnPause,\n          appData\n        });\n\n        this._producers.set(producer.id, producer);\n\n        this._handleProducer(producer); // Emit observer event.\n\n\n        this._observer.safeEmit('newproducer', producer);\n\n        return producer;\n      } catch (error) {\n        this._handler.stopSending(localId).catch(() => {});\n\n        throw error;\n      }\n    }, 'transport.produce()') // This catch is needed to stop the given track if the command above\n    // failed due to closed Transport.\n    .catch(error => {\n      if (stopTracks) {\n        try {\n          track.stop();\n        } catch (error2) {}\n      }\n\n      throw error;\n    });\n  }\n  /**\n   * Create a Consumer to consume a remote Producer.\n   */\n\n\n  async consume({\n    id,\n    producerId,\n    kind,\n    rtpParameters,\n    appData = {}\n  }) {\n    logger.debug('consume()');\n    rtpParameters = utils.clone(rtpParameters, undefined);\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (this._direction !== 'recv') throw new errors_1.UnsupportedError('not a receiving Transport');else if (typeof id !== 'string') throw new TypeError('missing id');else if (typeof producerId !== 'string') throw new TypeError('missing producerId');else if (kind !== 'audio' && kind !== 'video') throw new TypeError(`invalid kind '${kind}'`);else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object'); // Enqueue command.\n\n    return this._awaitQueue.push(async () => {\n      // Ensure the device can consume it.\n      const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);\n      if (!canConsume) throw new errors_1.UnsupportedError('cannot consume this Producer');\n      const {\n        localId,\n        rtpReceiver,\n        track\n      } = await this._handler.receive({\n        trackId: id,\n        kind,\n        rtpParameters\n      });\n      const consumer = new Consumer_1.Consumer({\n        id,\n        localId,\n        producerId,\n        rtpReceiver,\n        track,\n        rtpParameters,\n        appData\n      });\n\n      this._consumers.set(consumer.id, consumer);\n\n      this._handleConsumer(consumer); // If this is the first video Consumer and the Consumer for RTP probation\n      // has not yet been created, create it now.\n\n\n      if (!this._probatorConsumerCreated && kind === 'video') {\n        try {\n          const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);\n          await this._handler.receive({\n            trackId: 'probator',\n            kind: 'video',\n            rtpParameters: probatorRtpParameters\n          });\n          logger.debug('consume() | Consumer for RTP probation created');\n          this._probatorConsumerCreated = true;\n        } catch (error) {\n          logger.error('consume() | failed to create Consumer for RTP probation:%o', error);\n        }\n      } // Emit observer event.\n\n\n      this._observer.safeEmit('newconsumer', consumer);\n\n      return consumer;\n    }, 'transport.consume()');\n  }\n  /**\n   * Create a DataProducer\n   */\n\n\n  async produceData({\n    ordered = true,\n    maxPacketLifeTime,\n    maxRetransmits,\n    label = '',\n    protocol = '',\n    appData = {}\n  } = {}) {\n    logger.debug('produceData()');\n    if (this._direction !== 'send') throw new errors_1.UnsupportedError('not a sending Transport');else if (!this._maxSctpMessageSize) throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (this.listenerCount('producedata') === 0) throw new TypeError('no \"producedata\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object');\n    if (maxPacketLifeTime || maxRetransmits) ordered = false; // Enqueue command.\n\n    return this._awaitQueue.push(async () => {\n      const {\n        dataChannel,\n        sctpStreamParameters\n      } = await this._handler.sendDataChannel({\n        ordered,\n        maxPacketLifeTime,\n        maxRetransmits,\n        label,\n        protocol\n      }); // This will fill sctpStreamParameters's missing fields with default values.\n\n      ortc.validateSctpStreamParameters(sctpStreamParameters);\n      const {\n        id\n      } = await this.safeEmitAsPromise('producedata', {\n        sctpStreamParameters,\n        label,\n        protocol,\n        appData\n      });\n      const dataProducer = new DataProducer_1.DataProducer({\n        id,\n        dataChannel,\n        sctpStreamParameters,\n        appData\n      });\n\n      this._dataProducers.set(dataProducer.id, dataProducer);\n\n      this._handleDataProducer(dataProducer); // Emit observer event.\n\n\n      this._observer.safeEmit('newdataproducer', dataProducer);\n\n      return dataProducer;\n    }, 'transport.produceData()');\n  }\n  /**\n   * Create a DataConsumer\n   */\n\n\n  async consumeData({\n    id,\n    dataProducerId,\n    sctpStreamParameters,\n    label = '',\n    protocol = '',\n    appData = {}\n  }) {\n    logger.debug('consumeData()');\n    sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (this._direction !== 'recv') throw new errors_1.UnsupportedError('not a receiving Transport');else if (!this._maxSctpMessageSize) throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');else if (typeof id !== 'string') throw new TypeError('missing id');else if (typeof dataProducerId !== 'string') throw new TypeError('missing dataProducerId');else if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no \"connect\" listener set into this transport');else if (appData && typeof appData !== 'object') throw new TypeError('if given, appData must be an object'); // This may throw.\n\n    ortc.validateSctpStreamParameters(sctpStreamParameters); // Enqueue command.\n\n    return this._awaitQueue.push(async () => {\n      const {\n        dataChannel\n      } = await this._handler.receiveDataChannel({\n        sctpStreamParameters,\n        label,\n        protocol\n      });\n      const dataConsumer = new DataConsumer_1.DataConsumer({\n        id,\n        dataProducerId,\n        dataChannel,\n        sctpStreamParameters,\n        appData\n      });\n\n      this._dataConsumers.set(dataConsumer.id, dataConsumer);\n\n      this._handleDataConsumer(dataConsumer); // Emit observer event.\n\n\n      this._observer.safeEmit('newdataconsumer', dataConsumer);\n\n      return dataConsumer;\n    }, 'transport.consumeData()');\n  }\n\n  _handleHandler() {\n    const handler = this._handler;\n    handler.on('@connect', ({\n      dtlsParameters\n    }, callback, errback) => {\n      if (this._closed) {\n        errback(new errors_1.InvalidStateError('closed'));\n        return;\n      }\n\n      this.safeEmit('connect', {\n        dtlsParameters\n      }, callback, errback);\n    });\n    handler.on('@connectionstatechange', connectionState => {\n      if (connectionState === this._connectionState) return;\n      logger.debug('connection state changed to %s', connectionState);\n      this._connectionState = connectionState;\n      if (!this._closed) this.safeEmit('connectionstatechange', connectionState);\n    });\n  }\n\n  _handleProducer(producer) {\n    producer.on('@close', () => {\n      this._producers.delete(producer.id);\n\n      if (this._closed) return;\n\n      this._awaitQueue.push(async () => this._handler.stopSending(producer.localId), 'producer @close event').catch(error => logger.warn('producer.close() failed:%o', error));\n    });\n    producer.on('@replacetrack', (track, callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event').then(callback).catch(errback);\n    });\n    producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event').then(callback).catch(errback);\n    });\n    producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n      this._awaitQueue.push(async () => this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event').then(callback).catch(errback);\n    });\n    producer.on('@getstats', (callback, errback) => {\n      if (this._closed) return errback(new errors_1.InvalidStateError('closed'));\n\n      this._handler.getSenderStats(producer.localId).then(callback).catch(errback);\n    });\n  }\n\n  _handleConsumer(consumer) {\n    consumer.on('@close', () => {\n      this._consumers.delete(consumer.id);\n\n      if (this._closed) return;\n\n      this._awaitQueue.push(async () => this._handler.stopReceiving(consumer.localId), 'consumer @close event').catch(() => {});\n    });\n    consumer.on('@getstats', (callback, errback) => {\n      if (this._closed) return errback(new errors_1.InvalidStateError('closed'));\n\n      this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);\n    });\n  }\n\n  _handleDataProducer(dataProducer) {\n    dataProducer.on('@close', () => {\n      this._dataProducers.delete(dataProducer.id);\n    });\n  }\n\n  _handleDataConsumer(dataConsumer) {\n    dataConsumer.on('@close', () => {\n      this._dataConsumers.delete(dataConsumer.id);\n    });\n  }\n\n}\n\nexports.Transport = Transport;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/mediasoup-client/lib/Transport.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","exports","Transport","awaitqueue_1","require","Logger_1","EnhancedEventEmitter_1","errors_1","utils","ortc","Producer_1","Consumer_1","DataProducer_1","DataConsumer_1","logger","Logger","EnhancedEventEmitter","constructor","direction","id","iceParameters","iceCandidates","dtlsParameters","sctpParameters","iceServers","iceTransportPolicy","additionalSettings","proprietaryConstraints","appData","handlerFactory","extendedRtpCapabilities","canProduceByKind","_closed","_connectionState","_producers","Map","_consumers","_dataProducers","_dataConsumers","_probatorConsumerCreated","_awaitQueue","AwaitQueue","ClosedErrorClass","InvalidStateError","_observer","debug","_id","_direction","_extendedRtpCapabilities","_canProduceByKind","_maxSctpMessageSize","maxMessageSize","clone","bundlePolicy","rtcpMuxPolicy","sdpSemantics","_handler","run","_appData","_handleHandler","closed","handler","connectionState","Error","observer","close","producer","values","transportClosed","clear","consumer","dataProducer","dataConsumer","safeEmit","getStats","getTransportStats","restartIce","TypeError","push","updateIceServers","Array","isArray","produce","track","encodings","codecOptions","codec","stopTracks","disableTrackOnPause","zeroRtpOnPause","UnsupportedError","kind","readyState","listenerCount","normalizedEncodings","length","map","encoding","normalizedEncoding","active","dtx","scalabilityMode","scaleResolutionDownBy","maxBitrate","maxFramerate","adaptivePtime","priority","networkPriority","localId","rtpParameters","rtpSender","send","validateRtpParameters","safeEmitAsPromise","Producer","set","_handleProducer","error","stopSending","catch","stop","error2","consume","producerId","canConsume","canReceive","rtpReceiver","receive","trackId","Consumer","_handleConsumer","probatorRtpParameters","generateProbatorRtpParameters","produceData","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","dataChannel","sctpStreamParameters","sendDataChannel","validateSctpStreamParameters","DataProducer","_handleDataProducer","consumeData","dataProducerId","receiveDataChannel","DataConsumer","_handleDataConsumer","on","callback","errback","delete","warn","replaceTrack","then","spatialLayer","setMaxSpatialLayer","params","setRtpEncodingParameters","getSenderStats","stopReceiving","getReceiverStats"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst awaitqueue_1 = require(\"awaitqueue\");\nconst Logger_1 = require(\"./Logger\");\nconst EnhancedEventEmitter_1 = require(\"./EnhancedEventEmitter\");\nconst errors_1 = require(\"./errors\");\nconst utils = __importStar(require(\"./utils\"));\nconst ortc = __importStar(require(\"./ortc\"));\nconst Producer_1 = require(\"./Producer\");\nconst Consumer_1 = require(\"./Consumer\");\nconst DataProducer_1 = require(\"./DataProducer\");\nconst DataConsumer_1 = require(\"./DataConsumer\");\nconst logger = new Logger_1.Logger('Transport');\nclass Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits connect - (transportLocalParameters: any, callback: Function, errback: Function)\n     * @emits connectionstatechange - (connectionState: ConnectionState)\n     * @emits produce - (producerLocalParameters: any, callback: Function, errback: Function)\n     * @emits producedata - (dataProducerLocalParameters: any, callback: Function, errback: Function)\n     */\n    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Transport connection state.\n        this._connectionState = 'new';\n        // Map of Producers indexed by id.\n        this._producers = new Map();\n        // Map of Consumers indexed by id.\n        this._consumers = new Map();\n        // Map of DataProducers indexed by id.\n        this._dataProducers = new Map();\n        // Map of DataConsumers indexed by id.\n        this._dataConsumers = new Map();\n        // Whether the Consumer for RTP probation has been created.\n        this._probatorConsumerCreated = false;\n        // AwaitQueue instance to make async tasks happen sequentially.\n        this._awaitQueue = new awaitqueue_1.AwaitQueue({ ClosedErrorClass: errors_1.InvalidStateError });\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor() [id:%s, direction:%s]', id, direction);\n        this._id = id;\n        this._direction = direction;\n        this._extendedRtpCapabilities = extendedRtpCapabilities;\n        this._canProduceByKind = canProduceByKind;\n        this._maxSctpMessageSize =\n            sctpParameters ? sctpParameters.maxMessageSize : null;\n        // Clone and sanitize additionalSettings.\n        additionalSettings = utils.clone(additionalSettings, {});\n        delete additionalSettings.iceServers;\n        delete additionalSettings.iceTransportPolicy;\n        delete additionalSettings.bundlePolicy;\n        delete additionalSettings.rtcpMuxPolicy;\n        delete additionalSettings.sdpSemantics;\n        this._handler = handlerFactory();\n        this._handler.run({\n            direction,\n            iceParameters,\n            iceCandidates,\n            dtlsParameters,\n            sctpParameters,\n            iceServers,\n            iceTransportPolicy,\n            additionalSettings,\n            proprietaryConstraints,\n            extendedRtpCapabilities\n        });\n        this._appData = appData;\n        this._handleHandler();\n    }\n    /**\n     * Transport id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Whether the Transport is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Transport direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    /**\n     * RTC handler instance.\n     */\n    get handler() {\n        return this._handler;\n    }\n    /**\n     * Connection state.\n     */\n    get connectionState() {\n        return this._connectionState;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Observer.\n     *\n     * @emits close\n     * @emits newproducer - (producer: Producer)\n     * @emits newconsumer - (producer: Producer)\n     * @emits newdataproducer - (dataProducer: DataProducer)\n     * @emits newdataconsumer - (dataProducer: DataProducer)\n     */\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Close the Transport.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        // Close the AwaitQueue.\n        this._awaitQueue.close();\n        // Close the handler.\n        this._handler.close();\n        // Close all Producers.\n        for (const producer of this._producers.values()) {\n            producer.transportClosed();\n        }\n        this._producers.clear();\n        // Close all Consumers.\n        for (const consumer of this._consumers.values()) {\n            consumer.transportClosed();\n        }\n        this._consumers.clear();\n        // Close all DataProducers.\n        for (const dataProducer of this._dataProducers.values()) {\n            dataProducer.transportClosed();\n        }\n        this._dataProducers.clear();\n        // Close all DataConsumers.\n        for (const dataConsumer of this._dataConsumers.values()) {\n            dataConsumer.transportClosed();\n        }\n        this._dataConsumers.clear();\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated Transport (RTCPeerConnection) stats.\n     *\n     * @returns {RTCStatsReport}\n     */\n    async getStats() {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        return this._handler.getTransportStats();\n    }\n    /**\n     * Restart ICE connection.\n     */\n    async restartIce({ iceParameters }) {\n        logger.debug('restartIce()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!iceParameters)\n            throw new TypeError('missing iceParameters');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters), 'transport.restartIce()');\n    }\n    /**\n     * Update ICE servers.\n     */\n    async updateIceServers({ iceServers } = {}) {\n        logger.debug('updateIceServers()');\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (!Array.isArray(iceServers))\n            throw new TypeError('missing iceServers');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');\n    }\n    /**\n     * Create a Producer.\n     */\n    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {\n        logger.debug('produce() [track:%o]', track);\n        if (!track)\n            throw new TypeError('missing track');\n        else if (this._direction !== 'send')\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        else if (!this._canProduceByKind[track.kind])\n            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);\n        else if (track.readyState === 'ended')\n            throw new errors_1.InvalidStateError('track ended');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (this.listenerCount('produce') === 0)\n            throw new TypeError('no \"produce\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            let normalizedEncodings;\n            if (encodings && !Array.isArray(encodings)) {\n                throw TypeError('encodings must be an array');\n            }\n            else if (encodings && encodings.length === 0) {\n                normalizedEncodings = undefined;\n            }\n            else if (encodings) {\n                normalizedEncodings = encodings\n                    .map((encoding) => {\n                    const normalizedEncoding = { active: true };\n                    if (encoding.active === false)\n                        normalizedEncoding.active = false;\n                    if (typeof encoding.dtx === 'boolean')\n                        normalizedEncoding.dtx = encoding.dtx;\n                    if (typeof encoding.scalabilityMode === 'string')\n                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;\n                    if (typeof encoding.scaleResolutionDownBy === 'number')\n                        normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;\n                    if (typeof encoding.maxBitrate === 'number')\n                        normalizedEncoding.maxBitrate = encoding.maxBitrate;\n                    if (typeof encoding.maxFramerate === 'number')\n                        normalizedEncoding.maxFramerate = encoding.maxFramerate;\n                    if (typeof encoding.adaptivePtime === 'boolean')\n                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;\n                    if (typeof encoding.priority === 'string')\n                        normalizedEncoding.priority = encoding.priority;\n                    if (typeof encoding.networkPriority === 'string')\n                        normalizedEncoding.networkPriority = encoding.networkPriority;\n                    return normalizedEncoding;\n                });\n            }\n            const { localId, rtpParameters, rtpSender } = await this._handler.send({\n                track,\n                encodings: normalizedEncodings,\n                codecOptions,\n                codec\n            });\n            try {\n                // This will fill rtpParameters's missing fields with default values.\n                ortc.validateRtpParameters(rtpParameters);\n                const { id } = await this.safeEmitAsPromise('produce', {\n                    kind: track.kind,\n                    rtpParameters,\n                    appData\n                });\n                const producer = new Producer_1.Producer({\n                    id,\n                    localId,\n                    rtpSender,\n                    track,\n                    rtpParameters,\n                    stopTracks,\n                    disableTrackOnPause,\n                    zeroRtpOnPause,\n                    appData\n                });\n                this._producers.set(producer.id, producer);\n                this._handleProducer(producer);\n                // Emit observer event.\n                this._observer.safeEmit('newproducer', producer);\n                return producer;\n            }\n            catch (error) {\n                this._handler.stopSending(localId)\n                    .catch(() => { });\n                throw error;\n            }\n        }, 'transport.produce()')\n            // This catch is needed to stop the given track if the command above\n            // failed due to closed Transport.\n            .catch((error) => {\n            if (stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error2) { }\n            }\n            throw error;\n        });\n    }\n    /**\n     * Create a Consumer to consume a remote Producer.\n     */\n    async consume({ id, producerId, kind, rtpParameters, appData = {} }) {\n        logger.debug('consume()');\n        rtpParameters = utils.clone(rtpParameters, undefined);\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'recv')\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof producerId !== 'string')\n            throw new TypeError('missing producerId');\n        else if (kind !== 'audio' && kind !== 'video')\n            throw new TypeError(`invalid kind '${kind}'`);\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            // Ensure the device can consume it.\n            const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);\n            if (!canConsume)\n                throw new errors_1.UnsupportedError('cannot consume this Producer');\n            const { localId, rtpReceiver, track } = await this._handler.receive({ trackId: id, kind, rtpParameters });\n            const consumer = new Consumer_1.Consumer({\n                id,\n                localId,\n                producerId,\n                rtpReceiver,\n                track,\n                rtpParameters,\n                appData\n            });\n            this._consumers.set(consumer.id, consumer);\n            this._handleConsumer(consumer);\n            // If this is the first video Consumer and the Consumer for RTP probation\n            // has not yet been created, create it now.\n            if (!this._probatorConsumerCreated && kind === 'video') {\n                try {\n                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);\n                    await this._handler.receive({\n                        trackId: 'probator',\n                        kind: 'video',\n                        rtpParameters: probatorRtpParameters\n                    });\n                    logger.debug('consume() | Consumer for RTP probation created');\n                    this._probatorConsumerCreated = true;\n                }\n                catch (error) {\n                    logger.error('consume() | failed to create Consumer for RTP probation:%o', error);\n                }\n            }\n            // Emit observer event.\n            this._observer.safeEmit('newconsumer', consumer);\n            return consumer;\n        }, 'transport.consume()');\n    }\n    /**\n     * Create a DataProducer\n     */\n    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {} } = {}) {\n        logger.debug('produceData()');\n        if (this._direction !== 'send')\n            throw new errors_1.UnsupportedError('not a sending Transport');\n        else if (!this._maxSctpMessageSize)\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (this.listenerCount('producedata') === 0)\n            throw new TypeError('no \"producedata\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        if (maxPacketLifeTime || maxRetransmits)\n            ordered = false;\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({\n                ordered,\n                maxPacketLifeTime,\n                maxRetransmits,\n                label,\n                protocol\n            });\n            // This will fill sctpStreamParameters's missing fields with default values.\n            ortc.validateSctpStreamParameters(sctpStreamParameters);\n            const { id } = await this.safeEmitAsPromise('producedata', {\n                sctpStreamParameters,\n                label,\n                protocol,\n                appData\n            });\n            const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });\n            this._dataProducers.set(dataProducer.id, dataProducer);\n            this._handleDataProducer(dataProducer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataproducer', dataProducer);\n            return dataProducer;\n        }, 'transport.produceData()');\n    }\n    /**\n     * Create a DataConsumer\n     */\n    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {\n        logger.debug('consumeData()');\n        sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._direction !== 'recv')\n            throw new errors_1.UnsupportedError('not a receiving Transport');\n        else if (!this._maxSctpMessageSize)\n            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');\n        else if (typeof id !== 'string')\n            throw new TypeError('missing id');\n        else if (typeof dataProducerId !== 'string')\n            throw new TypeError('missing dataProducerId');\n        else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')\n            throw new TypeError('no \"connect\" listener set into this transport');\n        else if (appData && typeof appData !== 'object')\n            throw new TypeError('if given, appData must be an object');\n        // This may throw.\n        ortc.validateSctpStreamParameters(sctpStreamParameters);\n        // Enqueue command.\n        return this._awaitQueue.push(async () => {\n            const { dataChannel } = await this._handler.receiveDataChannel({\n                sctpStreamParameters,\n                label,\n                protocol\n            });\n            const dataConsumer = new DataConsumer_1.DataConsumer({\n                id,\n                dataProducerId,\n                dataChannel,\n                sctpStreamParameters,\n                appData\n            });\n            this._dataConsumers.set(dataConsumer.id, dataConsumer);\n            this._handleDataConsumer(dataConsumer);\n            // Emit observer event.\n            this._observer.safeEmit('newdataconsumer', dataConsumer);\n            return dataConsumer;\n        }, 'transport.consumeData()');\n    }\n    _handleHandler() {\n        const handler = this._handler;\n        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {\n            if (this._closed) {\n                errback(new errors_1.InvalidStateError('closed'));\n                return;\n            }\n            this.safeEmit('connect', { dtlsParameters }, callback, errback);\n        });\n        handler.on('@connectionstatechange', (connectionState) => {\n            if (connectionState === this._connectionState)\n                return;\n            logger.debug('connection state changed to %s', connectionState);\n            this._connectionState = connectionState;\n            if (!this._closed)\n                this.safeEmit('connectionstatechange', connectionState);\n        });\n    }\n    _handleProducer(producer) {\n        producer.on('@close', () => {\n            this._producers.delete(producer.id);\n            if (this._closed)\n                return;\n            this._awaitQueue.push(async () => this._handler.stopSending(producer.localId), 'producer @close event')\n                .catch((error) => logger.warn('producer.close() failed:%o', error));\n        });\n        producer.on('@replacetrack', (track, callback, errback) => {\n            this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {\n            this._awaitQueue.push(async () => (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer)), 'producer @setmaxspatiallayer event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@setrtpencodingparameters', (params, callback, errback) => {\n            this._awaitQueue.push(async () => (this._handler.setRtpEncodingParameters(producer.localId, params)), 'producer @setrtpencodingparameters event')\n                .then(callback)\n                .catch(errback);\n        });\n        producer.on('@getstats', (callback, errback) => {\n            if (this._closed)\n                return errback(new errors_1.InvalidStateError('closed'));\n            this._handler.getSenderStats(producer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    _handleConsumer(consumer) {\n        consumer.on('@close', () => {\n            this._consumers.delete(consumer.id);\n            if (this._closed)\n                return;\n            this._awaitQueue.push(async () => this._handler.stopReceiving(consumer.localId), 'consumer @close event')\n                .catch(() => { });\n        });\n        consumer.on('@getstats', (callback, errback) => {\n            if (this._closed)\n                return errback(new errors_1.InvalidStateError('closed'));\n            this._handler.getReceiverStats(consumer.localId)\n                .then(callback)\n                .catch(errback);\n        });\n    }\n    _handleDataProducer(dataProducer) {\n        dataProducer.on('@close', () => {\n            this._dataProducers.delete(dataProducer.id);\n        });\n    }\n    _handleDataConsumer(dataConsumer) {\n        dataConsumer.on('@close', () => {\n            this._dataConsumers.delete(dataConsumer.id);\n        });\n    }\n}\nexports.Transport = Transport;\n"]},"metadata":{},"sourceType":"script"}