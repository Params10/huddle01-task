{"ast":null,"code":"const W3CWebSocket = require('websocket').w3cwebsocket;\n\nconst retry = require('retry');\n\nconst Logger = require('../Logger');\n\nconst EnhancedEventEmitter = require('../EnhancedEventEmitter');\n\nconst Message = require('../Message');\n\nconst WS_SUBPROTOCOL = 'protoo';\nconst DEFAULT_RETRY_OPTIONS = {\n  retries: 10,\n  factor: 2,\n  minTimeout: 1 * 1000,\n  maxTimeout: 8 * 1000\n};\nconst logger = new Logger('WebSocketTransport');\n\nclass WebSocketTransport extends EnhancedEventEmitter {\n  /**\n   * @param {String} url - WebSocket URL.\n   * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.\n   */\n  constructor(url, options) {\n    super(logger);\n    logger.debug('constructor() [url:%s, options:%o]', url, options); // Closed flag.\n    // @type {Boolean}\n\n    this._closed = false; // WebSocket URL.\n    // @type {String}\n\n    this._url = url; // Options.\n    // @type {Object}\n\n    this._options = options || {}; // WebSocket instance.\n    // @type {WebSocket}\n\n    this._ws = null; // Run the WebSocket.\n\n    this._runWebSocket();\n  }\n\n  get closed() {\n    return this._closed;\n  }\n\n  close() {\n    if (this._closed) return;\n    logger.debug('close()'); // Don't wait for the WebSocket 'close' event, do it now.\n\n    this._closed = true;\n    this.safeEmit('close');\n\n    try {\n      this._ws.onopen = null;\n      this._ws.onclose = null;\n      this._ws.onerror = null;\n      this._ws.onmessage = null;\n\n      this._ws.close();\n    } catch (error) {\n      logger.error('close() | error closing the WebSocket: %o', error);\n    }\n  }\n\n  async send(message) {\n    if (this._closed) throw new Error('transport closed');\n\n    try {\n      this._ws.send(JSON.stringify(message));\n    } catch (error) {\n      logger.warn('send() failed:%o', error);\n      throw error;\n    }\n  }\n\n  _runWebSocket() {\n    const operation = retry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);\n    let wasConnected = false;\n    operation.attempt(currentAttempt => {\n      if (this._closed) {\n        operation.stop();\n        return;\n      }\n\n      logger.debug('_runWebSocket() [currentAttempt:%s]', currentAttempt);\n      this._ws = new W3CWebSocket(this._url, WS_SUBPROTOCOL, this._options.origin, this._options.headers, this._options.requestOptions, this._options.clientConfig);\n\n      this._ws.onopen = () => {\n        if (this._closed) return;\n        wasConnected = true; // Emit 'open' event.\n\n        this.safeEmit('open');\n      };\n\n      this._ws.onclose = event => {\n        if (this._closed) return;\n        logger.warn('WebSocket \"close\" event [wasClean:%s, code:%s, reason:\"%s\"]', event.wasClean, event.code, event.reason); // Don't retry if code is 4000 (closed by the server).\n\n        if (event.code !== 4000) {\n          // If it was not connected, try again.\n          if (!wasConnected) {\n            this.safeEmit('failed', currentAttempt);\n            if (this._closed) return;\n            if (operation.retry(true)) return;\n          } // If it was connected, start from scratch.\n          else {\n            operation.stop();\n            this.safeEmit('disconnected');\n            if (this._closed) return;\n\n            this._runWebSocket();\n\n            return;\n          }\n        }\n\n        this._closed = true; // Emit 'close' event.\n\n        this.safeEmit('close');\n      };\n\n      this._ws.onerror = () => {\n        if (this._closed) return;\n        logger.error('WebSocket \"error\" event');\n      };\n\n      this._ws.onmessage = event => {\n        if (this._closed) return;\n        const message = Message.parse(event.data);\n        if (!message) return;\n\n        if (this.listenerCount('message') === 0) {\n          logger.error('no listeners for WebSocket \"message\" event, ignoring received message');\n          return;\n        } // Emit 'message' event.\n\n\n        this.safeEmit('message', message);\n      };\n    });\n  }\n\n}\n\nmodule.exports = WebSocketTransport;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/protoo-client/lib/transports/WebSocketTransport.js"],"names":["W3CWebSocket","require","w3cwebsocket","retry","Logger","EnhancedEventEmitter","Message","WS_SUBPROTOCOL","DEFAULT_RETRY_OPTIONS","retries","factor","minTimeout","maxTimeout","logger","WebSocketTransport","constructor","url","options","debug","_closed","_url","_options","_ws","_runWebSocket","closed","close","safeEmit","onopen","onclose","onerror","onmessage","error","send","message","Error","JSON","stringify","warn","operation","wasConnected","attempt","currentAttempt","stop","origin","headers","requestOptions","clientConfig","event","wasClean","code","reason","parse","data","listenerCount","module","exports"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBC,YAA1C;;AACA,MAAMC,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMI,oBAAoB,GAAGJ,OAAO,CAAC,yBAAD,CAApC;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,YAAD,CAAvB;;AAEA,MAAMM,cAAc,GAAG,QAAvB;AACA,MAAMC,qBAAqB,GAC3B;AACCC,EAAAA,OAAO,EAAM,EADd;AAECC,EAAAA,MAAM,EAAO,CAFd;AAGCC,EAAAA,UAAU,EAAG,IAAI,IAHlB;AAICC,EAAAA,UAAU,EAAG,IAAI;AAJlB,CADA;AAQA,MAAMC,MAAM,GAAG,IAAIT,MAAJ,CAAW,oBAAX,CAAf;;AAEA,MAAMU,kBAAN,SAAiCT,oBAAjC,CACA;AACC;AACD;AACA;AACA;AACCU,EAAAA,WAAW,CAACC,GAAD,EAAMC,OAAN,EACX;AACC,UAAMJ,MAAN;AAEAA,IAAAA,MAAM,CAACK,KAAP,CAAa,oCAAb,EAAmDF,GAAnD,EAAwDC,OAAxD,EAHD,CAKC;AACA;;AACA,SAAKE,OAAL,GAAe,KAAf,CAPD,CASC;AACA;;AACA,SAAKC,IAAL,GAAYJ,GAAZ,CAXD,CAaC;AACA;;AACA,SAAKK,QAAL,GAAgBJ,OAAO,IAAI,EAA3B,CAfD,CAiBC;AACA;;AACA,SAAKK,GAAL,GAAW,IAAX,CAnBD,CAqBC;;AACA,SAAKC,aAAL;AACA;;AAES,MAANC,MAAM,GACV;AACC,WAAO,KAAKL,OAAZ;AACA;;AAEDM,EAAAA,KAAK,GACL;AACC,QAAI,KAAKN,OAAT,EACC;AAEDN,IAAAA,MAAM,CAACK,KAAP,CAAa,SAAb,EAJD,CAMC;;AACA,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKO,QAAL,CAAc,OAAd;;AAEA,QACA;AACC,WAAKJ,GAAL,CAASK,MAAT,GAAkB,IAAlB;AACA,WAAKL,GAAL,CAASM,OAAT,GAAmB,IAAnB;AACA,WAAKN,GAAL,CAASO,OAAT,GAAmB,IAAnB;AACA,WAAKP,GAAL,CAASQ,SAAT,GAAqB,IAArB;;AACA,WAAKR,GAAL,CAASG,KAAT;AACA,KAPD,CAQA,OAAOM,KAAP,EACA;AACClB,MAAAA,MAAM,CAACkB,KAAP,CAAa,2CAAb,EAA0DA,KAA1D;AACA;AACD;;AAES,QAAJC,IAAI,CAACC,OAAD,EACV;AACC,QAAI,KAAKd,OAAT,EACC,MAAM,IAAIe,KAAJ,CAAU,kBAAV,CAAN;;AAED,QACA;AACC,WAAKZ,GAAL,CAASU,IAAT,CAAcG,IAAI,CAACC,SAAL,CAAeH,OAAf,CAAd;AACA,KAHD,CAIA,OAAOF,KAAP,EACA;AACClB,MAAAA,MAAM,CAACwB,IAAP,CAAY,kBAAZ,EAAgCN,KAAhC;AAEA,YAAMA,KAAN;AACA;AACD;;AAEDR,EAAAA,aAAa,GACb;AACC,UAAMe,SAAS,GACdnC,KAAK,CAACmC,SAAN,CAAgB,KAAKjB,QAAL,CAAclB,KAAd,IAAuBK,qBAAvC,CADD;AAGA,QAAI+B,YAAY,GAAG,KAAnB;AAEAD,IAAAA,SAAS,CAACE,OAAV,CAAmBC,cAAD,IAClB;AACC,UAAI,KAAKtB,OAAT,EACA;AACCmB,QAAAA,SAAS,CAACI,IAAV;AAEA;AACA;;AAED7B,MAAAA,MAAM,CAACK,KAAP,CAAa,qCAAb,EAAoDuB,cAApD;AAEA,WAAKnB,GAAL,GAAW,IAAItB,YAAJ,CACV,KAAKoB,IADK,EAEVb,cAFU,EAGV,KAAKc,QAAL,CAAcsB,MAHJ,EAIV,KAAKtB,QAAL,CAAcuB,OAJJ,EAKV,KAAKvB,QAAL,CAAcwB,cALJ,EAMV,KAAKxB,QAAL,CAAcyB,YANJ,CAAX;;AAQA,WAAKxB,GAAL,CAASK,MAAT,GAAkB,MAClB;AACC,YAAI,KAAKR,OAAT,EACC;AAEDoB,QAAAA,YAAY,GAAG,IAAf,CAJD,CAMC;;AACA,aAAKb,QAAL,CAAc,MAAd;AACA,OATD;;AAWA,WAAKJ,GAAL,CAASM,OAAT,GAAoBmB,KAAD,IACnB;AACC,YAAI,KAAK5B,OAAT,EACC;AAEDN,QAAAA,MAAM,CAACwB,IAAP,CACC,6DADD,EAECU,KAAK,CAACC,QAFP,EAEiBD,KAAK,CAACE,IAFvB,EAE6BF,KAAK,CAACG,MAFnC,EAJD,CAQC;;AACA,YAAIH,KAAK,CAACE,IAAN,KAAe,IAAnB,EACA;AACC;AACA,cAAI,CAACV,YAAL,EACA;AACC,iBAAKb,QAAL,CAAc,QAAd,EAAwBe,cAAxB;AAEA,gBAAI,KAAKtB,OAAT,EACC;AAED,gBAAImB,SAAS,CAACnC,KAAV,CAAgB,IAAhB,CAAJ,EACC;AACD,WATD,CAUA;AAVA,eAYA;AACCmC,YAAAA,SAAS,CAACI,IAAV;AAEA,iBAAKhB,QAAL,CAAc,cAAd;AAEA,gBAAI,KAAKP,OAAT,EACC;;AAED,iBAAKI,aAAL;;AAEA;AACA;AACD;;AAED,aAAKJ,OAAL,GAAe,IAAf,CAtCD,CAwCC;;AACA,aAAKO,QAAL,CAAc,OAAd;AACA,OA3CD;;AA6CA,WAAKJ,GAAL,CAASO,OAAT,GAAmB,MACnB;AACC,YAAI,KAAKV,OAAT,EACC;AAEDN,QAAAA,MAAM,CAACkB,KAAP,CAAa,yBAAb;AACA,OAND;;AAQA,WAAKT,GAAL,CAASQ,SAAT,GAAsBiB,KAAD,IACrB;AACC,YAAI,KAAK5B,OAAT,EACC;AAED,cAAMc,OAAO,GAAG3B,OAAO,CAAC6C,KAAR,CAAcJ,KAAK,CAACK,IAApB,CAAhB;AAEA,YAAI,CAACnB,OAAL,EACC;;AAED,YAAI,KAAKoB,aAAL,CAAmB,SAAnB,MAAkC,CAAtC,EACA;AACCxC,UAAAA,MAAM,CAACkB,KAAP,CACC,uEADD;AAGA;AACA,SAfF,CAiBC;;;AACA,aAAKL,QAAL,CAAc,SAAd,EAAyBO,OAAzB;AACA,OApBD;AAqBA,KAxGD;AAyGA;;AA9LF;;AAiMAqB,MAAM,CAACC,OAAP,GAAiBzC,kBAAjB","sourcesContent":["const W3CWebSocket = require('websocket').w3cwebsocket;\nconst retry = require('retry');\nconst Logger = require('../Logger');\nconst EnhancedEventEmitter = require('../EnhancedEventEmitter');\nconst Message = require('../Message');\n\nconst WS_SUBPROTOCOL = 'protoo';\nconst DEFAULT_RETRY_OPTIONS =\n{\n\tretries    : 10,\n\tfactor     : 2,\n\tminTimeout : 1 * 1000,\n\tmaxTimeout : 8 * 1000\n};\n\nconst logger = new Logger('WebSocketTransport');\n\nclass WebSocketTransport extends EnhancedEventEmitter\n{\n\t/**\n\t * @param {String} url - WebSocket URL.\n\t * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.\n\t */\n\tconstructor(url, options)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor() [url:%s, options:%o]', url, options);\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// WebSocket URL.\n\t\t// @type {String}\n\t\tthis._url = url;\n\n\t\t// Options.\n\t\t// @type {Object}\n\t\tthis._options = options || {};\n\n\t\t// WebSocket instance.\n\t\t// @type {WebSocket}\n\t\tthis._ws = null;\n\n\t\t// Run the WebSocket.\n\t\tthis._runWebSocket();\n\t}\n\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\tclose()\n\t{\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tlogger.debug('close()');\n\n\t\t// Don't wait for the WebSocket 'close' event, do it now.\n\t\tthis._closed = true;\n\t\tthis.safeEmit('close');\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.onopen = null;\n\t\t\tthis._ws.onclose = null;\n\t\t\tthis._ws.onerror = null;\n\t\t\tthis._ws.onmessage = null;\n\t\t\tthis._ws.close();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error('close() | error closing the WebSocket: %o', error);\n\t\t}\n\t}\n\n\tasync send(message)\n\t{\n\t\tif (this._closed)\n\t\t\tthrow new Error('transport closed');\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.send(JSON.stringify(message));\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.warn('send() failed:%o', error);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t_runWebSocket()\n\t{\n\t\tconst operation =\n\t\t\tretry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);\n\n\t\tlet wasConnected = false;\n\n\t\toperation.attempt((currentAttempt) =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t{\n\t\t\t\toperation.stop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug('_runWebSocket() [currentAttempt:%s]', currentAttempt);\n\n\t\t\tthis._ws = new W3CWebSocket(\n\t\t\t\tthis._url,\n\t\t\t\tWS_SUBPROTOCOL,\n\t\t\t\tthis._options.origin,\n\t\t\t\tthis._options.headers,\n\t\t\t\tthis._options.requestOptions,\n\t\t\t\tthis._options.clientConfig);\n\n\t\t\tthis._ws.onopen = () =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\twasConnected = true;\n\n\t\t\t\t// Emit 'open' event.\n\t\t\t\tthis.safeEmit('open');\n\t\t\t};\n\n\t\t\tthis._ws.onclose = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'WebSocket \"close\" event [wasClean:%s, code:%s, reason:\"%s\"]',\n\t\t\t\t\tevent.wasClean, event.code, event.reason);\n\n\t\t\t\t// Don't retry if code is 4000 (closed by the server).\n\t\t\t\tif (event.code !== 4000)\n\t\t\t\t{\n\t\t\t\t\t// If it was not connected, try again.\n\t\t\t\t\tif (!wasConnected)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.safeEmit('failed', currentAttempt);\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tif (operation.retry(true))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// If it was connected, start from scratch.\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toperation.stop();\n\n\t\t\t\t\t\tthis.safeEmit('disconnected');\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tthis._runWebSocket();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._closed = true;\n\n\t\t\t\t// Emit 'close' event.\n\t\t\t\tthis.safeEmit('close');\n\t\t\t};\n\n\t\t\tthis._ws.onerror = () =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tlogger.error('WebSocket \"error\" event');\n\t\t\t};\n\n\t\t\tthis._ws.onmessage = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tconst message = Message.parse(event.data);\n\n\t\t\t\tif (!message)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (this.listenerCount('message') === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'no listeners for WebSocket \"message\" event, ignoring received message');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Emit 'message' event.\n\t\t\t\tthis.safeEmit('message', message);\n\t\t\t};\n\t\t});\n\t}\n}\n\nmodule.exports = WebSocketTransport;\n"]},"metadata":{},"sourceType":"script"}