{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transport = void 0;\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst Types = __importStar(require(\"@keepkey/device-protocol/lib/types_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst jspb = __importStar(require(\"google-protobuf\"));\n\nconst responseTypeRegistry_1 = require(\"./responseTypeRegistry\");\n\nconst typeRegistry_1 = require(\"./typeRegistry\");\n\nconst utils_1 = require(\"./utils\");\n\nclass Transport extends core.Transport {\n  constructor(keyring, delegate) {\n    super(keyring);\n    this.debugLink = false;\n    this.userActionRequired = false; /// One per transport, unlike on Trezor, since the contention is\n    /// only per-device, not global.\n\n    this.callInProgress = {\n      main: undefined,\n      debug: undefined\n    };\n    this.delegate = delegate;\n  }\n\n  static create(keyring, delegate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Transport(keyring, delegate);\n    });\n  }\n\n  isOpened() {\n    return this.delegate.isOpened();\n  }\n\n  getDeviceID() {\n    return this.delegate.getDeviceID();\n  }\n\n  connect() {\n    return this.delegate.connect();\n  }\n\n  tryConnectDebugLink() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let out = false;\n      if (this.delegate.tryConnectDebugLink && (yield this.delegate.tryConnectDebugLink())) out = true;\n      this.debugLink = out;\n      return out;\n    });\n  }\n\n  disconnect() {\n    return this.delegate.disconnect();\n  }\n\n  write(buf, debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // break frame into segments\n      for (let i = 0; i < buf.length; i += utils_1.SEGMENT_SIZE) {\n        const segment = buf.slice(i, i + utils_1.SEGMENT_SIZE);\n        const padding = new Uint8Array(utils_1.SEGMENT_SIZE - segment.length);\n        const fragments = [];\n        fragments.push(new Uint8Array([63]));\n        fragments.push(segment);\n        fragments.push(padding);\n        const fragmentBuffer = new Uint8Array(fragments.map(x => x.length).reduce((a, x) => a + x, 0));\n        fragments.reduce((a, x) => (fragmentBuffer.set(x, a), a + x.length), 0);\n        yield this.delegate.writeChunk(fragmentBuffer, debugLink);\n      }\n    });\n  }\n\n  read(debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const first = yield this.delegate.readChunk(debugLink); // Check that buffer starts with: \"?##\" [ 0x3f, 0x23, 0x23 ]\n      // \"?\" = USB reportId, \"##\" = KeepKey magic bytes\n      // Message ID is bytes 4-5. Message length starts at byte 6.\n\n      const firstView = new DataView(first.buffer.slice(first.byteOffset, first.byteOffset + first.byteLength));\n      const valid = (firstView.getUint32(0) & 0xffffff00) === 0x3f232300;\n      const msgLength = firstView.getUint32(5);\n      if (!valid) throw new Error(\"message not valid\");\n      const buffer = new Uint8Array(9 + 2 + msgLength);\n      buffer.set(first.slice(0, Math.min(first.length, buffer.length)));\n\n      for (let offset = first.length; offset < buffer.length;) {\n        // Drop USB \"?\" reportId in the first byte\n        let next = (yield this.delegate.readChunk(debugLink)).slice(1);\n        buffer.set(next.slice(0, Math.min(next.length, buffer.length - offset)), offset);\n        offset += next.length;\n      }\n\n      return buffer;\n    });\n  }\n\n  getVendor() {\n    return \"KeepKey\";\n  }\n\n  getEntropy(length) {\n    if (typeof window !== \"undefined\" && (window === null || window === void 0 ? void 0 : window.crypto)) {\n      return window.crypto.getRandomValues(new Uint8Array(length));\n    }\n\n    const {\n      randomBytes\n    } = require(\"crypto\");\n\n    return randomBytes(length);\n  }\n\n  getFirmwareHash(firmware) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof window !== \"undefined\" && (window === null || window === void 0 ? void 0 : window.crypto)) {\n        return new Uint8Array(yield window.crypto.subtle.digest({\n          name: \"SHA-256\"\n        }, firmware));\n      }\n\n      const {\n        createHash\n      } = require(\"crypto\");\n\n      const hash = createHash(\"sha256\");\n      hash.update(firmware);\n      return hash.digest();\n    });\n  }\n  /**\n   * Utility function to cancel all pending calls whenver one of them is cancelled.\n   */\n\n\n  cancellable(inProgress) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield inProgress;\n      } catch (e) {\n        // Throw away the error, as the other context will handle it,\n        // unless it was a cancel, in which case we cancel everything.\n        if (e.type === core.HDWalletErrorType.ActionCancelled) {\n          this.callInProgress = {\n            main: undefined,\n            debug: undefined\n          };\n          throw e;\n        }\n      }\n    });\n  }\n\n  lockDuring(action) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.callInProgress.main = (() => __awaiter(this, void 0, void 0, function* () {\n        yield this.cancellable(this.callInProgress.main);\n        return action();\n      }))();\n\n      return this.callInProgress.main;\n    });\n  }\n\n  handleCancellableResponse(messageType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const event = yield core.takeFirstOfManyEvents(this, [String(messageType), ...responseTypeRegistry_1.EXIT_TYPES]).toPromise();\n      return this.readResponse(false);\n    });\n  }\n\n  readResponse(debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf;\n\n      do {\n        buf = yield this.read(debugLink);\n      } while (!buf);\n\n      const [msgTypeEnum, msg] = this.fromMessageBuffer(buf);\n      let event = core.makeEvent({\n        message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],\n        message_enum: msgTypeEnum,\n        message: msg.toObject(),\n        proto: msg,\n        from_wallet: true\n      });\n      this.emit(String(msgTypeEnum), event);\n      if (debugLink) return event;\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n        const failureEvent = core.makeEvent({\n          message_type: core.Events.FAILURE,\n          message_enum: msgTypeEnum,\n          message: msg.toObject(),\n          from_wallet: true\n        });\n        this.emit(core.Events.FAILURE, failureEvent);\n        return failureEvent;\n      }\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_BUTTONREQUEST) {\n        this.emit(core.Events.BUTTON_REQUEST, core.makeEvent({\n          message_type: core.Events.BUTTON_REQUEST,\n          from_wallet: true\n        }));\n        this.userActionRequired = true;\n        return this.call(Messages.MessageType.MESSAGETYPE_BUTTONACK, new Messages.ButtonAck(), core.LONG_TIMEOUT, true, false);\n      }\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_ENTROPYREQUEST) {\n        const ack = new Messages.EntropyAck();\n        ack.setEntropy(this.getEntropy(32));\n        return this.call(Messages.MessageType.MESSAGETYPE_ENTROPYACK, ack, core.LONG_TIMEOUT, true, false);\n      }\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_PINMATRIXREQUEST) {\n        this.emit(core.Events.PIN_REQUEST, core.makeEvent({\n          message_type: core.Events.PIN_REQUEST,\n          from_wallet: true\n        }));\n        this.userActionRequired = true;\n        return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_PINMATRIXACK);\n      }\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_PASSPHRASEREQUEST) {\n        this.emit(core.Events.PASSPHRASE_REQUEST, core.makeEvent({\n          message_type: core.Events.PASSPHRASE_REQUEST,\n          from_wallet: true\n        }));\n        this.userActionRequired = true;\n        return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_PASSPHRASEACK);\n      }\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_CHARACTERREQUEST) {\n        this.emit(core.Events.CHARACTER_REQUEST, core.makeEvent({\n          message_type: core.Events.CHARACTER_REQUEST,\n          from_wallet: true\n        }));\n        this.userActionRequired = true;\n        return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_CHARACTERACK);\n      }\n\n      if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_WORDREQUEST) {\n        this.emit(core.Events.WORD_REQUEST, core.makeEvent({\n          message_type: core.Events.WORD_REQUEST,\n          from_wallet: true\n        }));\n        this.userActionRequired = true;\n        return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_WORDACK);\n      }\n\n      return event;\n    });\n  }\n\n  call(msgTypeEnum, msg, msgTimeout = core.DEFAULT_TIMEOUT, omitLock = false, noWait = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.emit(String(msgTypeEnum), core.makeEvent({\n        message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],\n        message_enum: msgTypeEnum,\n        message: msg.toObject(),\n        proto: msg,\n        from_wallet: false\n      }));\n\n      let makePromise = () => __awaiter(this, void 0, void 0, function* () {\n        if ([Messages.MessageType.MESSAGETYPE_BUTTONACK, Messages.MessageType.MESSAGETYPE_PASSPHRASEACK, Messages.MessageType.MESSAGETYPE_CHARACTERACK, Messages.MessageType.MESSAGETYPE_PINMATRIXACK, Messages.MessageType.MESSAGETYPE_WORDACK].includes(msgTypeEnum)) {\n          this.userActionRequired = true;\n        }\n\n        yield this.write(this.toMessageBuffer(msgTypeEnum, msg), false);\n\n        if (!noWait) {\n          const response = yield this.readResponse(false);\n          this.userActionRequired = false;\n\n          if (response.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE && response.message.code === Types.FailureType.FAILURE_ACTIONCANCELLED) {\n            this.callInProgress = {\n              main: undefined,\n              debug: undefined\n            };\n            throw new core.ActionCancelled();\n          }\n\n          return response;\n        }\n      });\n\n      if (!omitLock) {\n        // See the comments in hdwallet-trezor-connect's call for why this weird\n        // sequence. We've got a very similar issue here that needs pretty much\n        // the same solution.\n        this.callInProgress.main = (() => __awaiter(this, void 0, void 0, function* () {\n          yield this.cancellable(this.callInProgress.main);\n\n          try {\n            return makePromise();\n          } finally {\n            this.userActionRequired = false;\n          }\n        }))();\n\n        return yield this.callInProgress.main;\n      } else {\n        return makePromise();\n      }\n    });\n  }\n\n  callDebugLink(msgTypeEnum, msg, msgTimeout = core.DEFAULT_TIMEOUT, omitLock = false, noWait = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.emit(String(msgTypeEnum), core.makeEvent({\n        message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],\n        message_enum: msgTypeEnum,\n        message: msg.toObject(),\n        proto: msg,\n        from_wallet: false\n      }));\n\n      let makePromise = () => __awaiter(this, void 0, void 0, function* () {\n        yield this.write(this.toMessageBuffer(msgTypeEnum, msg), true);\n        if (!noWait) return this.readResponse(true);\n      });\n\n      if (!omitLock) {\n        this.callInProgress.debug = (() => __awaiter(this, void 0, void 0, function* () {\n          yield this.cancellable(this.callInProgress.debug);\n          return makePromise();\n        }))();\n\n        return yield this.callInProgress.debug;\n      } else {\n        return makePromise();\n      }\n    });\n  }\n\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.userActionRequired) return;\n\n      try {\n        this.callInProgress = {\n          main: undefined,\n          debug: undefined\n        };\n        const cancelMsg = new Messages.Cancel();\n        yield this.call(Messages.MessageType.MESSAGETYPE_CANCEL, cancelMsg, core.DEFAULT_TIMEOUT, false, this.userActionRequired);\n      } catch (e) {\n        console.error(\"Cancel Pending Error\", e);\n      } finally {\n        this.callInProgress = {\n          main: undefined,\n          debug: undefined\n        };\n      }\n    });\n  }\n\n  toMessageBuffer(msgTypeEnum, msg) {\n    const messageBuffer = msg.serializeBinary();\n    const headerBuffer = new Uint8Array(8);\n    const headerView = new DataView(headerBuffer.buffer);\n    headerView.setUint8(0, 0x23);\n    headerView.setUint8(1, 0x23);\n    headerView.setUint16(2, msgTypeEnum);\n    headerView.setUint32(4, messageBuffer.byteLength);\n    const fragments = [headerBuffer, messageBuffer];\n    const fragmentBuffer = new Uint8Array(fragments.map(x => x.length).reduce((a, x) => a + x, 0));\n    fragments.reduce((a, x) => (fragmentBuffer.set(x, a), a + x.length), 0);\n    return fragmentBuffer;\n  }\n\n  fromMessageBuffer(buf) {\n    const typeID = new DataView(buf.buffer).getUint16(3);\n    const MType = typeRegistry_1.messageTypeRegistry[typeID];\n\n    if (!MType) {\n      const msg = new Messages.Failure();\n      msg.setCode(Types.FailureType.FAILURE_UNEXPECTEDMESSAGE);\n      msg.setMessage(\"Unknown message type received\");\n      return [Messages.MessageType.MESSAGETYPE_FAILURE, msg];\n    }\n\n    const msg = new MType();\n    const reader = new jspb.BinaryReader(buf, 9, buf.length - (9 + 2));\n    return [typeID, MType.deserializeBinaryFromReader(msg, reader)];\n  }\n\n  static failureMessageFactory(e) {\n    const msg = new Messages.Failure();\n    msg.setCode(Types.FailureType.FAILURE_UNEXPECTEDMESSAGE);\n\n    if (typeof e === \"string\") {\n      msg.setMessage(e);\n    } else {\n      msg.setMessage(String(e));\n    }\n\n    return msg.serializeBinary();\n  }\n\n}\n\nexports.Transport = Transport;","map":{"version":3,"sources":["../src/transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transport = void 0;\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\nconst Types = __importStar(require(\"@keepkey/device-protocol/lib/types_pb\"));\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst jspb = __importStar(require(\"google-protobuf\"));\nconst responseTypeRegistry_1 = require(\"./responseTypeRegistry\");\nconst typeRegistry_1 = require(\"./typeRegistry\");\nconst utils_1 = require(\"./utils\");\nclass Transport extends core.Transport {\n    constructor(keyring, delegate) {\n        super(keyring);\n        this.debugLink = false;\n        this.userActionRequired = false;\n        /// One per transport, unlike on Trezor, since the contention is\n        /// only per-device, not global.\n        this.callInProgress = {\n            main: undefined,\n            debug: undefined,\n        };\n        this.delegate = delegate;\n    }\n    static create(keyring, delegate) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Transport(keyring, delegate);\n        });\n    }\n    isOpened() {\n        return this.delegate.isOpened();\n    }\n    getDeviceID() {\n        return this.delegate.getDeviceID();\n    }\n    connect() {\n        return this.delegate.connect();\n    }\n    tryConnectDebugLink() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let out = false;\n            if (this.delegate.tryConnectDebugLink && (yield this.delegate.tryConnectDebugLink()))\n                out = true;\n            this.debugLink = out;\n            return out;\n        });\n    }\n    disconnect() {\n        return this.delegate.disconnect();\n    }\n    write(buf, debugLink) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // break frame into segments\n            for (let i = 0; i < buf.length; i += utils_1.SEGMENT_SIZE) {\n                const segment = buf.slice(i, i + utils_1.SEGMENT_SIZE);\n                const padding = new Uint8Array(utils_1.SEGMENT_SIZE - segment.length);\n                const fragments = [];\n                fragments.push(new Uint8Array([63]));\n                fragments.push(segment);\n                fragments.push(padding);\n                const fragmentBuffer = new Uint8Array(fragments.map((x) => x.length).reduce((a, x) => a + x, 0));\n                fragments.reduce((a, x) => (fragmentBuffer.set(x, a), a + x.length), 0);\n                yield this.delegate.writeChunk(fragmentBuffer, debugLink);\n            }\n        });\n    }\n    read(debugLink) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const first = yield this.delegate.readChunk(debugLink);\n            // Check that buffer starts with: \"?##\" [ 0x3f, 0x23, 0x23 ]\n            // \"?\" = USB reportId, \"##\" = KeepKey magic bytes\n            // Message ID is bytes 4-5. Message length starts at byte 6.\n            const firstView = new DataView(first.buffer.slice(first.byteOffset, first.byteOffset + first.byteLength));\n            const valid = (firstView.getUint32(0) & 0xffffff00) === 0x3f232300;\n            const msgLength = firstView.getUint32(5);\n            if (!valid)\n                throw new Error(\"message not valid\");\n            const buffer = new Uint8Array(9 + 2 + msgLength);\n            buffer.set(first.slice(0, Math.min(first.length, buffer.length)));\n            for (let offset = first.length; offset < buffer.length;) {\n                // Drop USB \"?\" reportId in the first byte\n                let next = (yield this.delegate.readChunk(debugLink)).slice(1);\n                buffer.set(next.slice(0, Math.min(next.length, buffer.length - offset)), offset);\n                offset += next.length;\n            }\n            return buffer;\n        });\n    }\n    getVendor() {\n        return \"KeepKey\";\n    }\n    getEntropy(length) {\n        if (typeof window !== \"undefined\" && (window === null || window === void 0 ? void 0 : window.crypto)) {\n            return window.crypto.getRandomValues(new Uint8Array(length));\n        }\n        const { randomBytes } = require(\"crypto\");\n        return randomBytes(length);\n    }\n    getFirmwareHash(firmware) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof window !== \"undefined\" && (window === null || window === void 0 ? void 0 : window.crypto)) {\n                return new Uint8Array(yield window.crypto.subtle.digest({ name: \"SHA-256\" }, firmware));\n            }\n            const { createHash } = require(\"crypto\");\n            const hash = createHash(\"sha256\");\n            hash.update(firmware);\n            return hash.digest();\n        });\n    }\n    /**\n     * Utility function to cancel all pending calls whenver one of them is cancelled.\n     */\n    cancellable(inProgress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield inProgress;\n            }\n            catch (e) {\n                // Throw away the error, as the other context will handle it,\n                // unless it was a cancel, in which case we cancel everything.\n                if (e.type === core.HDWalletErrorType.ActionCancelled) {\n                    this.callInProgress = { main: undefined, debug: undefined };\n                    throw e;\n                }\n            }\n        });\n    }\n    lockDuring(action) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.callInProgress.main = (() => __awaiter(this, void 0, void 0, function* () {\n                yield this.cancellable(this.callInProgress.main);\n                return action();\n            }))();\n            return this.callInProgress.main;\n        });\n    }\n    handleCancellableResponse(messageType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const event = (yield core.takeFirstOfManyEvents(this, [String(messageType), ...responseTypeRegistry_1.EXIT_TYPES]).toPromise());\n            return this.readResponse(false);\n        });\n    }\n    readResponse(debugLink) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let buf;\n            do {\n                buf = yield this.read(debugLink);\n            } while (!buf);\n            const [msgTypeEnum, msg] = this.fromMessageBuffer(buf);\n            let event = core.makeEvent({\n                message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],\n                message_enum: msgTypeEnum,\n                message: msg.toObject(),\n                proto: msg,\n                from_wallet: true,\n            });\n            this.emit(String(msgTypeEnum), event);\n            if (debugLink)\n                return event;\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_FAILURE) {\n                const failureEvent = core.makeEvent({\n                    message_type: core.Events.FAILURE,\n                    message_enum: msgTypeEnum,\n                    message: msg.toObject(),\n                    from_wallet: true,\n                });\n                this.emit(core.Events.FAILURE, failureEvent);\n                return failureEvent;\n            }\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_BUTTONREQUEST) {\n                this.emit(core.Events.BUTTON_REQUEST, core.makeEvent({\n                    message_type: core.Events.BUTTON_REQUEST,\n                    from_wallet: true,\n                }));\n                this.userActionRequired = true;\n                return this.call(Messages.MessageType.MESSAGETYPE_BUTTONACK, new Messages.ButtonAck(), core.LONG_TIMEOUT, true, false);\n            }\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_ENTROPYREQUEST) {\n                const ack = new Messages.EntropyAck();\n                ack.setEntropy(this.getEntropy(32));\n                return this.call(Messages.MessageType.MESSAGETYPE_ENTROPYACK, ack, core.LONG_TIMEOUT, true, false);\n            }\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_PINMATRIXREQUEST) {\n                this.emit(core.Events.PIN_REQUEST, core.makeEvent({\n                    message_type: core.Events.PIN_REQUEST,\n                    from_wallet: true,\n                }));\n                this.userActionRequired = true;\n                return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_PINMATRIXACK);\n            }\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_PASSPHRASEREQUEST) {\n                this.emit(core.Events.PASSPHRASE_REQUEST, core.makeEvent({\n                    message_type: core.Events.PASSPHRASE_REQUEST,\n                    from_wallet: true,\n                }));\n                this.userActionRequired = true;\n                return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_PASSPHRASEACK);\n            }\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_CHARACTERREQUEST) {\n                this.emit(core.Events.CHARACTER_REQUEST, core.makeEvent({\n                    message_type: core.Events.CHARACTER_REQUEST,\n                    from_wallet: true,\n                }));\n                this.userActionRequired = true;\n                return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_CHARACTERACK);\n            }\n            if (msgTypeEnum === Messages.MessageType.MESSAGETYPE_WORDREQUEST) {\n                this.emit(core.Events.WORD_REQUEST, core.makeEvent({\n                    message_type: core.Events.WORD_REQUEST,\n                    from_wallet: true,\n                }));\n                this.userActionRequired = true;\n                return this.handleCancellableResponse(Messages.MessageType.MESSAGETYPE_WORDACK);\n            }\n            return event;\n        });\n    }\n    call(msgTypeEnum, msg, msgTimeout = core.DEFAULT_TIMEOUT, omitLock = false, noWait = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.emit(String(msgTypeEnum), core.makeEvent({\n                message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],\n                message_enum: msgTypeEnum,\n                message: msg.toObject(),\n                proto: msg,\n                from_wallet: false,\n            }));\n            let makePromise = () => __awaiter(this, void 0, void 0, function* () {\n                if ([\n                    Messages.MessageType.MESSAGETYPE_BUTTONACK,\n                    Messages.MessageType.MESSAGETYPE_PASSPHRASEACK,\n                    Messages.MessageType.MESSAGETYPE_CHARACTERACK,\n                    Messages.MessageType.MESSAGETYPE_PINMATRIXACK,\n                    Messages.MessageType.MESSAGETYPE_WORDACK,\n                ].includes(msgTypeEnum)) {\n                    this.userActionRequired = true;\n                }\n                yield this.write(this.toMessageBuffer(msgTypeEnum, msg), false);\n                if (!noWait) {\n                    const response = yield this.readResponse(false);\n                    this.userActionRequired = false;\n                    if (response.message_enum === Messages.MessageType.MESSAGETYPE_FAILURE &&\n                        response.message.code === Types.FailureType.FAILURE_ACTIONCANCELLED) {\n                        this.callInProgress = { main: undefined, debug: undefined };\n                        throw new core.ActionCancelled();\n                    }\n                    return response;\n                }\n            });\n            if (!omitLock) {\n                // See the comments in hdwallet-trezor-connect's call for why this weird\n                // sequence. We've got a very similar issue here that needs pretty much\n                // the same solution.\n                this.callInProgress.main = (() => __awaiter(this, void 0, void 0, function* () {\n                    yield this.cancellable(this.callInProgress.main);\n                    try {\n                        return makePromise();\n                    }\n                    finally {\n                        this.userActionRequired = false;\n                    }\n                }))();\n                return yield this.callInProgress.main;\n            }\n            else {\n                return makePromise();\n            }\n        });\n    }\n    callDebugLink(msgTypeEnum, msg, msgTimeout = core.DEFAULT_TIMEOUT, omitLock = false, noWait = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.emit(String(msgTypeEnum), core.makeEvent({\n                message_type: typeRegistry_1.messageNameRegistry[msgTypeEnum],\n                message_enum: msgTypeEnum,\n                message: msg.toObject(),\n                proto: msg,\n                from_wallet: false,\n            }));\n            let makePromise = () => __awaiter(this, void 0, void 0, function* () {\n                yield this.write(this.toMessageBuffer(msgTypeEnum, msg), true);\n                if (!noWait)\n                    return this.readResponse(true);\n            });\n            if (!omitLock) {\n                this.callInProgress.debug = (() => __awaiter(this, void 0, void 0, function* () {\n                    yield this.cancellable(this.callInProgress.debug);\n                    return makePromise();\n                }))();\n                return yield this.callInProgress.debug;\n            }\n            else {\n                return makePromise();\n            }\n        });\n    }\n    cancel() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.userActionRequired)\n                return;\n            try {\n                this.callInProgress = { main: undefined, debug: undefined };\n                const cancelMsg = new Messages.Cancel();\n                yield this.call(Messages.MessageType.MESSAGETYPE_CANCEL, cancelMsg, core.DEFAULT_TIMEOUT, false, this.userActionRequired);\n            }\n            catch (e) {\n                console.error(\"Cancel Pending Error\", e);\n            }\n            finally {\n                this.callInProgress = { main: undefined, debug: undefined };\n            }\n        });\n    }\n    toMessageBuffer(msgTypeEnum, msg) {\n        const messageBuffer = msg.serializeBinary();\n        const headerBuffer = new Uint8Array(8);\n        const headerView = new DataView(headerBuffer.buffer);\n        headerView.setUint8(0, 0x23);\n        headerView.setUint8(1, 0x23);\n        headerView.setUint16(2, msgTypeEnum);\n        headerView.setUint32(4, messageBuffer.byteLength);\n        const fragments = [headerBuffer, messageBuffer];\n        const fragmentBuffer = new Uint8Array(fragments.map((x) => x.length).reduce((a, x) => a + x, 0));\n        fragments.reduce((a, x) => (fragmentBuffer.set(x, a), a + x.length), 0);\n        return fragmentBuffer;\n    }\n    fromMessageBuffer(buf) {\n        const typeID = new DataView(buf.buffer).getUint16(3);\n        const MType = typeRegistry_1.messageTypeRegistry[typeID];\n        if (!MType) {\n            const msg = new Messages.Failure();\n            msg.setCode(Types.FailureType.FAILURE_UNEXPECTEDMESSAGE);\n            msg.setMessage(\"Unknown message type received\");\n            return [Messages.MessageType.MESSAGETYPE_FAILURE, msg];\n        }\n        const msg = new MType();\n        const reader = new jspb.BinaryReader(buf, 9, buf.length - (9 + 2));\n        return [typeID, MType.deserializeBinaryFromReader(msg, reader)];\n    }\n    static failureMessageFactory(e) {\n        const msg = new Messages.Failure();\n        msg.setCode(Types.FailureType.FAILURE_UNEXPECTEDMESSAGE);\n        if (typeof e === \"string\") {\n            msg.setMessage(e);\n        }\n        else {\n            msg.setMessage(String(e));\n        }\n        return msg.serializeBinary();\n    }\n}\nexports.Transport = Transport;\n//# sourceMappingURL=transport.js.map"]},"metadata":{},"sourceType":"script"}