{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeBc32Data = exports.encodeBc32Data = exports.encodeSegwitAddress = exports.decodeSegwitAddress = exports.Bech32Version = void 0;\n\nvar bech32_1 = __importDefault(require(\"./bech32\"));\n\nvar Bech32Version;\n\n(function (Bech32Version) {\n  Bech32Version[Bech32Version[\"Origin\"] = 1] = \"Origin\";\n  Bech32Version[Bech32Version[\"bis\"] = 2] = \"bis\";\n})(Bech32Version = exports.Bech32Version || (exports.Bech32Version = {}));\n\nvar convertBits = function (data, fromBits, toBits, pad) {\n  var acc = 0;\n  var bits = 0;\n  var ret = [];\n  var maxv = (1 << toBits) - 1;\n\n  for (var p = 0; p < data.length; ++p) {\n    var value = data[p];\n\n    if (value < 0 || value >> fromBits !== 0) {\n      return null;\n    }\n\n    acc = acc << fromBits | value;\n    bits += fromBits;\n\n    while (bits >= toBits) {\n      bits -= toBits;\n      ret.push(acc >> bits & maxv);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      ret.push(acc << toBits - bits & maxv);\n    }\n  } else if (bits >= fromBits || acc << toBits - bits & maxv) {\n    return null;\n  }\n\n  return ret;\n};\n\nvar decodeSegwitAddress = function (hrp, addr) {\n  var dec = bech32_1.default.decode(addr);\n\n  if (dec === null || dec.hrp !== hrp || dec.data.length < 1 || dec.data[0] > 16) {\n    return null;\n  }\n\n  var res = convertBits(Uint8Array.from(dec.data.slice(1)), 5, 8, false);\n\n  if (res === null || res.length < 2 || res.length > 40) {\n    return null;\n  }\n\n  if (dec.data[0] === 0 && res.length !== 20 && res.length !== 32) {\n    return null;\n  }\n\n  return {\n    version: dec.data[0],\n    program: res\n  };\n};\n\nexports.decodeSegwitAddress = decodeSegwitAddress;\n\nvar encodeSegwitAddress = function (hrp, version, program) {\n  var u82u5 = convertBits(program, 8, 5, true);\n\n  if (!u82u5) {\n    return null;\n  }\n\n  var ret = bech32_1.default.encode(hrp, [version].concat(u82u5), Bech32Version.Origin);\n\n  if (exports.decodeSegwitAddress(hrp, ret) === null) {\n    return null;\n  }\n\n  return ret;\n};\n\nexports.encodeSegwitAddress = encodeSegwitAddress;\n\nvar encodeBc32Data = function (hex) {\n  var data = Buffer.from(hex, 'hex');\n  var u82u5 = convertBits(data, 8, 5, true);\n\n  if (!u82u5) {\n    throw new Error('invalid input');\n  } else {\n    return bech32_1.default.encode(undefined, u82u5, Bech32Version.bis);\n  }\n};\n\nexports.encodeBc32Data = encodeBc32Data;\n\nvar decodeBc32Data = function (data) {\n  var result = bech32_1.default.decode(data);\n\n  if (result) {\n    var res = convertBits(Buffer.from(result.data), 5, 8, false);\n    if (res) return Buffer.from(res).toString('hex');\n    return null;\n  } else {\n    return null;\n  }\n};\n\nexports.decodeBc32Data = decodeBc32Data;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeBc32Data = exports.encodeBc32Data = exports.encodeSegwitAddress = exports.decodeSegwitAddress = exports.Bech32Version = void 0;\nvar bech32_1 = __importDefault(require(\"./bech32\"));\nvar Bech32Version;\n(function (Bech32Version) {\n    Bech32Version[Bech32Version[\"Origin\"] = 1] = \"Origin\";\n    Bech32Version[Bech32Version[\"bis\"] = 2] = \"bis\";\n})(Bech32Version = exports.Bech32Version || (exports.Bech32Version = {}));\nvar convertBits = function (data, fromBits, toBits, pad) {\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toBits) - 1;\n    for (var p = 0; p < data.length; ++p) {\n        var value = data[p];\n        if (value < 0 || value >> fromBits !== 0) {\n            return null;\n        }\n        acc = (acc << fromBits) | value;\n        bits += fromBits;\n        while (bits >= toBits) {\n            bits -= toBits;\n            ret.push((acc >> bits) & maxv);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            ret.push((acc << (toBits - bits)) & maxv);\n        }\n    }\n    else if (bits >= fromBits || (acc << (toBits - bits)) & maxv) {\n        return null;\n    }\n    return ret;\n};\nvar decodeSegwitAddress = function (hrp, addr) {\n    var dec = bech32_1.default.decode(addr);\n    if (dec === null || dec.hrp !== hrp || dec.data.length < 1 || dec.data[0] > 16) {\n        return null;\n    }\n    var res = convertBits(Uint8Array.from(dec.data.slice(1)), 5, 8, false);\n    if (res === null || res.length < 2 || res.length > 40) {\n        return null;\n    }\n    if (dec.data[0] === 0 && res.length !== 20 && res.length !== 32) {\n        return null;\n    }\n    return { version: dec.data[0], program: res };\n};\nexports.decodeSegwitAddress = decodeSegwitAddress;\nvar encodeSegwitAddress = function (hrp, version, program) {\n    var u82u5 = convertBits(program, 8, 5, true);\n    if (!u82u5) {\n        return null;\n    }\n    var ret = bech32_1.default.encode(hrp, [version].concat(u82u5), Bech32Version.Origin);\n    if (exports.decodeSegwitAddress(hrp, ret) === null) {\n        return null;\n    }\n    return ret;\n};\nexports.encodeSegwitAddress = encodeSegwitAddress;\nvar encodeBc32Data = function (hex) {\n    var data = Buffer.from(hex, 'hex');\n    var u82u5 = convertBits(data, 8, 5, true);\n    if (!u82u5) {\n        throw new Error('invalid input');\n    }\n    else {\n        return bech32_1.default.encode(undefined, u82u5, Bech32Version.bis);\n    }\n};\nexports.encodeBc32Data = encodeBc32Data;\nvar decodeBc32Data = function (data) {\n    var result = bech32_1.default.decode(data);\n    if (result) {\n        var res = convertBits(Buffer.from(result.data), 5, 8, false);\n        if (res)\n            return Buffer.from(res).toString('hex');\n        return null;\n    }\n    else {\n        return null;\n    }\n};\nexports.decodeBc32Data = decodeBc32Data;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}