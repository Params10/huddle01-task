{"ast":null,"code":"const debug = require('debug')('h264-profile-level-id');\n/* eslint-disable no-console */\n\n\ndebug.log = console.info.bind(console);\n/* eslint-enable no-console */\n\nconst ProfileConstrainedBaseline = 1;\nconst ProfileBaseline = 2;\nconst ProfileMain = 3;\nconst ProfileConstrainedHigh = 4;\nconst ProfileHigh = 5;\nexports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;\nexports.ProfileBaseline = ProfileBaseline;\nexports.ProfileMain = ProfileMain;\nexports.ProfileConstrainedHigh = ProfileConstrainedHigh;\nexports.ProfileHigh = ProfileHigh; // All values are equal to ten times the level number, except level 1b which is\n// special.\n\nconst Level1_b = 0;\nconst Level1 = 10;\nconst Level1_1 = 11;\nconst Level1_2 = 12;\nconst Level1_3 = 13;\nconst Level2 = 20;\nconst Level2_1 = 21;\nconst Level2_2 = 22;\nconst Level3 = 30;\nconst Level3_1 = 31;\nconst Level3_2 = 32;\nconst Level4 = 40;\nconst Level4_1 = 41;\nconst Level4_2 = 42;\nconst Level5 = 50;\nconst Level5_1 = 51;\nconst Level5_2 = 52;\nexports.Level1_b = Level1_b;\nexports.Level1 = Level1;\nexports.Level1_1 = Level1_1;\nexports.Level1_2 = Level1_2;\nexports.Level1_3 = Level1_3;\nexports.Level2 = Level2;\nexports.Level2_1 = Level2_1;\nexports.Level2_2 = Level2_2;\nexports.Level3 = Level3;\nexports.Level3_1 = Level3_1;\nexports.Level3_2 = Level3_2;\nexports.Level4 = Level4;\nexports.Level4_1 = Level4_1;\nexports.Level4_2 = Level4_2;\nexports.Level5 = Level5;\nexports.Level5_1 = Level5_1;\nexports.Level5_2 = Level5_2;\n\nclass ProfileLevelId {\n  constructor(profile, level) {\n    this.profile = profile;\n    this.level = level;\n  }\n\n}\n\nexports.ProfileLevelId = ProfileLevelId; // Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\n\nconst DefaultProfileLevelId = new ProfileLevelId(ProfileConstrainedBaseline, Level3_1); // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n// flag specifies if level 1b or level 1.1 is used.\n\nconst ConstraintSet3Flag = 0x10; // Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to be\n// either 0 or 1.\n\nclass BitPattern {\n  constructor(str) {\n    this._mask = ~byteMaskString('x', str);\n    this._maskedValue = byteMaskString('1', str);\n  }\n\n  isMatch(value) {\n    return this._maskedValue === (value & this._mask);\n  }\n\n} // Class for converting between profile_idc/profile_iop to Profile.\n\n\nclass ProfilePattern {\n  constructor(profile_idc, profile_iop, profile) {\n    this.profile_idc = profile_idc;\n    this.profile_iop = profile_iop;\n    this.profile = profile;\n  }\n\n} // This is from https://tools.ietf.org/html/rfc6184#section-8.1.\n\n\nconst ProfilePatterns = [new ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline), new ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline), new ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline), new ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain), new ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh), new ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)];\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n *\n * @param {String} str - profile-level-id value as a string of 3 hex bytes.\n *\n * @returns {ProfileLevelId}\n */\n\nexports.parseProfileLevelId = function (str) {\n  // The string should consist of 3 bytes in hexadecimal format.\n  if (typeof str !== 'string' || str.length !== 6) return null;\n  const profile_level_id_numeric = parseInt(str, 16);\n  if (profile_level_id_numeric === 0) return null; // Separate into three bytes.\n\n  const level_idc = profile_level_id_numeric & 0xFF;\n  const profile_iop = profile_level_id_numeric >> 8 & 0xFF;\n  const profile_idc = profile_level_id_numeric >> 16 & 0xFF; // Parse level based on level_idc and constraint set 3 flag.\n\n  let level;\n\n  switch (level_idc) {\n    case Level1_1:\n      {\n        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;\n        break;\n      }\n\n    case Level1:\n    case Level1_2:\n    case Level1_3:\n    case Level2:\n    case Level2_1:\n    case Level2_2:\n    case Level3:\n    case Level3_1:\n    case Level3_2:\n    case Level4:\n    case Level4_1:\n    case Level4_2:\n    case Level5:\n    case Level5_1:\n    case Level5_2:\n      {\n        level = level_idc;\n        break;\n      }\n    // Unrecognized level_idc.\n\n    default:\n      {\n        debug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);\n        return null;\n      }\n  } // Parse profile_idc/profile_iop into a Profile enum.\n\n\n  for (const pattern of ProfilePatterns) {\n    if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {\n      return new ProfileLevelId(pattern.profile, level);\n    }\n  }\n\n  debug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');\n  return null;\n};\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n *\n * @param {ProfileLevelId} profile_level_id\n *\n * @returns {String}\n */\n\n\nexports.profileLevelIdToString = function (profile_level_id) {\n  // Handle special case level == 1b.\n  if (profile_level_id.level == Level1_b) {\n    switch (profile_level_id.profile) {\n      case ProfileConstrainedBaseline:\n        {\n          return '42f00b';\n        }\n\n      case ProfileBaseline:\n        {\n          return '42100b';\n        }\n\n      case ProfileMain:\n        {\n          return '4d100b';\n        }\n      // Level 1_b is not allowed for other profiles.\n\n      default:\n        {\n          debug('profileLevelIdToString() | Level 1_b not is allowed for profile:%s', profile_level_id.profile);\n          return null;\n        }\n    }\n  }\n\n  let profile_idc_iop_string;\n\n  switch (profile_level_id.profile) {\n    case ProfileConstrainedBaseline:\n      {\n        profile_idc_iop_string = '42e0';\n        break;\n      }\n\n    case ProfileBaseline:\n      {\n        profile_idc_iop_string = '4200';\n        break;\n      }\n\n    case ProfileMain:\n      {\n        profile_idc_iop_string = '4d00';\n        break;\n      }\n\n    case ProfileConstrainedHigh:\n      {\n        profile_idc_iop_string = '640c';\n        break;\n      }\n\n    case ProfileHigh:\n      {\n        profile_idc_iop_string = '6400';\n        break;\n      }\n\n    default:\n      {\n        debug('profileLevelIdToString() | unrecognized profile:%s', profile_level_id.profile);\n        return null;\n      }\n  }\n\n  let levelStr = profile_level_id.level.toString(16);\n  if (levelStr.length === 1) levelStr = `0${levelStr}`;\n  return `${profile_idc_iop_string}${levelStr}`;\n};\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned if\n * the key is present but the string is invalid.\n *\n * @param {Object} [params={}] - Codec parameters object.\n *\n * @returns {ProfileLevelId}\n */\n\n\nexports.parseSdpProfileLevelId = function (params = {}) {\n  const profile_level_id = params['profile-level-id'];\n  return !profile_level_id ? DefaultProfileLevelId : exports.parseProfileLevelId(profile_level_id);\n};\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n *\n * @param {Object} [params1={}] - Codec parameters object.\n * @param {Object} [params2={}] - Codec parameters object.\n *\n * @returns {Boolean}\n */\n\n\nexports.isSameProfile = function (params1 = {}, params2 = {}) {\n  const profile_level_id_1 = exports.parseSdpProfileLevelId(params1);\n  const profile_level_id_2 = exports.parseSdpProfileLevelId(params2); // Compare H264 profiles, but not levels.\n\n  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);\n};\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict superset\n * of the profile in remote_offered_params, we could limit the profile in the\n * answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and level-asymmetry-allowed.\n *\n * @param {Object} [local_supported_params={}]\n * @param {Object} [remote_offered_params={}]\n *\n * @returns {String} Canonical string representation as three hex bytes of the\n *   profile level id, or null if no one of the params have profile-level-id.\n *\n * @throws {TypeError} If Profile mismatch or invalid params.\n */\n\n\nexports.generateProfileLevelIdForAnswer = function (local_supported_params = {}, remote_offered_params = {}) {\n  // If both local and remote params do not contain profile-level-id, they are\n  // both using the default profile. In this case, don't return anything.\n  if (!local_supported_params['profile-level-id'] && !remote_offered_params['profile-level-id']) {\n    debug('generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');\n    return null;\n  } // Parse profile-level-ids.\n\n\n  const local_profile_level_id = exports.parseSdpProfileLevelId(local_supported_params);\n  const remote_profile_level_id = exports.parseSdpProfileLevelId(remote_offered_params); // The local and remote codec must have valid and equal H264 Profiles.\n\n  if (!local_profile_level_id) throw new TypeError('invalid local_profile_level_id');\n  if (!remote_profile_level_id) throw new TypeError('invalid remote_profile_level_id');\n  if (local_profile_level_id.profile !== remote_profile_level_id.profile) throw new TypeError('H264 Profile mismatch'); // Parse level information.\n\n  const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);\n  const local_level = local_profile_level_id.level;\n  const remote_level = remote_profile_level_id.level;\n  const min_level = minLevel(local_level, remote_level); // Determine answer level. When level asymmetry is not allowed, level upgrade\n  // is not allowed, i.e., the level in the answer must be equal to or lower\n  // than the level in the offer.\n\n  const answer_level = level_asymmetry_allowed ? local_level : min_level;\n  debug('generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]', local_profile_level_id.profile, answer_level); // Return the resulting profile-level-id for the answer parameters.\n\n  return exports.profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));\n}; // Convert a string of 8 characters into a byte where the positions containing\n// character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n// will return 0b10110000.\n\n\nfunction byteMaskString(c, str) {\n  return (str[0] === c) << 7 | (str[1] === c) << 6 | (str[2] === c) << 5 | (str[3] === c) << 4 | (str[4] === c) << 3 | (str[5] === c) << 2 | (str[6] === c) << 1 | (str[7] === c) << 0;\n} // Compare H264 levels and handle the level 1b case.\n\n\nfunction isLessLevel(a, b) {\n  if (a === Level1_b) return b !== Level1 && b !== Level1_b;\n  if (b === Level1_b) return a !== Level1;\n  return a < b;\n}\n\nfunction minLevel(a, b) {\n  return isLessLevel(a, b) ? a : b;\n}\n\nfunction isLevelAsymmetryAllowed(params = {}) {\n  const level_asymmetry_allowed = params['level-asymmetry-allowed'];\n  return level_asymmetry_allowed === 1 || level_asymmetry_allowed === '1';\n}","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/h264-profile-level-id/index.js"],"names":["debug","require","log","console","info","bind","ProfileConstrainedBaseline","ProfileBaseline","ProfileMain","ProfileConstrainedHigh","ProfileHigh","exports","Level1_b","Level1","Level1_1","Level1_2","Level1_3","Level2","Level2_1","Level2_2","Level3","Level3_1","Level3_2","Level4","Level4_1","Level4_2","Level5","Level5_1","Level5_2","ProfileLevelId","constructor","profile","level","DefaultProfileLevelId","ConstraintSet3Flag","BitPattern","str","_mask","byteMaskString","_maskedValue","isMatch","value","ProfilePattern","profile_idc","profile_iop","ProfilePatterns","parseProfileLevelId","length","profile_level_id_numeric","parseInt","level_idc","pattern","profileLevelIdToString","profile_level_id","profile_idc_iop_string","levelStr","toString","parseSdpProfileLevelId","params","isSameProfile","params1","params2","profile_level_id_1","profile_level_id_2","Boolean","generateProfileLevelIdForAnswer","local_supported_params","remote_offered_params","local_profile_level_id","remote_profile_level_id","TypeError","level_asymmetry_allowed","isLevelAsymmetryAllowed","local_level","remote_level","min_level","minLevel","answer_level","c","isLessLevel","a","b"],"mappings":"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","sourcesContent":["const debug = require('debug')('h264-profile-level-id');\n\n/* eslint-disable no-console */\ndebug.log = console.info.bind(console);\n/* eslint-enable no-console */\n\nconst ProfileConstrainedBaseline = 1;\nconst ProfileBaseline = 2;\nconst ProfileMain = 3;\nconst ProfileConstrainedHigh = 4;\nconst ProfileHigh = 5;\n\nexports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;\nexports.ProfileBaseline = ProfileBaseline;\nexports.ProfileMain = ProfileMain;\nexports.ProfileConstrainedHigh = ProfileConstrainedHigh;\nexports.ProfileHigh = ProfileHigh;\n\n// All values are equal to ten times the level number, except level 1b which is\n// special.\nconst Level1_b = 0;\nconst Level1 = 10;\nconst Level1_1 = 11;\nconst Level1_2 = 12;\nconst Level1_3 = 13;\nconst Level2 = 20;\nconst Level2_1 = 21;\nconst Level2_2 = 22;\nconst Level3 = 30;\nconst Level3_1 = 31;\nconst Level3_2 = 32;\nconst Level4 = 40;\nconst Level4_1 = 41;\nconst Level4_2 = 42;\nconst Level5 = 50;\nconst Level5_1 = 51;\nconst Level5_2 = 52;\n\nexports.Level1_b = Level1_b;\nexports.Level1 = Level1;\nexports.Level1_1 = Level1_1;\nexports.Level1_2 = Level1_2;\nexports.Level1_3 = Level1_3;\nexports.Level2 = Level2;\nexports.Level2_1 = Level2_1;\nexports.Level2_2 = Level2_2;\nexports.Level3 = Level3;\nexports.Level3_1 = Level3_1;\nexports.Level3_2 = Level3_2;\nexports.Level4 = Level4;\nexports.Level4_1 = Level4_1;\nexports.Level4_2 = Level4_2;\nexports.Level5 = Level5;\nexports.Level5_1 = Level5_1;\nexports.Level5_2 = Level5_2;\n\nclass ProfileLevelId\n{\n\tconstructor(profile, level)\n\t{\n\t\tthis.profile = profile;\n\t\tthis.level = level;\n\t}\n}\n\nexports.ProfileLevelId = ProfileLevelId;\n\n// Default ProfileLevelId.\n//\n// TODO: The default should really be profile Baseline and level 1 according to\n// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not\n// break backwards compatibility with older versions of WebRTC where external\n// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1\n// instead. This workaround will only be done in an interim period to allow\n// external clients to update their code.\n//\n// http://crbug/webrtc/6337.\nconst DefaultProfileLevelId =\n\tnew ProfileLevelId(ProfileConstrainedBaseline, Level3_1);\n\n// For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3\n// flag specifies if level 1b or level 1.1 is used.\nconst ConstraintSet3Flag = 0x10;\n\n// Class for matching bit patterns such as \"x1xx0000\" where 'x' is allowed to be\n// either 0 or 1.\nclass BitPattern\n{\n\tconstructor(str)\n\t{\n\t\tthis._mask = ~byteMaskString('x', str);\n\t\tthis._maskedValue = byteMaskString('1', str);\n\t}\n\n\tisMatch(value)\n\t{\n\t\treturn this._maskedValue === (value & this._mask);\n\t}\n}\n\n// Class for converting between profile_idc/profile_iop to Profile.\nclass ProfilePattern\n{\n\tconstructor(profile_idc, profile_iop, profile)\n\t{\n\t\tthis.profile_idc = profile_idc;\n\t\tthis.profile_iop = profile_iop;\n\t\tthis.profile = profile;\n\t}\n}\n\n// This is from https://tools.ietf.org/html/rfc6184#section-8.1.\nconst ProfilePatterns =\n[\n\tnew ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline),\n\tnew ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline),\n\tnew ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain),\n\tnew ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh),\n\tnew ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)\n];\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes.\n * Nothing will be returned if the string is not a recognized H264 profile\n * level id.\n *\n * @param {String} str - profile-level-id value as a string of 3 hex bytes.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseProfileLevelId = function(str)\n{\n\t// The string should consist of 3 bytes in hexadecimal format.\n\tif (typeof str !== 'string' || str.length !== 6)\n\t\treturn null;\n\n\tconst profile_level_id_numeric = parseInt(str, 16);\n\n\tif (profile_level_id_numeric === 0)\n\t\treturn null;\n\n\t// Separate into three bytes.\n\tconst level_idc = profile_level_id_numeric & 0xFF;\n\tconst profile_iop = (profile_level_id_numeric >> 8) & 0xFF;\n\tconst profile_idc = (profile_level_id_numeric >> 16) & 0xFF;\n\n\t// Parse level based on level_idc and constraint set 3 flag.\n\tlet level;\n\n\tswitch (level_idc)\n\t{\n\t\tcase Level1_1:\n\t\t{\n\t\t\tlevel = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;\n\t\t\tbreak;\n\t\t}\n\t\tcase Level1:\n\t\tcase Level1_2:\n\t\tcase Level1_3:\n\t\tcase Level2:\n\t\tcase Level2_1:\n\t\tcase Level2_2:\n\t\tcase Level3:\n\t\tcase Level3_1:\n\t\tcase Level3_2:\n\t\tcase Level4:\n\t\tcase Level4_1:\n\t\tcase Level4_2:\n\t\tcase Level5:\n\t\tcase Level5_1:\n\t\tcase Level5_2:\n\t\t{\n\t\t\tlevel = level_idc;\n\t\t\tbreak;\n\t\t}\n\t\t// Unrecognized level_idc.\n\t\tdefault:\n\t\t{\n\t\t\tdebug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// Parse profile_idc/profile_iop into a Profile enum.\n\tfor (const pattern of ProfilePatterns)\n\t{\n\t\tif (\n\t\t\tprofile_idc === pattern.profile_idc &&\n\t\t\tpattern.profile_iop.isMatch(profile_iop)\n\t\t)\n\t\t{\n\t\t\treturn new ProfileLevelId(pattern.profile, level);\n\t\t}\n\t}\n\n\tdebug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');\n\n\treturn null;\n};\n\n/**\n * Returns canonical string representation as three hex bytes of the profile\n * level id, or returns nothing for invalid profile level ids.\n *\n * @param {ProfileLevelId} profile_level_id\n *\n * @returns {String}\n */\nexports.profileLevelIdToString = function(profile_level_id)\n{\n\t// Handle special case level == 1b.\n\tif (profile_level_id.level == Level1_b)\n\t{\n\t\tswitch (profile_level_id.profile)\n\t\t{\n\t\t\tcase ProfileConstrainedBaseline:\n\t\t\t{\n\t\t\t\treturn '42f00b';\n\t\t\t}\n\t\t\tcase ProfileBaseline:\n\t\t\t{\n\t\t\t\treturn '42100b';\n\t\t\t}\n\t\t\tcase ProfileMain:\n\t\t\t{\n\t\t\t\treturn '4d100b';\n\t\t\t}\n\t\t\t// Level 1_b is not allowed for other profiles.\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tdebug(\n\t\t\t\t\t'profileLevelIdToString() | Level 1_b not is allowed for profile:%s',\n\t\t\t\t\tprofile_level_id.profile);\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tlet profile_idc_iop_string;\n\n\tswitch (profile_level_id.profile)\n\t{\n\t\tcase ProfileConstrainedBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '42e0';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileBaseline:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4200';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileMain:\n\t\t{\n\t\t\tprofile_idc_iop_string = '4d00';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileConstrainedHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '640c';\n\t\t\tbreak;\n\t\t}\n\t\tcase ProfileHigh:\n\t\t{\n\t\t\tprofile_idc_iop_string = '6400';\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tdebug(\n\t\t\t\t'profileLevelIdToString() | unrecognized profile:%s',\n\t\t\t\tprofile_level_id.profile);\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tlet levelStr = (profile_level_id.level).toString(16);\n\n\tif (levelStr.length === 1)\n\t\tlevelStr = `0${levelStr}`;\n\n\treturn `${profile_idc_iop_string}${levelStr}`;\n};\n\n/**\n * Parse profile level id that is represented as a string of 3 hex bytes\n * contained in an SDP key-value map. A default profile level id will be\n * returned if the profile-level-id key is missing. Nothing will be returned if\n * the key is present but the string is invalid.\n *\n * @param {Object} [params={}] - Codec parameters object.\n *\n * @returns {ProfileLevelId}\n */\nexports.parseSdpProfileLevelId = function(params = {})\n{\n\tconst profile_level_id = params['profile-level-id'];\n\n\treturn !profile_level_id\n\t\t? DefaultProfileLevelId\n\t\t: exports.parseProfileLevelId(profile_level_id);\n};\n\n/**\n * Returns true if the parameters have the same H264 profile, i.e. the same\n * H264 profile (Baseline, High, etc).\n *\n * @param {Object} [params1={}] - Codec parameters object.\n * @param {Object} [params2={}] - Codec parameters object.\n *\n * @returns {Boolean}\n */\nexports.isSameProfile = function(params1 = {}, params2 = {})\n{\n\tconst profile_level_id_1 = exports.parseSdpProfileLevelId(params1);\n\tconst profile_level_id_2 = exports.parseSdpProfileLevelId(params2);\n\n\t// Compare H264 profiles, but not levels.\n\treturn Boolean(\n\t\tprofile_level_id_1 &&\n\t\tprofile_level_id_2 &&\n\t\tprofile_level_id_1.profile === profile_level_id_2.profile\n\t);\n};\n\n/**\n * Generate codec parameters that will be used as answer in an SDP negotiation\n * based on local supported parameters and remote offered parameters. Both\n * local_supported_params and remote_offered_params represent sendrecv media\n * descriptions, i.e they are a mix of both encode and decode capabilities. In\n * theory, when the profile in local_supported_params represent a strict superset\n * of the profile in remote_offered_params, we could limit the profile in the\n * answer to the profile in remote_offered_params.\n *\n * However, to simplify the code, each supported H264 profile should be listed\n * explicitly in the list of local supported codecs, even if they are redundant.\n * Then each local codec in the list should be tested one at a time against the\n * remote codec, and only when the profiles are equal should this function be\n * called. Therefore, this function does not need to handle profile intersection,\n * and the profile of local_supported_params and remote_offered_params must be\n * equal before calling this function. The parameters that are used when\n * negotiating are the level part of profile-level-id and level-asymmetry-allowed.\n *\n * @param {Object} [local_supported_params={}]\n * @param {Object} [remote_offered_params={}]\n *\n * @returns {String} Canonical string representation as three hex bytes of the\n *   profile level id, or null if no one of the params have profile-level-id.\n *\n * @throws {TypeError} If Profile mismatch or invalid params.\n */\nexports.generateProfileLevelIdForAnswer = function(\n\tlocal_supported_params = {},\n\tremote_offered_params = {}\n)\n{\n\t// If both local and remote params do not contain profile-level-id, they are\n\t// both using the default profile. In this case, don't return anything.\n\tif (\n\t\t!local_supported_params['profile-level-id'] &&\n\t\t!remote_offered_params['profile-level-id']\n\t)\n\t{\n\t\tdebug(\n\t\t\t'generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');\n\n\t\treturn null;\n\t}\n\n\t// Parse profile-level-ids.\n\tconst local_profile_level_id =\n\t\texports.parseSdpProfileLevelId(local_supported_params);\n\tconst remote_profile_level_id =\n\t\texports.parseSdpProfileLevelId(remote_offered_params);\n\n\t// The local and remote codec must have valid and equal H264 Profiles.\n\tif (!local_profile_level_id)\n\t\tthrow new TypeError('invalid local_profile_level_id');\n\n\tif (!remote_profile_level_id)\n\t\tthrow new TypeError('invalid remote_profile_level_id');\n\n\tif (local_profile_level_id.profile !== remote_profile_level_id.profile)\n\t\tthrow new TypeError('H264 Profile mismatch');\n\n\t// Parse level information.\n\tconst level_asymmetry_allowed = (\n\t\tisLevelAsymmetryAllowed(local_supported_params) &&\n\t\tisLevelAsymmetryAllowed(remote_offered_params)\n\t);\n\n\tconst local_level = local_profile_level_id.level;\n\tconst remote_level = remote_profile_level_id.level;\n\tconst min_level = minLevel(local_level, remote_level);\n\n\t// Determine answer level. When level asymmetry is not allowed, level upgrade\n\t// is not allowed, i.e., the level in the answer must be equal to or lower\n\t// than the level in the offer.\n\tconst answer_level = level_asymmetry_allowed ? local_level : min_level;\n\n\tdebug(\n\t\t'generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]',\n\t\tlocal_profile_level_id.profile, answer_level);\n\n\t// Return the resulting profile-level-id for the answer parameters.\n\treturn exports.profileLevelIdToString(\n\t\tnew ProfileLevelId(local_profile_level_id.profile, answer_level));\n};\n\n// Convert a string of 8 characters into a byte where the positions containing\n// character c will have their bit set. For example, c = 'x', str = \"x1xx0000\"\n// will return 0b10110000.\nfunction byteMaskString(c, str)\n{\n\treturn (\n\t\t((str[0] === c) << 7) | ((str[1] === c) << 6) | ((str[2] === c) << 5) |\n\t\t((str[3] === c) << 4)\t| ((str[4] === c) << 3)\t| ((str[5] === c) << 2)\t|\n\t\t((str[6] === c) << 1)\t| ((str[7] === c) << 0)\n\t);\n}\n\n// Compare H264 levels and handle the level 1b case.\nfunction isLessLevel(a, b)\n{\n\tif (a === Level1_b)\n\t\treturn b !== Level1 && b !== Level1_b;\n\n\tif (b === Level1_b)\n\t\treturn a !== Level1;\n\n\treturn a < b;\n}\n\nfunction minLevel(a, b)\n{\n\treturn isLessLevel(a, b) ? a : b;\n}\n\nfunction isLevelAsymmetryAllowed(params = {})\n{\n\tconst level_asymmetry_allowed = params['level-asymmetry-allowed'];\n\n\treturn (\n\t\tlevel_asymmetry_allowed === 1 ||\n\t\tlevel_asymmetry_allowed === '1'\n\t);\n}\n"]},"metadata":{},"sourceType":"script"}