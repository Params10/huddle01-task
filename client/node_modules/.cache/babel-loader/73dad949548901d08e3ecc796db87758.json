{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst fountainUtils_1 = require(\"./fountainUtils\");\n\nconst cbor_1 = require(\"./cbor\");\n\nclass FountainEncoderPart {\n  constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  get fragment() {\n    return this._fragment;\n  }\n\n  get seqNum() {\n    return this._seqNum;\n  }\n\n  get seqLength() {\n    return this._seqLength;\n  }\n\n  get checksum() {\n    return this._checksum;\n  }\n\n  cbor() {\n    const result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n    return Buffer.from(result);\n  }\n\n  description() {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n  }\n\n  static fromCBOR(cborPayload) {\n    const [seqNum, seqLength, messageLength, checksum, fragment] = cbor_1.cborDecode(cborPayload);\n    assert_1.default(typeof seqNum === 'number');\n    assert_1.default(typeof seqLength === 'number');\n    assert_1.default(typeof messageLength === 'number');\n    assert_1.default(typeof checksum === 'number');\n    assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n    return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n  }\n\n}\n\nexports.FountainEncoderPart = FountainEncoderPart;\n\nclass FountainEncoder {\n  constructor(message, maxFragmentLength = 100, firstSeqNum = 0, minFragmentLength = 10) {\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n\n  get fragmentsLength() {\n    return this._fragments.length;\n  }\n\n  get fragments() {\n    return this._fragments;\n  }\n\n  get messageLength() {\n    return this._messageLength;\n  }\n\n  isComplete() {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  isSinglePart() {\n    return this._fragments.length === 1;\n  }\n\n  seqLength() {\n    return this._fragments.length;\n  }\n\n  mix(indexes) {\n    return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n  }\n\n  nextPart() {\n    this.seqNum = utils_1.toUint32(this.seqNum + 1);\n    const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n    return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n  }\n\n  static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n    assert_1.default(messageLength > 0);\n    assert_1.default(minFragmentLength > 0);\n    assert_1.default(maxFragmentLength >= minFragmentLength);\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  static partitionMessage(message, fragmentLength) {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n      fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n      .fill(fragment, 0, fragment.length);\n\n      _fragments.push(fragment);\n    }\n\n    return _fragments;\n  }\n\n}\n\nexports.default = FountainEncoder;","map":{"version":3,"sources":["../src/fountainEncoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FountainEncoderPart = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst cbor_1 = require(\"./cbor\");\nclass FountainEncoderPart {\n    constructor(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n        this._seqNum = _seqNum;\n        this._seqLength = _seqLength;\n        this._messageLength = _messageLength;\n        this._checksum = _checksum;\n        this._fragment = _fragment;\n    }\n    get messageLength() { return this._messageLength; }\n    get fragment() { return this._fragment; }\n    get seqNum() { return this._seqNum; }\n    get seqLength() { return this._seqLength; }\n    get checksum() { return this._checksum; }\n    cbor() {\n        const result = cbor_1.cborEncode([\n            this._seqNum,\n            this._seqLength,\n            this._messageLength,\n            this._checksum,\n            this._fragment\n        ]);\n        return Buffer.from(result);\n    }\n    description() {\n        return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`;\n    }\n    static fromCBOR(cborPayload) {\n        const [seqNum, seqLength, messageLength, checksum, fragment,] = cbor_1.cborDecode(cborPayload);\n        assert_1.default(typeof seqNum === 'number');\n        assert_1.default(typeof seqLength === 'number');\n        assert_1.default(typeof messageLength === 'number');\n        assert_1.default(typeof checksum === 'number');\n        assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n        return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n    }\n}\nexports.FountainEncoderPart = FountainEncoderPart;\nclass FountainEncoder {\n    constructor(message, maxFragmentLength = 100, firstSeqNum = 0, minFragmentLength = 10) {\n        const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n        this._messageLength = message.length;\n        this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n        this.fragmentLength = fragmentLength;\n        this.seqNum = utils_1.toUint32(firstSeqNum);\n        this.checksum = utils_1.getCRC(message);\n    }\n    get fragmentsLength() { return this._fragments.length; }\n    get fragments() { return this._fragments; }\n    get messageLength() { return this._messageLength; }\n    isComplete() {\n        return this.seqNum >= this._fragments.length;\n    }\n    isSinglePart() {\n        return this._fragments.length === 1;\n    }\n    seqLength() {\n        return this._fragments.length;\n    }\n    mix(indexes) {\n        return indexes.reduce((result, index) => utils_1.bufferXOR(this._fragments[index], result), Buffer.alloc(this.fragmentLength, 0));\n    }\n    nextPart() {\n        this.seqNum = utils_1.toUint32(this.seqNum + 1);\n        const indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n        const mixed = this.mix(indexes);\n        return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n    }\n    static findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n        assert_1.default(messageLength > 0);\n        assert_1.default(minFragmentLength > 0);\n        assert_1.default(maxFragmentLength >= minFragmentLength);\n        const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n        let fragmentLength = 0;\n        for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n            fragmentLength = Math.ceil(messageLength / fragmentCount);\n            if (fragmentLength <= maxFragmentLength) {\n                break;\n            }\n        }\n        return fragmentLength;\n    }\n    static partitionMessage(message, fragmentLength) {\n        let remaining = Buffer.from(message);\n        let fragment;\n        let _fragments = [];\n        while (remaining.length > 0) {\n            [fragment, remaining] = utils_1.split(remaining, -fragmentLength);\n            fragment = Buffer\n                .alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n                .fill(fragment, 0, fragment.length);\n            _fragments.push(fragment);\n        }\n        return _fragments;\n    }\n}\nexports.default = FountainEncoder;\n//# sourceMappingURL=fountainEncoder.js.map"]},"metadata":{},"sourceType":"script"}