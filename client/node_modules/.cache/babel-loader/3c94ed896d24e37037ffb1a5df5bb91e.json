{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cosmosGetAddress = exports.cosmosSignTx = exports.cosmosGetAccountPaths = void 0;\n\nconst CosmosMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-cosmos_pb\"));\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nfunction cosmosGetAccountPaths(msg) {\n  return [{\n    addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Atom\"), 0x80000000 + msg.accountIdx, 0, 0]\n  }];\n}\n\nexports.cosmosGetAccountPaths = cosmosGetAccountPaths;\n\nfunction cosmosSignTx(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n      const signTx = new CosmosMessages.CosmosSignTx();\n      signTx.setAddressNList(msg.addressNList);\n      signTx.setAccountNumber(msg.account_number);\n      signTx.setChainId(msg.chain_id);\n      signTx.setFeeAmount(parseInt(msg.tx.fee.amount[0].amount));\n      signTx.setGas(parseInt(msg.tx.fee.gas));\n      signTx.setSequence(msg.sequence);\n      if (msg.tx.memo !== undefined) signTx.setMemo(msg.tx.memo);\n      signTx.setMsgCount(1);\n      let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_COSMOSSIGNTX, signTx, core.LONG_TIMEOUT,\n      /*omitLock=*/\n      true);\n      if (resp.message_type === core.Events.FAILURE) throw resp;\n\n      for (let m of msg.tx.msg) {\n        if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_COSMOSMSGREQUEST) {\n          throw new Error(`cosmos: unexpected response ${resp.message_type}`);\n        }\n\n        let ack;\n\n        if (m.type === \"cosmos-sdk/MsgSend\") {\n          if (m.value.amount.length !== 1) {\n            throw new Error(\"cosmos: Multiple amounts per msg not supported\");\n          }\n\n          const denom = m.value.amount[0].denom;\n\n          if (denom !== \"uatom\") {\n            throw new Error(\"cosmos: Unsupported denomination: \" + denom);\n          }\n\n          const send = new CosmosMessages.CosmosMsgSend();\n          send.setFromAddress(m.value.from_address);\n          send.setToAddress(m.value.to_address);\n          send.setAmount(m.value.amount[0].amount);\n          ack = new CosmosMessages.CosmosMsgAck();\n          ack.setSend(send);\n        } else {\n          throw new Error(`cosmos: Message ${m.type} is not yet supported`);\n        }\n\n        resp = yield transport.call(Messages.MessageType.MESSAGETYPE_COSMOSMSGACK, ack, core.LONG_TIMEOUT,\n        /*omitLock=*/\n        true);\n        if (resp.message_type === core.Events.FAILURE) throw resp;\n      }\n\n      if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_COSMOSSIGNEDTX) {\n        throw new Error(`cosmos: unexpected response ${resp.message_type}`);\n      }\n\n      const signedTx = resp.proto;\n      const signed = lodash_1.default.cloneDeep(msg.tx);\n      signed.signatures = [{\n        pub_key: {\n          type: \"tendermint/PubKeySecp256k1\",\n          value: signedTx.getPublicKey_asB64()\n        },\n        signature: signedTx.getSignature_asB64()\n      }];\n      return signed;\n    }));\n  });\n}\n\nexports.cosmosSignTx = cosmosSignTx;\n\nfunction cosmosGetAddress(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const getAddr = new CosmosMessages.CosmosGetAddress();\n    getAddr.setAddressNList(msg.addressNList);\n    getAddr.setShowDisplay(msg.showDisplay !== false);\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_COSMOSGETADDRESS, getAddr, core.LONG_TIMEOUT);\n    if (response.message_type === core.Events.FAILURE) throw response;\n    const cosmosAddress = response.proto;\n    return core.mustBeDefined(cosmosAddress.getAddress());\n  });\n}\n\nexports.cosmosGetAddress = cosmosGetAddress;","map":{"version":3,"sources":["../src/cosmos.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cosmosGetAddress = exports.cosmosSignTx = exports.cosmosGetAccountPaths = void 0;\nconst CosmosMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-cosmos_pb\"));\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nfunction cosmosGetAccountPaths(msg) {\n    return [\n        {\n            addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Atom\"), 0x80000000 + msg.accountIdx, 0, 0],\n        },\n    ];\n}\nexports.cosmosGetAccountPaths = cosmosGetAccountPaths;\nfunction cosmosSignTx(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n            const signTx = new CosmosMessages.CosmosSignTx();\n            signTx.setAddressNList(msg.addressNList);\n            signTx.setAccountNumber(msg.account_number);\n            signTx.setChainId(msg.chain_id);\n            signTx.setFeeAmount(parseInt(msg.tx.fee.amount[0].amount));\n            signTx.setGas(parseInt(msg.tx.fee.gas));\n            signTx.setSequence(msg.sequence);\n            if (msg.tx.memo !== undefined)\n                signTx.setMemo(msg.tx.memo);\n            signTx.setMsgCount(1);\n            let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_COSMOSSIGNTX, signTx, core.LONG_TIMEOUT, \n            /*omitLock=*/ true);\n            if (resp.message_type === core.Events.FAILURE)\n                throw resp;\n            for (let m of msg.tx.msg) {\n                if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_COSMOSMSGREQUEST) {\n                    throw new Error(`cosmos: unexpected response ${resp.message_type}`);\n                }\n                let ack;\n                if (m.type === \"cosmos-sdk/MsgSend\") {\n                    if (m.value.amount.length !== 1) {\n                        throw new Error(\"cosmos: Multiple amounts per msg not supported\");\n                    }\n                    const denom = m.value.amount[0].denom;\n                    if (denom !== \"uatom\") {\n                        throw new Error(\"cosmos: Unsupported denomination: \" + denom);\n                    }\n                    const send = new CosmosMessages.CosmosMsgSend();\n                    send.setFromAddress(m.value.from_address);\n                    send.setToAddress(m.value.to_address);\n                    send.setAmount(m.value.amount[0].amount);\n                    ack = new CosmosMessages.CosmosMsgAck();\n                    ack.setSend(send);\n                }\n                else {\n                    throw new Error(`cosmos: Message ${m.type} is not yet supported`);\n                }\n                resp = yield transport.call(Messages.MessageType.MESSAGETYPE_COSMOSMSGACK, ack, core.LONG_TIMEOUT, /*omitLock=*/ true);\n                if (resp.message_type === core.Events.FAILURE)\n                    throw resp;\n            }\n            if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_COSMOSSIGNEDTX) {\n                throw new Error(`cosmos: unexpected response ${resp.message_type}`);\n            }\n            const signedTx = resp.proto;\n            const signed = lodash_1.default.cloneDeep(msg.tx);\n            signed.signatures = [\n                {\n                    pub_key: {\n                        type: \"tendermint/PubKeySecp256k1\",\n                        value: signedTx.getPublicKey_asB64(),\n                    },\n                    signature: signedTx.getSignature_asB64(),\n                },\n            ];\n            return signed;\n        }));\n    });\n}\nexports.cosmosSignTx = cosmosSignTx;\nfunction cosmosGetAddress(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const getAddr = new CosmosMessages.CosmosGetAddress();\n        getAddr.setAddressNList(msg.addressNList);\n        getAddr.setShowDisplay(msg.showDisplay !== false);\n        const response = yield transport.call(Messages.MessageType.MESSAGETYPE_COSMOSGETADDRESS, getAddr, core.LONG_TIMEOUT);\n        if (response.message_type === core.Events.FAILURE)\n            throw response;\n        const cosmosAddress = response.proto;\n        return core.mustBeDefined(cosmosAddress.getAddress());\n    });\n}\nexports.cosmosGetAddress = cosmosGetAddress;\n//# sourceMappingURL=cosmos.js.map"]},"metadata":{},"sourceType":"script"}