{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\n\nconst h264 = __importStar(require(\"h264-profile-level-id\"));\n\nconst utils = __importStar(require(\"./utils\"));\n\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCapabilities(caps) {\n  if (typeof caps !== 'object') throw new TypeError('caps is not an object'); // codecs is optional. If unset, fill with an empty array.\n\n  if (caps.codecs && !Array.isArray(caps.codecs)) throw new TypeError('caps.codecs is not an array');else if (!caps.codecs) caps.codecs = [];\n\n  for (const codec of caps.codecs) {\n    validateRtpCodecCapability(codec);\n  } // headerExtensions is optional. If unset, fill with an empty array.\n\n\n  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) throw new TypeError('caps.headerExtensions is not an array');else if (!caps.headerExtensions) caps.headerExtensions = [];\n\n  for (const ext of caps.headerExtensions) {\n    validateRtpHeaderExtension(ext);\n  }\n}\n\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCodecCapability(codec) {\n  const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (typeof codec !== 'object') throw new TypeError('codec is not an object'); // mimeType is mandatory.\n\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');\n  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType'); // Just override kind with media component of mimeType.\n\n  codec.kind = mimeTypeMatch[1].toLowerCase(); // preferredPayloadType is optional.\n\n  if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number') throw new TypeError('invalid codec.preferredPayloadType'); // clockRate is mandatory.\n\n  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate'); // channels is optional. If unset, set it to 1 (just if audio).\n\n  if (codec.kind === 'audio') {\n    if (typeof codec.channels !== 'number') codec.channels = 1;\n  } else {\n    delete codec.channels;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!codec.parameters || typeof codec.parameters !== 'object') codec.parameters = {};\n\n  for (const key of Object.keys(codec.parameters)) {\n    let value = codec.parameters[key];\n\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n    } // Specific parameters validation.\n\n\n    if (key === 'apt') {\n      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');\n    }\n  } // rtcpFeedback is optional. If unset, set it to an empty array.\n\n\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];\n\n  for (const fb of codec.rtcpFeedback) {\n    validateRtcpFeedback(fb);\n  }\n}\n\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtcpFeedback(fb) {\n  if (typeof fb !== 'object') throw new TypeError('fb is not an object'); // type is mandatory.\n\n  if (!fb.type || typeof fb.type !== 'string') throw new TypeError('missing fb.type'); // parameter is optional. If unset set it to an empty string.\n\n  if (!fb.parameter || typeof fb.parameter !== 'string') fb.parameter = '';\n}\n\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpHeaderExtension(ext) {\n  if (typeof ext !== 'object') throw new TypeError('ext is not an object'); // kind is mandatory.\n\n  if (ext.kind !== 'audio' && ext.kind !== 'video') throw new TypeError('invalid ext.kind'); // uri is mandatory.\n\n  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri'); // preferredId is mandatory.\n\n  if (typeof ext.preferredId !== 'number') throw new TypeError('missing ext.preferredId'); // preferredEncrypt is optional. If unset set it to false.\n\n  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') throw new TypeError('invalid ext.preferredEncrypt');else if (!ext.preferredEncrypt) ext.preferredEncrypt = false; // direction is optional. If unset set it to sendrecv.\n\n  if (ext.direction && typeof ext.direction !== 'string') throw new TypeError('invalid ext.direction');else if (!ext.direction) ext.direction = 'sendrecv';\n}\n\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpParameters(params) {\n  if (typeof params !== 'object') throw new TypeError('params is not an object'); // mid is optional.\n\n  if (params.mid && typeof params.mid !== 'string') throw new TypeError('params.mid is not a string'); // codecs is mandatory.\n\n  if (!Array.isArray(params.codecs)) throw new TypeError('missing params.codecs');\n\n  for (const codec of params.codecs) {\n    validateRtpCodecParameters(codec);\n  } // headerExtensions is optional. If unset, fill with an empty array.\n\n\n  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) throw new TypeError('params.headerExtensions is not an array');else if (!params.headerExtensions) params.headerExtensions = [];\n\n  for (const ext of params.headerExtensions) {\n    validateRtpHeaderExtensionParameters(ext);\n  } // encodings is optional. If unset, fill with an empty array.\n\n\n  if (params.encodings && !Array.isArray(params.encodings)) throw new TypeError('params.encodings is not an array');else if (!params.encodings) params.encodings = [];\n\n  for (const encoding of params.encodings) {\n    validateRtpEncodingParameters(encoding);\n  } // rtcp is optional. If unset, fill with an empty object.\n\n\n  if (params.rtcp && typeof params.rtcp !== 'object') throw new TypeError('params.rtcp is not an object');else if (!params.rtcp) params.rtcp = {};\n  validateRtcpParameters(params.rtcp);\n}\n\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpCodecParameters(codec) {\n  const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n  if (typeof codec !== 'object') throw new TypeError('codec is not an object'); // mimeType is mandatory.\n\n  if (!codec.mimeType || typeof codec.mimeType !== 'string') throw new TypeError('missing codec.mimeType');\n  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n  if (!mimeTypeMatch) throw new TypeError('invalid codec.mimeType'); // payloadType is mandatory.\n\n  if (typeof codec.payloadType !== 'number') throw new TypeError('missing codec.payloadType'); // clockRate is mandatory.\n\n  if (typeof codec.clockRate !== 'number') throw new TypeError('missing codec.clockRate');\n  const kind = mimeTypeMatch[1].toLowerCase(); // channels is optional. If unset, set it to 1 (just if audio).\n\n  if (kind === 'audio') {\n    if (typeof codec.channels !== 'number') codec.channels = 1;\n  } else {\n    delete codec.channels;\n  } // parameters is optional. If unset, set it to an empty object.\n\n\n  if (!codec.parameters || typeof codec.parameters !== 'object') codec.parameters = {};\n\n  for (const key of Object.keys(codec.parameters)) {\n    let value = codec.parameters[key];\n\n    if (value === undefined) {\n      codec.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') {\n      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n    } // Specific parameters validation.\n\n\n    if (key === 'apt') {\n      if (typeof value !== 'number') throw new TypeError('invalid codec apt parameter');\n    }\n  } // rtcpFeedback is optional. If unset, set it to an empty array.\n\n\n  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) codec.rtcpFeedback = [];\n\n  for (const fb of codec.rtcpFeedback) {\n    validateRtcpFeedback(fb);\n  }\n}\n\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpHeaderExtensionParameters(ext) {\n  if (typeof ext !== 'object') throw new TypeError('ext is not an object'); // uri is mandatory.\n\n  if (!ext.uri || typeof ext.uri !== 'string') throw new TypeError('missing ext.uri'); // id is mandatory.\n\n  if (typeof ext.id !== 'number') throw new TypeError('missing ext.id'); // encrypt is optional. If unset set it to false.\n\n  if (ext.encrypt && typeof ext.encrypt !== 'boolean') throw new TypeError('invalid ext.encrypt');else if (!ext.encrypt) ext.encrypt = false; // parameters is optional. If unset, set it to an empty object.\n\n  if (!ext.parameters || typeof ext.parameters !== 'object') ext.parameters = {};\n\n  for (const key of Object.keys(ext.parameters)) {\n    let value = ext.parameters[key];\n\n    if (value === undefined) {\n      ext.parameters[key] = '';\n      value = '';\n    }\n\n    if (typeof value !== 'string' && typeof value !== 'number') throw new TypeError('invalid header extension parameter');\n  }\n}\n\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtpEncodingParameters(encoding) {\n  if (typeof encoding !== 'object') throw new TypeError('encoding is not an object'); // ssrc is optional.\n\n  if (encoding.ssrc && typeof encoding.ssrc !== 'number') throw new TypeError('invalid encoding.ssrc'); // rid is optional.\n\n  if (encoding.rid && typeof encoding.rid !== 'string') throw new TypeError('invalid encoding.rid'); // rtx is optional.\n\n  if (encoding.rtx && typeof encoding.rtx !== 'object') {\n    throw new TypeError('invalid encoding.rtx');\n  } else if (encoding.rtx) {\n    // RTX ssrc is mandatory if rtx is present.\n    if (typeof encoding.rtx.ssrc !== 'number') throw new TypeError('missing encoding.rtx.ssrc');\n  } // dtx is optional. If unset set it to false.\n\n\n  if (!encoding.dtx || typeof encoding.dtx !== 'boolean') encoding.dtx = false; // scalabilityMode is optional.\n\n  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string') throw new TypeError('invalid encoding.scalabilityMode');\n}\n\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateRtcpParameters(rtcp) {\n  if (typeof rtcp !== 'object') throw new TypeError('rtcp is not an object'); // cname is optional.\n\n  if (rtcp.cname && typeof rtcp.cname !== 'string') throw new TypeError('invalid rtcp.cname'); // reducedSize is optional. If unset set it to true.\n\n  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') rtcp.reducedSize = true;\n}\n\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpCapabilities(caps) {\n  if (typeof caps !== 'object') throw new TypeError('caps is not an object'); // numStreams is mandatory.\n\n  if (!caps.numStreams || typeof caps.numStreams !== 'object') throw new TypeError('missing caps.numStreams');\n  validateNumSctpStreams(caps.numStreams);\n}\n\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateNumSctpStreams(numStreams) {\n  if (typeof numStreams !== 'object') throw new TypeError('numStreams is not an object'); // OS is mandatory.\n\n  if (typeof numStreams.OS !== 'number') throw new TypeError('missing numStreams.OS'); // MIS is mandatory.\n\n  if (typeof numStreams.MIS !== 'number') throw new TypeError('missing numStreams.MIS');\n}\n\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpParameters(params) {\n  if (typeof params !== 'object') throw new TypeError('params is not an object'); // port is mandatory.\n\n  if (typeof params.port !== 'number') throw new TypeError('missing params.port'); // OS is mandatory.\n\n  if (typeof params.OS !== 'number') throw new TypeError('missing params.OS'); // MIS is mandatory.\n\n  if (typeof params.MIS !== 'number') throw new TypeError('missing params.MIS'); // maxMessageSize is mandatory.\n\n  if (typeof params.maxMessageSize !== 'number') throw new TypeError('missing params.maxMessageSize');\n}\n\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\n\nfunction validateSctpStreamParameters(params) {\n  if (typeof params !== 'object') throw new TypeError('params is not an object'); // streamId is mandatory.\n\n  if (typeof params.streamId !== 'number') throw new TypeError('missing params.streamId'); // ordered is optional.\n\n  let orderedGiven = false;\n  if (typeof params.ordered === 'boolean') orderedGiven = true;else params.ordered = true; // maxPacketLifeTime is optional.\n\n  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number') throw new TypeError('invalid params.maxPacketLifeTime'); // maxRetransmits is optional.\n\n  if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') throw new TypeError('invalid params.maxRetransmits');\n  if (params.maxPacketLifeTime && params.maxRetransmits) throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n\n  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n    params.ordered = false;\n  } // label is optional.\n\n\n  if (params.label && typeof params.label !== 'string') throw new TypeError('invalid params.label'); // protocol is optional.\n\n  if (params.protocol && typeof params.protocol !== 'string') throw new TypeError('invalid params.protocol');\n}\n\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\n\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n  const extendedRtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  }; // Match media codecs and keep the order preferred by remoteCaps.\n\n  for (const remoteCodec of remoteCaps.codecs || []) {\n    if (isRtxCodec(remoteCodec)) continue;\n    const matchingLocalCodec = (localCaps.codecs || []).find(localCodec => matchCodecs(localCodec, remoteCodec, {\n      strict: true,\n      modify: true\n    }));\n    if (!matchingLocalCodec) continue;\n    const extendedCodec = {\n      mimeType: matchingLocalCodec.mimeType,\n      kind: matchingLocalCodec.kind,\n      clockRate: matchingLocalCodec.clockRate,\n      channels: matchingLocalCodec.channels,\n      localPayloadType: matchingLocalCodec.preferredPayloadType,\n      localRtxPayloadType: undefined,\n      remotePayloadType: remoteCodec.preferredPayloadType,\n      remoteRtxPayloadType: undefined,\n      localParameters: matchingLocalCodec.parameters,\n      remoteParameters: remoteCodec.parameters,\n      rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n    };\n    extendedRtpCapabilities.codecs.push(extendedCodec);\n  } // Match RTX codecs.\n\n\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    const matchingLocalRtxCodec = localCaps.codecs.find(localCodec => isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);\n    const matchingRemoteRtxCodec = remoteCaps.codecs.find(remoteCodec => isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);\n\n    if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n      extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n      extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n    }\n  } // Match header extensions.\n\n\n  for (const remoteExt of remoteCaps.headerExtensions) {\n    const matchingLocalExt = localCaps.headerExtensions.find(localExt => matchHeaderExtensions(localExt, remoteExt));\n    if (!matchingLocalExt) continue;\n    const extendedExt = {\n      kind: remoteExt.kind,\n      uri: remoteExt.uri,\n      sendId: matchingLocalExt.preferredId,\n      recvId: remoteExt.preferredId,\n      encrypt: matchingLocalExt.preferredEncrypt,\n      direction: 'sendrecv'\n    };\n\n    switch (remoteExt.direction) {\n      case 'sendrecv':\n        extendedExt.direction = 'sendrecv';\n        break;\n\n      case 'recvonly':\n        extendedExt.direction = 'sendonly';\n        break;\n\n      case 'sendonly':\n        extendedExt.direction = 'recvonly';\n        break;\n\n      case 'inactive':\n        extendedExt.direction = 'inactive';\n        break;\n    }\n\n    extendedRtpCapabilities.headerExtensions.push(extendedExt);\n  }\n\n  return extendedRtpCapabilities;\n}\n\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\n\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n  const rtpCapabilities = {\n    codecs: [],\n    headerExtensions: []\n  };\n\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      kind: extendedCodec.kind,\n      preferredPayloadType: extendedCodec.remotePayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.localParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpCapabilities.codecs.push(codec); // Add RTX codec.\n\n    if (!extendedCodec.remoteRtxPayloadType) continue;\n    const rtxCodec = {\n      mimeType: `${extendedCodec.kind}/rtx`,\n      kind: extendedCodec.kind,\n      preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n      clockRate: extendedCodec.clockRate,\n      parameters: {\n        apt: extendedCodec.remotePayloadType\n      },\n      rtcpFeedback: []\n    };\n    rtpCapabilities.codecs.push(rtxCodec); // TODO: In the future, we need to add FEC, CN, etc, codecs.\n  }\n\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions not valid for receiving.\n    if (extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'recvonly') {\n      continue;\n    }\n\n    const ext = {\n      kind: extendedExtension.kind,\n      uri: extendedExtension.uri,\n      preferredId: extendedExtension.recvId,\n      preferredEncrypt: extendedExtension.encrypt,\n      direction: extendedExtension.direction\n    };\n    rtpCapabilities.headerExtensions.push(ext);\n  }\n\n  return rtpCapabilities;\n}\n\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\n\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n  const rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    if (extendedCodec.kind !== kind) continue;\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      payloadType: extendedCodec.localPayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.localParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpParameters.codecs.push(codec); // Add RTX codec.\n\n    if (extendedCodec.localRtxPayloadType) {\n      const rtxCodec = {\n        mimeType: `${extendedCodec.kind}/rtx`,\n        payloadType: extendedCodec.localRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.localPayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpParameters.codecs.push(rtxCodec);\n    }\n  }\n\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions of a different kind and those not valid for sending.\n    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n      continue;\n    }\n\n    const ext = {\n      uri: extendedExtension.uri,\n      id: extendedExtension.sendId,\n      encrypt: extendedExtension.encrypt,\n      parameters: {}\n    };\n    rtpParameters.headerExtensions.push(ext);\n  }\n\n  return rtpParameters;\n}\n\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\n\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n  const rtpParameters = {\n    mid: undefined,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [],\n    rtcp: {}\n  };\n\n  for (const extendedCodec of extendedRtpCapabilities.codecs) {\n    if (extendedCodec.kind !== kind) continue;\n    const codec = {\n      mimeType: extendedCodec.mimeType,\n      payloadType: extendedCodec.localPayloadType,\n      clockRate: extendedCodec.clockRate,\n      channels: extendedCodec.channels,\n      parameters: extendedCodec.remoteParameters,\n      rtcpFeedback: extendedCodec.rtcpFeedback\n    };\n    rtpParameters.codecs.push(codec); // Add RTX codec.\n\n    if (extendedCodec.localRtxPayloadType) {\n      const rtxCodec = {\n        mimeType: `${extendedCodec.kind}/rtx`,\n        payloadType: extendedCodec.localRtxPayloadType,\n        clockRate: extendedCodec.clockRate,\n        parameters: {\n          apt: extendedCodec.localPayloadType\n        },\n        rtcpFeedback: []\n      };\n      rtpParameters.codecs.push(rtxCodec);\n    }\n  }\n\n  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n    // Ignore RTP extensions of a different kind and those not valid for sending.\n    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== 'sendrecv' && extendedExtension.direction !== 'sendonly') {\n      continue;\n    }\n\n    const ext = {\n      uri: extendedExtension.uri,\n      id: extendedExtension.sendId,\n      encrypt: extendedExtension.encrypt,\n      parameters: {}\n    };\n    rtpParameters.headerExtensions.push(ext);\n  } // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n\n\n  if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'goog-remb');\n    }\n  } else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'transport-cc');\n    }\n  } else {\n    for (const codec of rtpParameters.codecs) {\n      codec.rtcpFeedback = (codec.rtcpFeedback || []).filter(fb => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');\n    }\n  }\n\n  return rtpParameters;\n}\n\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\n\nfunction reduceCodecs(codecs, capCodec) {\n  const filteredCodecs = []; // If no capability codec is given, take the first one (and RTX).\n\n  if (!capCodec) {\n    filteredCodecs.push(codecs[0]);\n    if (isRtxCodec(codecs[1])) filteredCodecs.push(codecs[1]);\n  } // Otherwise look for a compatible set of codecs.\n  else {\n    for (let idx = 0; idx < codecs.length; ++idx) {\n      if (matchCodecs(codecs[idx], capCodec)) {\n        filteredCodecs.push(codecs[idx]);\n        if (isRtxCodec(codecs[idx + 1])) filteredCodecs.push(codecs[idx + 1]);\n        break;\n      }\n    }\n\n    if (filteredCodecs.length === 0) throw new TypeError('no matching codec found');\n  }\n\n  return filteredCodecs;\n}\n\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\n\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n  // Clone given reference video RTP parameters.\n  videoRtpParameters = utils.clone(videoRtpParameters, {}); // This may throw.\n\n  validateRtpParameters(videoRtpParameters);\n  const rtpParameters = {\n    mid: RTP_PROBATOR_MID,\n    codecs: [],\n    headerExtensions: [],\n    encodings: [{\n      ssrc: RTP_PROBATOR_SSRC\n    }],\n    rtcp: {\n      cname: 'probator'\n    }\n  };\n  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n  return rtpParameters;\n}\n\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\n\nfunction canSend(kind, extendedRtpCapabilities) {\n  return extendedRtpCapabilities.codecs.some(codec => codec.kind === kind);\n}\n\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\n\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n  // This may throw.\n  validateRtpParameters(rtpParameters);\n  if (rtpParameters.codecs.length === 0) return false;\n  const firstMediaCodec = rtpParameters.codecs[0];\n  return extendedRtpCapabilities.codecs.some(codec => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\n\nexports.canReceive = canReceive;\n\nfunction isRtxCodec(codec) {\n  if (!codec) return false;\n  return /.+\\/rtx$/i.test(codec.mimeType);\n}\n\nfunction matchCodecs(aCodec, bCodec, {\n  strict = false,\n  modify = false\n} = {}) {\n  const aMimeType = aCodec.mimeType.toLowerCase();\n  const bMimeType = bCodec.mimeType.toLowerCase();\n  if (aMimeType !== bMimeType) return false;\n  if (aCodec.clockRate !== bCodec.clockRate) return false;\n  if (aCodec.channels !== bCodec.channels) return false; // Per codec special checks.\n\n  switch (aMimeType) {\n    case 'video/h264':\n      {\n        const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n        const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n        if (aPacketizationMode !== bPacketizationMode) return false; // If strict matching check profile-level-id.\n\n        if (strict) {\n          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) return false;\n          let selectedProfileLevelId;\n\n          try {\n            selectedProfileLevelId = h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n          } catch (error) {\n            return false;\n          }\n\n          if (modify) {\n            if (selectedProfileLevelId) {\n              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n            } else {\n              delete aCodec.parameters['profile-level-id'];\n              delete bCodec.parameters['profile-level-id'];\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'video/vp9':\n      {\n        // If strict matching check profile-id.\n        if (strict) {\n          const aProfileId = aCodec.parameters['profile-id'] || 0;\n          const bProfileId = bCodec.parameters['profile-id'] || 0;\n          if (aProfileId !== bProfileId) return false;\n        }\n\n        break;\n      }\n  }\n\n  return true;\n}\n\nfunction matchHeaderExtensions(aExt, bExt) {\n  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) return false;\n  if (aExt.uri !== bExt.uri) return false;\n  return true;\n}\n\nfunction reduceRtcpFeedback(codecA, codecB) {\n  const reducedRtcpFeedback = [];\n\n  for (const aFb of codecA.rtcpFeedback || []) {\n    const matchingBFb = (codecB.rtcpFeedback || []).find(bFb => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));\n    if (matchingBFb) reducedRtcpFeedback.push(matchingBFb);\n  }\n\n  return reducedRtcpFeedback;\n}","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/mediasoup-client/lib/ortc.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","exports","canReceive","canSend","generateProbatorRtpParameters","reduceCodecs","getSendingRemoteRtpParameters","getSendingRtpParameters","getRecvRtpCapabilities","getExtendedRtpCapabilities","validateSctpStreamParameters","validateSctpParameters","validateNumSctpStreams","validateSctpCapabilities","validateRtcpParameters","validateRtpEncodingParameters","validateRtpHeaderExtensionParameters","validateRtpCodecParameters","validateRtpParameters","validateRtpHeaderExtension","validateRtcpFeedback","validateRtpCodecCapability","validateRtpCapabilities","h264","require","utils","RTP_PROBATOR_MID","RTP_PROBATOR_SSRC","RTP_PROBATOR_CODEC_PAYLOAD_TYPE","caps","TypeError","codecs","Array","isArray","codec","headerExtensions","ext","MimeTypeRegex","RegExp","mimeType","mimeTypeMatch","exec","kind","toLowerCase","preferredPayloadType","clockRate","channels","parameters","key","keys","rtcpFeedback","fb","type","parameter","uri","preferredId","preferredEncrypt","direction","params","mid","encodings","encoding","rtcp","payloadType","id","encrypt","ssrc","rid","rtx","dtx","scalabilityMode","cname","reducedSize","numStreams","OS","MIS","port","maxMessageSize","streamId","orderedGiven","ordered","maxPacketLifeTime","maxRetransmits","label","protocol","localCaps","remoteCaps","extendedRtpCapabilities","remoteCodec","isRtxCodec","matchingLocalCodec","find","localCodec","matchCodecs","strict","modify","extendedCodec","localPayloadType","localRtxPayloadType","remotePayloadType","remoteRtxPayloadType","localParameters","remoteParameters","reduceRtcpFeedback","push","matchingLocalRtxCodec","apt","matchingRemoteRtxCodec","remoteExt","matchingLocalExt","localExt","matchHeaderExtensions","extendedExt","sendId","recvId","rtpCapabilities","rtxCodec","extendedExtension","rtpParameters","some","filter","capCodec","filteredCodecs","idx","length","videoRtpParameters","clone","firstMediaCodec","test","aCodec","bCodec","aMimeType","bMimeType","aPacketizationMode","bPacketizationMode","isSameProfile","selectedProfileLevelId","generateProfileLevelIdForAnswer","error","aProfileId","bProfileId","aExt","bExt","codecA","codecB","reducedRtcpFeedback","aFb","matchingBFb","bFb"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;\nconst h264 = __importStar(require(\"h264-profile-level-id\"));\nconst utils = __importStar(require(\"./utils\"));\nconst RTP_PROBATOR_MID = 'probator';\nconst RTP_PROBATOR_SSRC = 1234;\nconst RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;\n/**\n * Validates RtpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCapabilities(caps) {\n    if (typeof caps !== 'object')\n        throw new TypeError('caps is not an object');\n    // codecs is optional. If unset, fill with an empty array.\n    if (caps.codecs && !Array.isArray(caps.codecs))\n        throw new TypeError('caps.codecs is not an array');\n    else if (!caps.codecs)\n        caps.codecs = [];\n    for (const codec of caps.codecs) {\n        validateRtpCodecCapability(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))\n        throw new TypeError('caps.headerExtensions is not an array');\n    else if (!caps.headerExtensions)\n        caps.headerExtensions = [];\n    for (const ext of caps.headerExtensions) {\n        validateRtpHeaderExtension(ext);\n    }\n}\nexports.validateRtpCapabilities = validateRtpCapabilities;\n/**\n * Validates RtpCodecCapability. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecCapability(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object')\n        throw new TypeError('codec is not an object');\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\n        throw new TypeError('missing codec.mimeType');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    // Just override kind with media component of mimeType.\n    codec.kind = mimeTypeMatch[1].toLowerCase();\n    // preferredPayloadType is optional.\n    if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')\n        throw new TypeError('invalid codec.preferredPayloadType');\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number')\n        throw new TypeError('missing codec.clockRate');\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (codec.kind === 'audio') {\n        if (typeof codec.channels !== 'number')\n            codec.channels = 1;\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object')\n        codec.parameters = {};\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number')\n                throw new TypeError('invalid codec apt parameter');\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\n        codec.rtcpFeedback = [];\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecCapability = validateRtpCodecCapability;\n/**\n * Validates RtcpFeedback. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpFeedback(fb) {\n    if (typeof fb !== 'object')\n        throw new TypeError('fb is not an object');\n    // type is mandatory.\n    if (!fb.type || typeof fb.type !== 'string')\n        throw new TypeError('missing fb.type');\n    // parameter is optional. If unset set it to an empty string.\n    if (!fb.parameter || typeof fb.parameter !== 'string')\n        fb.parameter = '';\n}\nexports.validateRtcpFeedback = validateRtcpFeedback;\n/**\n * Validates RtpHeaderExtension. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtension(ext) {\n    if (typeof ext !== 'object')\n        throw new TypeError('ext is not an object');\n    // kind is mandatory.\n    if (ext.kind !== 'audio' && ext.kind !== 'video')\n        throw new TypeError('invalid ext.kind');\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string')\n        throw new TypeError('missing ext.uri');\n    // preferredId is mandatory.\n    if (typeof ext.preferredId !== 'number')\n        throw new TypeError('missing ext.preferredId');\n    // preferredEncrypt is optional. If unset set it to false.\n    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')\n        throw new TypeError('invalid ext.preferredEncrypt');\n    else if (!ext.preferredEncrypt)\n        ext.preferredEncrypt = false;\n    // direction is optional. If unset set it to sendrecv.\n    if (ext.direction && typeof ext.direction !== 'string')\n        throw new TypeError('invalid ext.direction');\n    else if (!ext.direction)\n        ext.direction = 'sendrecv';\n}\nexports.validateRtpHeaderExtension = validateRtpHeaderExtension;\n/**\n * Validates RtpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // mid is optional.\n    if (params.mid && typeof params.mid !== 'string')\n        throw new TypeError('params.mid is not a string');\n    // codecs is mandatory.\n    if (!Array.isArray(params.codecs))\n        throw new TypeError('missing params.codecs');\n    for (const codec of params.codecs) {\n        validateRtpCodecParameters(codec);\n    }\n    // headerExtensions is optional. If unset, fill with an empty array.\n    if (params.headerExtensions && !Array.isArray(params.headerExtensions))\n        throw new TypeError('params.headerExtensions is not an array');\n    else if (!params.headerExtensions)\n        params.headerExtensions = [];\n    for (const ext of params.headerExtensions) {\n        validateRtpHeaderExtensionParameters(ext);\n    }\n    // encodings is optional. If unset, fill with an empty array.\n    if (params.encodings && !Array.isArray(params.encodings))\n        throw new TypeError('params.encodings is not an array');\n    else if (!params.encodings)\n        params.encodings = [];\n    for (const encoding of params.encodings) {\n        validateRtpEncodingParameters(encoding);\n    }\n    // rtcp is optional. If unset, fill with an empty object.\n    if (params.rtcp && typeof params.rtcp !== 'object')\n        throw new TypeError('params.rtcp is not an object');\n    else if (!params.rtcp)\n        params.rtcp = {};\n    validateRtcpParameters(params.rtcp);\n}\nexports.validateRtpParameters = validateRtpParameters;\n/**\n * Validates RtpCodecParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpCodecParameters(codec) {\n    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');\n    if (typeof codec !== 'object')\n        throw new TypeError('codec is not an object');\n    // mimeType is mandatory.\n    if (!codec.mimeType || typeof codec.mimeType !== 'string')\n        throw new TypeError('missing codec.mimeType');\n    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);\n    if (!mimeTypeMatch)\n        throw new TypeError('invalid codec.mimeType');\n    // payloadType is mandatory.\n    if (typeof codec.payloadType !== 'number')\n        throw new TypeError('missing codec.payloadType');\n    // clockRate is mandatory.\n    if (typeof codec.clockRate !== 'number')\n        throw new TypeError('missing codec.clockRate');\n    const kind = mimeTypeMatch[1].toLowerCase();\n    // channels is optional. If unset, set it to 1 (just if audio).\n    if (kind === 'audio') {\n        if (typeof codec.channels !== 'number')\n            codec.channels = 1;\n    }\n    else {\n        delete codec.channels;\n    }\n    // parameters is optional. If unset, set it to an empty object.\n    if (!codec.parameters || typeof codec.parameters !== 'object')\n        codec.parameters = {};\n    for (const key of Object.keys(codec.parameters)) {\n        let value = codec.parameters[key];\n        if (value === undefined) {\n            codec.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);\n        }\n        // Specific parameters validation.\n        if (key === 'apt') {\n            if (typeof value !== 'number')\n                throw new TypeError('invalid codec apt parameter');\n        }\n    }\n    // rtcpFeedback is optional. If unset, set it to an empty array.\n    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))\n        codec.rtcpFeedback = [];\n    for (const fb of codec.rtcpFeedback) {\n        validateRtcpFeedback(fb);\n    }\n}\nexports.validateRtpCodecParameters = validateRtpCodecParameters;\n/**\n * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpHeaderExtensionParameters(ext) {\n    if (typeof ext !== 'object')\n        throw new TypeError('ext is not an object');\n    // uri is mandatory.\n    if (!ext.uri || typeof ext.uri !== 'string')\n        throw new TypeError('missing ext.uri');\n    // id is mandatory.\n    if (typeof ext.id !== 'number')\n        throw new TypeError('missing ext.id');\n    // encrypt is optional. If unset set it to false.\n    if (ext.encrypt && typeof ext.encrypt !== 'boolean')\n        throw new TypeError('invalid ext.encrypt');\n    else if (!ext.encrypt)\n        ext.encrypt = false;\n    // parameters is optional. If unset, set it to an empty object.\n    if (!ext.parameters || typeof ext.parameters !== 'object')\n        ext.parameters = {};\n    for (const key of Object.keys(ext.parameters)) {\n        let value = ext.parameters[key];\n        if (value === undefined) {\n            ext.parameters[key] = '';\n            value = '';\n        }\n        if (typeof value !== 'string' && typeof value !== 'number')\n            throw new TypeError('invalid header extension parameter');\n    }\n}\nexports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;\n/**\n * Validates RtpEncodingParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtpEncodingParameters(encoding) {\n    if (typeof encoding !== 'object')\n        throw new TypeError('encoding is not an object');\n    // ssrc is optional.\n    if (encoding.ssrc && typeof encoding.ssrc !== 'number')\n        throw new TypeError('invalid encoding.ssrc');\n    // rid is optional.\n    if (encoding.rid && typeof encoding.rid !== 'string')\n        throw new TypeError('invalid encoding.rid');\n    // rtx is optional.\n    if (encoding.rtx && typeof encoding.rtx !== 'object') {\n        throw new TypeError('invalid encoding.rtx');\n    }\n    else if (encoding.rtx) {\n        // RTX ssrc is mandatory if rtx is present.\n        if (typeof encoding.rtx.ssrc !== 'number')\n            throw new TypeError('missing encoding.rtx.ssrc');\n    }\n    // dtx is optional. If unset set it to false.\n    if (!encoding.dtx || typeof encoding.dtx !== 'boolean')\n        encoding.dtx = false;\n    // scalabilityMode is optional.\n    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')\n        throw new TypeError('invalid encoding.scalabilityMode');\n}\nexports.validateRtpEncodingParameters = validateRtpEncodingParameters;\n/**\n * Validates RtcpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateRtcpParameters(rtcp) {\n    if (typeof rtcp !== 'object')\n        throw new TypeError('rtcp is not an object');\n    // cname is optional.\n    if (rtcp.cname && typeof rtcp.cname !== 'string')\n        throw new TypeError('invalid rtcp.cname');\n    // reducedSize is optional. If unset set it to true.\n    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')\n        rtcp.reducedSize = true;\n}\nexports.validateRtcpParameters = validateRtcpParameters;\n/**\n * Validates SctpCapabilities. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpCapabilities(caps) {\n    if (typeof caps !== 'object')\n        throw new TypeError('caps is not an object');\n    // numStreams is mandatory.\n    if (!caps.numStreams || typeof caps.numStreams !== 'object')\n        throw new TypeError('missing caps.numStreams');\n    validateNumSctpStreams(caps.numStreams);\n}\nexports.validateSctpCapabilities = validateSctpCapabilities;\n/**\n * Validates NumSctpStreams. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateNumSctpStreams(numStreams) {\n    if (typeof numStreams !== 'object')\n        throw new TypeError('numStreams is not an object');\n    // OS is mandatory.\n    if (typeof numStreams.OS !== 'number')\n        throw new TypeError('missing numStreams.OS');\n    // MIS is mandatory.\n    if (typeof numStreams.MIS !== 'number')\n        throw new TypeError('missing numStreams.MIS');\n}\nexports.validateNumSctpStreams = validateNumSctpStreams;\n/**\n * Validates SctpParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // port is mandatory.\n    if (typeof params.port !== 'number')\n        throw new TypeError('missing params.port');\n    // OS is mandatory.\n    if (typeof params.OS !== 'number')\n        throw new TypeError('missing params.OS');\n    // MIS is mandatory.\n    if (typeof params.MIS !== 'number')\n        throw new TypeError('missing params.MIS');\n    // maxMessageSize is mandatory.\n    if (typeof params.maxMessageSize !== 'number')\n        throw new TypeError('missing params.maxMessageSize');\n}\nexports.validateSctpParameters = validateSctpParameters;\n/**\n * Validates SctpStreamParameters. It may modify given data by adding missing\n * fields with default values.\n * It throws if invalid.\n */\nfunction validateSctpStreamParameters(params) {\n    if (typeof params !== 'object')\n        throw new TypeError('params is not an object');\n    // streamId is mandatory.\n    if (typeof params.streamId !== 'number')\n        throw new TypeError('missing params.streamId');\n    // ordered is optional.\n    let orderedGiven = false;\n    if (typeof params.ordered === 'boolean')\n        orderedGiven = true;\n    else\n        params.ordered = true;\n    // maxPacketLifeTime is optional.\n    if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')\n        throw new TypeError('invalid params.maxPacketLifeTime');\n    // maxRetransmits is optional.\n    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')\n        throw new TypeError('invalid params.maxRetransmits');\n    if (params.maxPacketLifeTime && params.maxRetransmits)\n        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');\n    if (orderedGiven &&\n        params.ordered &&\n        (params.maxPacketLifeTime || params.maxRetransmits)) {\n        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');\n    }\n    else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {\n        params.ordered = false;\n    }\n    // label is optional.\n    if (params.label && typeof params.label !== 'string')\n        throw new TypeError('invalid params.label');\n    // protocol is optional.\n    if (params.protocol && typeof params.protocol !== 'string')\n        throw new TypeError('invalid params.protocol');\n}\nexports.validateSctpStreamParameters = validateSctpStreamParameters;\n/**\n * Generate extended RTP capabilities for sending and receiving.\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps) {\n    const extendedRtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    // Match media codecs and keep the order preferred by remoteCaps.\n    for (const remoteCodec of remoteCaps.codecs || []) {\n        if (isRtxCodec(remoteCodec))\n            continue;\n        const matchingLocalCodec = (localCaps.codecs || [])\n            .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));\n        if (!matchingLocalCodec)\n            continue;\n        const extendedCodec = {\n            mimeType: matchingLocalCodec.mimeType,\n            kind: matchingLocalCodec.kind,\n            clockRate: matchingLocalCodec.clockRate,\n            channels: matchingLocalCodec.channels,\n            localPayloadType: matchingLocalCodec.preferredPayloadType,\n            localRtxPayloadType: undefined,\n            remotePayloadType: remoteCodec.preferredPayloadType,\n            remoteRtxPayloadType: undefined,\n            localParameters: matchingLocalCodec.parameters,\n            remoteParameters: remoteCodec.parameters,\n            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)\n        };\n        extendedRtpCapabilities.codecs.push(extendedCodec);\n    }\n    // Match RTX codecs.\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const matchingLocalRtxCodec = localCaps.codecs\n            .find((localCodec) => (isRtxCodec(localCodec) &&\n            localCodec.parameters.apt === extendedCodec.localPayloadType));\n        const matchingRemoteRtxCodec = remoteCaps.codecs\n            .find((remoteCodec) => (isRtxCodec(remoteCodec) &&\n            remoteCodec.parameters.apt === extendedCodec.remotePayloadType));\n        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {\n            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n        }\n    }\n    // Match header extensions.\n    for (const remoteExt of remoteCaps.headerExtensions) {\n        const matchingLocalExt = localCaps.headerExtensions\n            .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));\n        if (!matchingLocalExt)\n            continue;\n        const extendedExt = {\n            kind: remoteExt.kind,\n            uri: remoteExt.uri,\n            sendId: matchingLocalExt.preferredId,\n            recvId: remoteExt.preferredId,\n            encrypt: matchingLocalExt.preferredEncrypt,\n            direction: 'sendrecv'\n        };\n        switch (remoteExt.direction) {\n            case 'sendrecv':\n                extendedExt.direction = 'sendrecv';\n                break;\n            case 'recvonly':\n                extendedExt.direction = 'sendonly';\n                break;\n            case 'sendonly':\n                extendedExt.direction = 'recvonly';\n                break;\n            case 'inactive':\n                extendedExt.direction = 'inactive';\n                break;\n        }\n        extendedRtpCapabilities.headerExtensions.push(extendedExt);\n    }\n    return extendedRtpCapabilities;\n}\nexports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n */\nfunction getRecvRtpCapabilities(extendedRtpCapabilities) {\n    const rtpCapabilities = {\n        codecs: [],\n        headerExtensions: []\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remotePayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpCapabilities.codecs.push(codec);\n        // Add RTX codec.\n        if (!extendedCodec.remoteRtxPayloadType)\n            continue;\n        const rtxCodec = {\n            mimeType: `${extendedCodec.kind}/rtx`,\n            kind: extendedCodec.kind,\n            preferredPayloadType: extendedCodec.remoteRtxPayloadType,\n            clockRate: extendedCodec.clockRate,\n            parameters: {\n                apt: extendedCodec.remotePayloadType\n            },\n            rtcpFeedback: []\n        };\n        rtpCapabilities.codecs.push(rtxCodec);\n        // TODO: In the future, we need to add FEC, CN, etc, codecs.\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions not valid for receiving.\n        if (extendedExtension.direction !== 'sendrecv' &&\n            extendedExtension.direction !== 'recvonly') {\n            continue;\n        }\n        const ext = {\n            kind: extendedExtension.kind,\n            uri: extendedExtension.uri,\n            preferredId: extendedExtension.recvId,\n            preferredEncrypt: extendedExtension.encrypt,\n            direction: extendedExtension.direction\n        };\n        rtpCapabilities.headerExtensions.push(ext);\n    }\n    return rtpCapabilities;\n}\nexports.getRecvRtpCapabilities = getRecvRtpCapabilities;\n/**\n * Generate RTP parameters of the given kind for sending media.\n * NOTE: mid, encodings and rtcp fields are left empty.\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind)\n            continue;\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.localParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    return rtpParameters;\n}\nexports.getSendingRtpParameters = getSendingRtpParameters;\n/**\n * Generate RTP parameters of the given kind suitable for the remote SDP answer.\n */\nfunction getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {\n    const rtpParameters = {\n        mid: undefined,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [],\n        rtcp: {}\n    };\n    for (const extendedCodec of extendedRtpCapabilities.codecs) {\n        if (extendedCodec.kind !== kind)\n            continue;\n        const codec = {\n            mimeType: extendedCodec.mimeType,\n            payloadType: extendedCodec.localPayloadType,\n            clockRate: extendedCodec.clockRate,\n            channels: extendedCodec.channels,\n            parameters: extendedCodec.remoteParameters,\n            rtcpFeedback: extendedCodec.rtcpFeedback\n        };\n        rtpParameters.codecs.push(codec);\n        // Add RTX codec.\n        if (extendedCodec.localRtxPayloadType) {\n            const rtxCodec = {\n                mimeType: `${extendedCodec.kind}/rtx`,\n                payloadType: extendedCodec.localRtxPayloadType,\n                clockRate: extendedCodec.clockRate,\n                parameters: {\n                    apt: extendedCodec.localPayloadType\n                },\n                rtcpFeedback: []\n            };\n            rtpParameters.codecs.push(rtxCodec);\n        }\n    }\n    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {\n        // Ignore RTP extensions of a different kind and those not valid for sending.\n        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||\n            (extendedExtension.direction !== 'sendrecv' &&\n                extendedExtension.direction !== 'sendonly')) {\n            continue;\n        }\n        const ext = {\n            uri: extendedExtension.uri,\n            id: extendedExtension.sendId,\n            encrypt: extendedExtension.encrypt,\n            parameters: {}\n        };\n        rtpParameters.headerExtensions.push(ext);\n    }\n    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.\n    if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'goog-remb');\n        }\n    }\n    else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => fb.type !== 'transport-cc');\n        }\n    }\n    else {\n        for (const codec of rtpParameters.codecs) {\n            codec.rtcpFeedback = (codec.rtcpFeedback || [])\n                .filter((fb) => (fb.type !== 'transport-cc' &&\n                fb.type !== 'goog-remb'));\n        }\n    }\n    return rtpParameters;\n}\nexports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;\n/**\n * Reduce given codecs by returning an array of codecs \"compatible\" with the\n * given capability codec. If no capability codec is given, take the first\n * one(s).\n *\n * Given codecs must be generated by ortc.getSendingRtpParameters() or\n * ortc.getSendingRemoteRtpParameters().\n *\n * The returned array of codecs also include a RTX codec if available.\n */\nfunction reduceCodecs(codecs, capCodec) {\n    const filteredCodecs = [];\n    // If no capability codec is given, take the first one (and RTX).\n    if (!capCodec) {\n        filteredCodecs.push(codecs[0]);\n        if (isRtxCodec(codecs[1]))\n            filteredCodecs.push(codecs[1]);\n    }\n    // Otherwise look for a compatible set of codecs.\n    else {\n        for (let idx = 0; idx < codecs.length; ++idx) {\n            if (matchCodecs(codecs[idx], capCodec)) {\n                filteredCodecs.push(codecs[idx]);\n                if (isRtxCodec(codecs[idx + 1]))\n                    filteredCodecs.push(codecs[idx + 1]);\n                break;\n            }\n        }\n        if (filteredCodecs.length === 0)\n            throw new TypeError('no matching codec found');\n    }\n    return filteredCodecs;\n}\nexports.reduceCodecs = reduceCodecs;\n/**\n * Create RTP parameters for a Consumer for the RTP probator.\n */\nfunction generateProbatorRtpParameters(videoRtpParameters) {\n    // Clone given reference video RTP parameters.\n    videoRtpParameters = utils.clone(videoRtpParameters, {});\n    // This may throw.\n    validateRtpParameters(videoRtpParameters);\n    const rtpParameters = {\n        mid: RTP_PROBATOR_MID,\n        codecs: [],\n        headerExtensions: [],\n        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],\n        rtcp: { cname: 'probator' }\n    };\n    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);\n    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;\n    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;\n    return rtpParameters;\n}\nexports.generateProbatorRtpParameters = generateProbatorRtpParameters;\n/**\n * Whether media can be sent based on the given RTP capabilities.\n */\nfunction canSend(kind, extendedRtpCapabilities) {\n    return extendedRtpCapabilities.codecs.\n        some((codec) => codec.kind === kind);\n}\nexports.canSend = canSend;\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities) {\n    // This may throw.\n    validateRtpParameters(rtpParameters);\n    if (rtpParameters.codecs.length === 0)\n        return false;\n    const firstMediaCodec = rtpParameters.codecs[0];\n    return extendedRtpCapabilities.codecs\n        .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);\n}\nexports.canReceive = canReceive;\nfunction isRtxCodec(codec) {\n    if (!codec)\n        return false;\n    return /.+\\/rtx$/i.test(codec.mimeType);\n}\nfunction matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {\n    const aMimeType = aCodec.mimeType.toLowerCase();\n    const bMimeType = bCodec.mimeType.toLowerCase();\n    if (aMimeType !== bMimeType)\n        return false;\n    if (aCodec.clockRate !== bCodec.clockRate)\n        return false;\n    if (aCodec.channels !== bCodec.channels)\n        return false;\n    // Per codec special checks.\n    switch (aMimeType) {\n        case 'video/h264':\n            {\n                const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;\n                const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;\n                if (aPacketizationMode !== bPacketizationMode)\n                    return false;\n                // If strict matching check profile-level-id.\n                if (strict) {\n                    if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))\n                        return false;\n                    let selectedProfileLevelId;\n                    try {\n                        selectedProfileLevelId =\n                            h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);\n                    }\n                    catch (error) {\n                        return false;\n                    }\n                    if (modify) {\n                        if (selectedProfileLevelId) {\n                            aCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                            bCodec.parameters['profile-level-id'] = selectedProfileLevelId;\n                        }\n                        else {\n                            delete aCodec.parameters['profile-level-id'];\n                            delete bCodec.parameters['profile-level-id'];\n                        }\n                    }\n                }\n                break;\n            }\n        case 'video/vp9':\n            {\n                // If strict matching check profile-id.\n                if (strict) {\n                    const aProfileId = aCodec.parameters['profile-id'] || 0;\n                    const bProfileId = bCodec.parameters['profile-id'] || 0;\n                    if (aProfileId !== bProfileId)\n                        return false;\n                }\n                break;\n            }\n    }\n    return true;\n}\nfunction matchHeaderExtensions(aExt, bExt) {\n    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)\n        return false;\n    if (aExt.uri !== bExt.uri)\n        return false;\n    return true;\n}\nfunction reduceRtcpFeedback(codecA, codecB) {\n    const reducedRtcpFeedback = [];\n    for (const aFb of codecA.rtcpFeedback || []) {\n        const matchingBFb = (codecB.rtcpFeedback || [])\n            .find((bFb) => (bFb.type === aFb.type &&\n            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));\n        if (matchingBFb)\n            reducedRtcpFeedback.push(matchingBFb);\n    }\n    return reducedRtcpFeedback;\n}\n"]},"metadata":{},"sourceType":"script"}