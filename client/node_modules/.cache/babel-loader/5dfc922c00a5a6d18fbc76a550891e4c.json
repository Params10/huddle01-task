{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransportDelegate = void 0;\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst keepkey = __importStar(require(\"@shapeshiftoss/hdwallet-keepkey\"));\n\nconst utils_1 = require(\"./utils\");\n\nclass TransportDelegate {\n  constructor(usbDevice) {\n    if (usbDevice.vendorId !== utils_1.VENDOR_ID) throw new core.WebUSBCouldNotPair(\"KeepKey\", \"bad vendor id\");\n    if (usbDevice.productId !== utils_1.WEBUSB_PRODUCT_ID) throw new core.FirmwareUpdateRequired(\"KeepKey\", \"6.1.0\");\n    this.usbDevice = usbDevice;\n  }\n\n  static create(device) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (device.vendorId !== utils_1.VENDOR_ID) return null;\n      return new TransportDelegate(device);\n    });\n  }\n\n  getDeviceID() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.usbDevice.serialNumber;\n    });\n  }\n\n  isOpened() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.usbDevice.opened;\n    });\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.usbDevice.open();\n      if (this.usbDevice.configuration === null) yield this.usbDevice.selectConfiguration(1);\n\n      try {\n        yield this.usbDevice.claimInterface(0);\n      } catch (e) {\n        console.error(\"Could not claim interface 0\", this.usbDevice, {\n          e\n        });\n        if (e.code === 18) // \"The requested interface implements a protected class\"\n          throw new core.FirmwareUpdateRequired(\"KeepKey\", \"6.1.0\");\n        if (e.code === 19) // \"Unable to claim interface\"\n          throw new core.ConflictingApp(\"KeepKey\");\n        throw e;\n      }\n    });\n  }\n\n  tryConnectDebugLink() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // We have to use \"guess & check\" here because the browser doesn't give us a\n      // way to inspect the descriptors :(\n      try {\n        yield this.usbDevice.claimInterface(1);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.usbDevice.opened) return;\n\n      try {\n        // If the device is disconnected, this will fail and throw, which is fine.\n        yield this.usbDevice.close();\n      } catch (e) {\n        console.log(\"Error closing connection with usbDevice\");\n      }\n    });\n  }\n\n  writeChunk(buf, debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.usbDevice.transferOut(debugLink ? 2 : 1, buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n    });\n  }\n\n  readChunk(debugLink) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        status,\n        data\n      } = yield this.usbDevice.transferIn(debugLink ? 2 : 1, keepkey.SEGMENT_SIZE + 1);\n\n      if (status === \"stall\") {\n        yield this.usbDevice.clearHalt(\"out\", debugLink ? 2 : 1);\n      }\n\n      if (data === undefined) throw new Error(\"bad read\");\n      return new Uint8Array(core.toArrayBuffer(data));\n    });\n  }\n\n}\n\nexports.TransportDelegate = TransportDelegate;","map":{"version":3,"sources":["../src/transport.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,IAAA,GAAA,YAAA,CAAA,OAAA,CAAA,8BAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,YAAA,CAAA,OAAA,CAAA,iCAAA,CAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAGA,MAAa,iBAAb,CAA8B;AAG5B,EAAA,WAAA,CAAY,SAAZ,EAA6B;AAC3B,QAAI,SAAS,CAAC,QAAV,KAAuB,OAAA,CAAA,SAA3B,EAAsC,MAAM,IAAI,IAAI,CAAC,kBAAT,CAA4B,SAA5B,EAAuC,eAAvC,CAAN;AACtC,QAAI,SAAS,CAAC,SAAV,KAAwB,OAAA,CAAA,iBAA5B,EAA+C,MAAM,IAAI,IAAI,CAAC,sBAAT,CAAgC,SAAhC,EAA2C,OAA3C,CAAN;AAC/C,SAAK,SAAL,GAAiB,SAAjB;AACD;;AAEkB,SAAN,MAAM,CAAC,MAAD,EAAe;;AAChC,UAAI,MAAM,CAAC,QAAP,KAAoB,OAAA,CAAA,SAAxB,EAAmC,OAAO,IAAP;AACnC,aAAO,IAAI,iBAAJ,CAAsB,MAAtB,CAAP;AACD,K;AAAA;;AAEK,EAAA,WAAW,GAAA;;AACf,aAAO,KAAK,SAAL,CAAe,YAAtB;AACD,K;AAAA;;AAEK,EAAA,QAAQ,GAAA;;AACZ,aAAO,KAAK,SAAL,CAAe,MAAtB;AACD,K;AAAA;;AAEK,EAAA,OAAO,GAAA;;AACX,YAAM,KAAK,SAAL,CAAe,IAAf,EAAN;AACA,UAAI,KAAK,SAAL,CAAe,aAAf,KAAiC,IAArC,EAA2C,MAAM,KAAK,SAAL,CAAe,mBAAf,CAAmC,CAAnC,CAAN;;AAE3C,UAAI;AACF,cAAM,KAAK,SAAL,CAAe,cAAf,CAA8B,CAA9B,CAAN;AACD,OAFD,CAEE,OAAO,CAAP,EAAU;AACV,QAAA,OAAO,CAAC,KAAR,CAAc,6BAAd,EAA6C,KAAK,SAAlD,EAA6D;AAAE,UAAA;AAAF,SAA7D;AACA,YAAI,CAAC,CAAC,IAAF,KAAW,EAAf,EACE;AACA,gBAAM,IAAI,IAAI,CAAC,sBAAT,CAAgC,SAAhC,EAA2C,OAA3C,CAAN;AACF,YAAI,CAAC,CAAC,IAAF,KAAW,EAAf,EACE;AACA,gBAAM,IAAI,IAAI,CAAC,cAAT,CAAwB,SAAxB,CAAN;AACF,cAAM,CAAN;AACD;AACF,K;AAAA;;AAEK,EAAA,mBAAmB,GAAA;;AACvB;AACA;AACA,UAAI;AACF,cAAM,KAAK,SAAL,CAAe,cAAf,CAA8B,CAA9B,CAAN;AACA,eAAO,IAAP;AACD,OAHD,CAGE,OAAO,CAAP,EAAU;AACV,eAAO,KAAP;AACD;AACF,K;AAAA;;AAEK,EAAA,UAAU,GAAA;;AACd,UAAI,CAAC,KAAK,SAAL,CAAe,MAApB,EAA4B;;AAC5B,UAAI;AACF;AACA,cAAM,KAAK,SAAL,CAAe,KAAf,EAAN;AACD,OAHD,CAGE,OAAO,CAAP,EAAU;AACV,QAAA,OAAO,CAAC,GAAR,CAAY,yCAAZ;AACD;AACF,K;AAAA;;AAEK,EAAA,UAAU,CAAC,GAAD,EAAkB,SAAlB,EAAoC;;AAClD,YAAM,KAAK,SAAL,CAAe,WAAf,CAA2B,SAAS,GAAG,CAAH,GAAO,CAA3C,EAA8C,GAAG,CAAC,MAAJ,CAAW,KAAX,CAAiB,GAAG,CAAC,UAArB,EAAiC,GAAG,CAAC,UAAJ,GAAiB,GAAG,CAAC,UAAtD,CAA9C,CAAN;AACD,K;AAAA;;AAEK,EAAA,SAAS,CAAC,SAAD,EAAmB;;AAChC,YAAM;AAAE,QAAA,MAAF;AAAU,QAAA;AAAV,UAAmB,MAAM,KAAK,SAAL,CAAe,UAAf,CAA0B,SAAS,GAAG,CAAH,GAAO,CAA1C,EAA6C,OAAO,CAAC,YAAR,GAAuB,CAApE,CAA/B;;AAEA,UAAI,MAAM,KAAK,OAAf,EAAwB;AACtB,cAAM,KAAK,SAAL,CAAe,SAAf,CAAyB,KAAzB,EAAgC,SAAS,GAAG,CAAH,GAAO,CAAhD,CAAN;AACD;;AAED,UAAI,IAAI,KAAK,SAAb,EAAwB,MAAM,IAAI,KAAJ,CAAU,UAAV,CAAN;AACxB,aAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,aAAL,CAAmB,IAAnB,CAAf,CAAP;AACD,K;AAAA;;AA1E2B;;AAA9B,OAAA,CAAA,iBAAA,GAAA,iBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransportDelegate = void 0;\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst keepkey = __importStar(require(\"@shapeshiftoss/hdwallet-keepkey\"));\nconst utils_1 = require(\"./utils\");\nclass TransportDelegate {\n    constructor(usbDevice) {\n        if (usbDevice.vendorId !== utils_1.VENDOR_ID)\n            throw new core.WebUSBCouldNotPair(\"KeepKey\", \"bad vendor id\");\n        if (usbDevice.productId !== utils_1.WEBUSB_PRODUCT_ID)\n            throw new core.FirmwareUpdateRequired(\"KeepKey\", \"6.1.0\");\n        this.usbDevice = usbDevice;\n    }\n    static create(device) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (device.vendorId !== utils_1.VENDOR_ID)\n                return null;\n            return new TransportDelegate(device);\n        });\n    }\n    getDeviceID() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.usbDevice.serialNumber;\n        });\n    }\n    isOpened() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.usbDevice.opened;\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.usbDevice.open();\n            if (this.usbDevice.configuration === null)\n                yield this.usbDevice.selectConfiguration(1);\n            try {\n                yield this.usbDevice.claimInterface(0);\n            }\n            catch (e) {\n                console.error(\"Could not claim interface 0\", this.usbDevice, { e });\n                if (e.code === 18)\n                    // \"The requested interface implements a protected class\"\n                    throw new core.FirmwareUpdateRequired(\"KeepKey\", \"6.1.0\");\n                if (e.code === 19)\n                    // \"Unable to claim interface\"\n                    throw new core.ConflictingApp(\"KeepKey\");\n                throw e;\n            }\n        });\n    }\n    tryConnectDebugLink() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // We have to use \"guess & check\" here because the browser doesn't give us a\n            // way to inspect the descriptors :(\n            try {\n                yield this.usbDevice.claimInterface(1);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.usbDevice.opened)\n                return;\n            try {\n                // If the device is disconnected, this will fail and throw, which is fine.\n                yield this.usbDevice.close();\n            }\n            catch (e) {\n                console.log(\"Error closing connection with usbDevice\");\n            }\n        });\n    }\n    writeChunk(buf, debugLink) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.usbDevice.transferOut(debugLink ? 2 : 1, buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n        });\n    }\n    readChunk(debugLink) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { status, data } = yield this.usbDevice.transferIn(debugLink ? 2 : 1, keepkey.SEGMENT_SIZE + 1);\n            if (status === \"stall\") {\n                yield this.usbDevice.clearHalt(\"out\", debugLink ? 2 : 1);\n            }\n            if (data === undefined)\n                throw new Error(\"bad read\");\n            return new Uint8Array(core.toArrayBuffer(data));\n        });\n    }\n}\nexports.TransportDelegate = TransportDelegate;\n//# sourceMappingURL=transport.js.map"]},"metadata":{},"sourceType":"script"}