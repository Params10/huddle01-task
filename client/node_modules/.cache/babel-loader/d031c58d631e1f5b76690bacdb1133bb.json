{"ast":null,"code":"const bitwise = require('bitwise');\n\nconst superagent = require('superagent');\n\nconst bitcoin = require('./bitcoin');\n\nconst ethereum = require('./ethereum');\n\nconst {\n  buildAddAbiPayload,\n  abiParsers,\n  MAX_ABI_DEFS\n} = require('./ethereumAbi');\n\nconst {\n  isValidAssetPath,\n  isValidCoinType,\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  ensureHexBuffer,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  parseLattice1Response,\n  toPaddedDER\n} = require('./util');\n\nconst {\n  getFwVersionConst,\n  ADDR_STR_LEN,\n  ENC_MSG_LEN,\n  decResLengths,\n  deviceCodes,\n  encReqCodes,\n  responseCodes,\n  REQUEST_TYPE_BYTE,\n  VERSION_BYTE,\n  messageConstants,\n  BASE_URL,\n  signingSchema\n} = require('./constants');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst EMPTY_WALLET_UID = Buffer.alloc(32);\n\nclass Client {\n  constructor({\n    baseUrl,\n    crypto,\n    name,\n    privKey,\n    timeout,\n    retryCount\n  } = {}) {\n    // Definitions\n    // if (!baseUrl) throw new Error('baseUrl is required');\n    if (name && name.length > 24) throw new Error('name must be less than 24 characters');\n    if (!crypto) throw new Error('crypto provider is required');\n    this.baseUrl = baseUrl || BASE_URL;\n    this.crypto = crypto;\n    this.name = name || 'Unknown'; // Derive an ECDSA keypair using the p256 curve. The public key will\n    // be used as an identifier\n\n    this.privKey = privKey || this.crypto.randomBytes(32);\n    this.key = getP256KeyPair(this.privKey); //.encode('hex');\n    // Stateful params\n\n    this.ephemeralPub = null;\n    this.sharedSecret = null;\n    this.timeout = timeout || 60000;\n    this.deviceId = null;\n    this.isPaired = false;\n    this.retryCount = retryCount || 3; // Information about the current wallet. Should be null unless we know a wallet is present\n\n    this.activeWallets = {\n      internal: {\n        uid: EMPTY_WALLET_UID,\n        // 32 byte id\n        name: null,\n        // 20 char (max) string\n        capabilities: null,\n        // 4 byte flag\n        external: false\n      },\n      external: {\n        uid: EMPTY_WALLET_UID,\n        // 32 byte id\n        name: null,\n        // 20 char (max) string\n        capabilities: null,\n        // 4 byte flag\n        external: true\n      }\n    };\n  } //=======================================================================\n  // LATTICE FUNCTIONS\n  //=======================================================================\n  // `Connect` will attempt to contact a device based on its deviceId.\n  // The response should include an ephemeral public key, which is used to\n  // pair with the device in a later request\n\n\n  connect(deviceId, cb) {\n    // User may \"re-connect\" if a device ID has previously been stored\n    if (typeof deviceId === 'function') {\n      if (!this.deviceId) return cb('No device ID has been stored. Please connect with your device ID first.');\n      cb = deviceId;\n    } else {\n      // If the user passes in a device ID, connect to that device and save\n      // the new ID for future use.\n      this.deviceId = deviceId;\n    }\n\n    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      this.isPaired = this._handleConnect(res) || false; // Check for an active wallet. This will get bypassed if we are not paired.\n\n      if (this.isPaired) {\n        this._getActiveWallet(err => {\n          return cb(err, this.isPaired);\n        }, true);\n      } else {\n        return cb(null);\n      }\n    });\n  }\n\n  pair(pairingSecret, cb) {\n    // Build the secret hash from the salt\n    const pubKey = this.pubKeyBytes();\n    const nameBuf = Buffer.alloc(25);\n\n    if (this.name.length > 24) {\n      return cb('Name is too many characters. Please change it to <25 characters.');\n    }\n\n    nameBuf.write(this.name); // Make sure we add a null termination byte to the pairing secret\n\n    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);\n    const hash = this.crypto.createHash('sha256').update(preImage).digest();\n    const sig = this.key.sign(hash); // returns an array, not a buffer\n\n    const derSig = toPaddedDER(sig);\n    const payload = Buffer.concat([nameBuf, derSig]); // Build the request\n\n    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err); // Recover the ephemeral key\n\n      const errStr = this._handlePair(res);\n\n      if (errStr) return cb(errStr); // Try to get the active wallet once pairing is successful\n\n      this._getActiveWallet(err => {\n        if (err) return cb(err);\n        return cb(null, this.hasActiveWallet());\n      }, true);\n    });\n  }\n\n  test(data, cb) {\n    if (!data.payload) return cb('First argument must contain `testID` and `payload` fields.');\n    const TEST_DATA_SZ = 500;\n    const payload = Buffer.alloc(TEST_DATA_SZ + 6);\n    payload.writeUInt32BE(data.testID, 0);\n    payload.writeUInt16BE(data.payload.length, 4);\n    data.payload.copy(payload, 6);\n\n    const param = this._buildEncRequest(encReqCodes.TEST, payload);\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n\n      const decrypted = this._handleEncResponse(res, decResLengths.test);\n\n      if (decrypted.err !== null) return cb(decrypted.err);\n      return cb(null, decrypted.data.slice(65)); // remove ephem pub\n    });\n  }\n\n  getAddresses(opts, cb) {\n    const SKIP_CACHE_FLAG = 1;\n    const MAX_ADDR = 10;\n    const {\n      startPath,\n      n,\n      skipCache = true\n    } = opts;\n    if (startPath === undefined || n === undefined) return cb('Please provide `startPath` and `n` options');\n    if (startPath.length < 2 || startPath.length > 5) return cb('Path must include between 2 and 5 indices');\n    if (n > MAX_ADDR) return cb(`You may only request ${MAX_ADDR} addresses at once.`);\n    if (skipCache === false && false === isValidAssetPath(startPath) || skipCache === true && false === isValidCoinType(startPath)) return cb('Parent path is not supported');\n    const fwConstants = getFwVersionConst(this.fwVersion);\n    let sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag\n\n    if (fwConstants.varAddrPathSzAllowed) {\n      sz += 1; // pathDepth\n    } else if (startPath.length !== 5) {\n      return cb('Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.');\n    }\n\n    const payload = Buffer.alloc(sz);\n    let off = 0; // WalletUID\n\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off);\n    off += 32; // Build the start path (5x u32 indices)\n\n    if (fwConstants.varAddrPathSzAllowed) {\n      payload.writeUInt8(startPath.length, off);\n      off += 1;\n    }\n\n    for (let i = 0; i < 5; i++) {\n      if (i <= startPath.length) payload.writeUInt32BE(startPath[i], off);\n      off += 4;\n    } // Specify the number of subsequent addresses to request.\n    // We also allow the user to skip the cache and request any address related to the asset\n    // in the wallet.\n\n\n    let val;\n\n    if (true === fwConstants.addrFlagsAllowed) {\n      const flag = skipCache === true ? bitwise.nibble.read(SKIP_CACHE_FLAG) : bitwise.nibble.read(0);\n      const count = bitwise.nibble.read(n);\n      val = bitwise.byte.write(flag.concat(count));\n    } else {\n      val = n;\n    }\n\n    payload.writeUInt8(val, off);\n    off++;\n\n    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);\n\n    return this._request(param, (err, res) => {\n      if (err) return cb(err);\n\n      const parsedRes = this._handleGetAddresses(res);\n\n      if (parsedRes.err) return cb(parsedRes.err);\n      return cb(null, parsedRes.data);\n    });\n  }\n\n  sign(opts, cb, cachedData = null, nextCode = null) {\n    const {\n      currency\n    } = opts;\n    let {\n      data\n    } = opts;\n\n    if (currency === undefined || data === undefined) {\n      return cb('Please provide `currency` and `data` options');\n    } else if (signReqResolver[currency] === undefined) {\n      return cb('Unsupported currency');\n    } // All transaction requests must be put into the same sized buffer.\n    // This comes from sizeof(GpTransactionRequest_t), but note we remove\n    // the 2-byte schemaId since it is not returned from our resolver.\n    // Note that different firmware versions may have different data sizes.\n\n\n    const fwConstants = getFwVersionConst(this.fwVersion); // Build the signing request payload to send to the device. If we catch\n    // bad params, return an error instead\n\n    data = {\n      fwConstants,\n      ...data\n    };\n    let req, reqPayload;\n    let schema;\n\n    if (cachedData !== null && nextCode !== null) {\n      req = cachedData;\n      reqPayload = Buffer.concat([nextCode, req.extraDataPayloads.shift()]);\n      schema = signingSchema.EXTRA_DATA;\n    } else {\n      req = signReqResolver[currency](data);\n      if (req.err !== undefined) return cb(req.err);\n      if (req.payload.length > fwConstants.reqMaxDataSz) return cb('Transaction is too large');\n      reqPayload = req.payload;\n      schema = req.schema;\n    } // Build the payload\n\n\n    const payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);\n    let off = 0; // Whether there will be follow up requests\n\n    const hasExtraPayloads = req.extraDataPayloads && Number(req.extraDataPayloads.length > 0);\n    payload.writeUInt8(hasExtraPayloads, off);\n    off += 1; // Copy request schema (e.g. ETH or BTC transfer)\n\n    payload.writeUInt8(schema, off);\n    off += 1; // Copy the wallet UID\n\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off);\n    off += wallet.uid.length; // Build data based on the type of request\n    // Copy the payload of the request\n\n    reqPayload.copy(payload, off); // Construct the encrypted request and send it\n\n    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet(err => {\n          if (err) return cb(err);else return this.sign(opts, cb, cachedData, nextCode);\n        });\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else if (hasExtraPayloads) {\n        const decrypted = this._handleEncResponse(res, decResLengths.sign);\n\n        nextCode = decrypted.data.slice(65, 73);\n        if (!cachedData) cachedData = req;\n        return this.sign(opts, cb, cachedData, nextCode);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const parsedRes = this._handleSign(res, currency, req);\n\n        return cb(parsedRes.err, parsedRes.data);\n      }\n    });\n  }\n\n  addAbiDefs(defs, cb, nextCode = null) {\n    const defsToAdd = defs.slice(0, MAX_ABI_DEFS);\n    defs = defs.slice(MAX_ABI_DEFS);\n    let abiPayload;\n\n    try {\n      abiPayload = buildAddAbiPayload(defsToAdd);\n    } catch (err) {\n      return cb(err);\n    }\n\n    const payload = Buffer.alloc(abiPayload.length + 10); // Let the firmware know how many defs are remaining *after this one*.\n    // If this is a positive number, firmware will send us a temporary code\n    // to bypass user authorization if the user has configured easy ABI loading.\n\n    payload.writeUInt16LE(defs.length); // If this is a follow-up request, we don't need to ask for user authorization\n    // if we use the correct temporary u64\n\n    if (nextCode !== null) nextCode.copy(payload, 2);\n    abiPayload.copy(payload, 10);\n\n    const param = this._buildEncRequest(encReqCodes.ADD_ABI_DEFS, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode && responseCode !== responseCodes.RESP_SUCCESS) return cb('Error making request.');else if (err) return cb(err);\n\n      const decrypted = this._handleEncResponse(res, decResLengths.addAbiDefs); // Grab the 8 byte code to fast track our next request, if needed\n\n\n      nextCode = decrypted.data.slice(65, 73); // No defs left? Return success\n\n      if (defs.length === 0) return cb(null); // Add the next set\n\n      this.addAbiDefs(defs, cb, nextCode, defs);\n    });\n  }\n\n  addPermissionV0(opts, cb) {\n    const {\n      currency,\n      timeWindow,\n      limit,\n      decimals,\n      asset\n    } = opts;\n    if (!currency || timeWindow === undefined || limit === undefined || decimals === undefined || timeWindow === null || limit === null || decimals === null) return cb('currency, timeWindow, decimals, and limit are all required options.');else if (timeWindow === 0 || limit === 0) return cb('Time window and spending limit must be positive.'); // Build the name of the permission\n\n    let name = currency;\n    if (asset) name += `_${asset}`; // Start building the payload\n\n    const payload = Buffer.alloc(293); // Copy the name\n\n    if (Buffer.from(name).length > 255) return cb('Asset name too long.');\n    Buffer.from(name).copy(payload, 0); // Convert the limit to a 32 byte hex buffer and copy it in\n\n    const limitBuf = ensureHexBuffer(limit);\n    if (limitBuf.length > 32) return cb('Limit too large.');\n    limitBuf.copy(payload, 256 + (32 - limitBuf.length)); // Copy the time window (seconds)\n\n    payload.writeUInt32BE(timeWindow, 288);\n    payload.writeUInt8(decimals, 292); // Encrypt the request and send it to the Lattice.\n\n    const param = this._buildEncRequest(encReqCodes.ADD_PERMISSION_V0, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet(err => {\n          if (err) return cb(err);else return this.addPermissionV0(opts, cb);\n        });\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const d = this._handleEncResponse(res, decResLengths.finalizePair);\n\n        if (d.err) return cb(d.err);\n        return cb(null);\n      }\n    });\n  } //=======================================================================\n  // INTERNAL FUNCTIONS\n  // These handle the logic around building requests and consuming\n  // responses. They take into account the Lattice's serialization scheme\n  // among other protocols.\n  //=======================================================================\n  // Get the active wallet in the device. If we already have one recorded,\n  // we don't need to do anything\n  // returns cb(err) -- err is a string\n\n\n  _getActiveWallet(cb, forceRefresh = false) {\n    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {\n      // If the active wallet already exists, or if we are not paired, skip the request\n      return cb(null);\n    } else {\n      // No active wallet? Get it from the device\n      const payload = Buffer.alloc(0);\n\n      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);\n\n      return this._request(param, (err, res) => {\n        if (err) {\n          this._resetActiveWallets();\n\n          return cb(err);\n        }\n\n        return cb(this._handleGetWallets(res));\n      });\n    }\n  } // Get the shared secret, derived via ECDH from the local private key\n  // and the ephemeral public key\n  // @returns Buffer\n\n\n  _getSharedSecret() {\n    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which\n    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.\n    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));\n  } // Get the ephemeral id, which is the first 4 bytes of the shared secret\n  // generated from the local private key and the ephemeral public key from\n  // the device.\n  // @returns Buffer\n\n\n  _getEphemId() {\n    if (this.ephemeralPub === null) return null; // EphemId is the first 4 bytes of the hash of the shared secret\n\n    const secret = this._getSharedSecret();\n\n    const hash = this.crypto.createHash('sha256').update(secret).digest();\n    return hash.slice(0, 4);\n  }\n\n  _buildEncRequest(enc_request_code, payload) {\n    // Get the ephemeral id - all encrypted requests require there to be an\n    // epehemeral public key in order to send\n    const ephemId = parseInt(this._getEphemId().toString('hex'), 16); // Build the payload and checksum\n\n    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);\n    const cs = checksum(payloadPreCs);\n    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4); // Lattice validates checksums in little endian\n\n    payloadPreCs.copy(payloadBuf, 0);\n    payloadBuf.writeUInt32LE(cs, payloadPreCs.length); // Encrypt this payload\n\n    const secret = this._getSharedSecret();\n\n    const newEncPayload = aes256_encrypt(payloadBuf, secret); // Write to the overall payload. We must use the same length\n    // for every encrypted request and must include a 32-bit ephemId\n    // along with the encrypted data\n\n    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4); // First 4 bytes are the ephemeral id (in little endian)\n\n    newPayload.writeUInt32LE(ephemId, 0); // Next N bytes\n\n    newEncPayload.copy(newPayload, 4);\n    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);\n  } // Build a request to send to the device.\n  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code\n  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)\n  // @param [payload] {buffer} - serialized payload\n  // @returns {buffer}\n\n\n  _buildRequest(request_code, payload) {\n    // Length of payload;\n    // we add 1 to the payload length to account for the request_code byte\n    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;\n\n    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {\n      L = 1 + payload.length;\n    }\n\n    let i = 0;\n    const preReq = Buffer.alloc(L + 8); // Build the header\n\n    i = preReq.writeUInt8(VERSION_BYTE, i);\n    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);\n    const id = this.crypto.randomBytes(4);\n    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);\n    i = preReq.writeUInt16BE(L, i); // Build the payload\n\n    i = preReq.writeUInt8(request_code, i);\n    if (L > 1) i = payload.copy(preReq, i); // Add the checksum\n\n    const cs = checksum(preReq);\n    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum\n\n    i = preReq.copy(req);\n    req.writeUInt32BE(cs, i);\n    return req;\n  }\n\n  _request(data, cb, retryCount = this.retryCount) {\n    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');\n    const url = `${this.baseUrl}/${this.deviceId}`;\n    superagent.post(url).timeout(this.timeout).send({\n      data\n    }).then(res => {\n      if (!res || !res.body) return cb(`Invalid response: ${res}`);else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`);\n      const parsed = parseLattice1Response(res.body.message); // If the device is busy, retry if we can\n\n      if ((parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY || parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT) && retryCount > 0) {\n        return setTimeout(() => {\n          this._request(data, cb, retryCount - 1);\n        }, 3000);\n      } // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID\n\n\n      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) this._resetActiveWallets(); // If there was an error in the response, return it\n\n      if (parsed.err) return cb(parsed.err);\n      return cb(null, parsed.data, parsed.responseCode);\n    }).catch(err => {\n      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';\n      if (isTimeout) return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.');else return cb('Failed to make request to device.');\n    });\n  } // ----- Device response handlers -----\n  // Connect will call `StartPairingMode` on the device, which gives the\n  // user 60 seconds to finalize the pairing\n  // This will return an ephemeral public key, which is needed for the next\n  // request. If the device is already paired, this ephemPub is simply used\n  // to encrypt the next request. If the device is not paired, it is needed\n  // to pair the device within 60 seconds.\n  // @returns true if we are paired to the device already\n\n\n  _handleConnect(res) {\n    let off = 0;\n    const pairingStatus = res.readUInt8(off);\n    off++; // If we are already paired, we get the next ephemeral key\n\n    const pub = res.slice(off, off + 65).toString('hex');\n    off += 65; // Grab the firmware version (will be 0-length for older fw versions)\n    // It is of format |fix|minor|major|reserved|\n\n    this.fwVersion = res.slice(off, off + 4); // Set the public key\n\n    this.ephemeralPub = getP256KeyPairFromPub(pub); // return the state of our pairing\n\n    return pairingStatus === messageConstants.PAIRED;\n  } // All encrypted responses must be decrypted with the previous shared secret. Per specification,\n  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the \n  // new ephemeralPub.\n\n\n  _handleEncResponse(encRes, len) {\n    // Decrypt response\n    const secret = this._getSharedSecret();\n\n    const encData = encRes.slice(0, ENC_MSG_LEN);\n    const res = aes256_decrypt(encData, secret); // len does not include a 65-byte pubkey that prefies each encResponse\n\n    len += 65; // Validate checksum. It will be the last 4 bytes of the decrypted payload.\n    // The length of the decrypted payload will be fixed for each given message type.\n\n    const toCheck = res.slice(0, len);\n    const cs = parseInt(`0x${res.slice(len, len + 4).toString('hex')}`);\n    const csCheck = checksum(toCheck);\n    if (cs !== csCheck) return {\n      err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})`\n    }; // First 65 bytes is the next ephemeral pubkey\n\n    const pub = res.slice(0, 65).toString('hex');\n\n    try {\n      this.ephemeralPub = getP256KeyPairFromPub(pub);\n      return {\n        err: null,\n        data: res\n      };\n    } catch (e) {\n      return {\n        err: `Error handling getAddresses response: ${e.toString()}`\n      };\n    }\n  } // Pair will create a new pairing if the user successfully enters the secret\n  // into the device in time. If successful (status=0), the device will return\n  // a new ephemeral public key, which is used to derive a shared secret\n  // for the next request\n  // @returns error (or null)\n\n\n  _handlePair(encRes) {\n    const d = this._handleEncResponse(encRes, decResLengths.finalizePair);\n\n    if (d.err) return d.err; // Remove the pairing salt - we're paired!\n\n    this.pairingSalt = null;\n    this.isPaired = true;\n    return null;\n  } // GetAddresses will return an array of address strings\n\n\n  _handleGetAddresses(encRes) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);\n\n    if (decrypted.err !== null) return decrypted;\n    const addrData = decrypted.data;\n    let off = 65; // Skip 65 byte pubkey prefix\n    // Look for addresses until we reach the end (a 4 byte checksum)\n\n    const addrs = [];\n\n    while (off + 4 < decResLengths.getAddresses) {\n      const addrBytes = addrData.slice(off, off + ADDR_STR_LEN);\n      off += ADDR_STR_LEN; // Return the UTF-8 representation\n\n      const len = addrBytes.indexOf(0); // First 0 is the null terminator\n\n      if (len > 0) addrs.push(addrBytes.slice(0, len).toString());\n    }\n\n    return {\n      data: addrs,\n      err: null\n    };\n  }\n\n  _handleGetWallets(encRes) {\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);\n\n    if (decrypted.err !== null) return decrypted;\n    const res = decrypted.data;\n    let walletUID; // Read the external wallet data first. If it is non-null, the external wallet will\n    // be the active wallet of the device and we should save it.\n    // If the external wallet is blank, it means there is no card present and we should \n    // save and use the interal wallet.\n    // If both wallets are empty, it means the device still needs to be set up.\n\n    const walletDescriptorLen = 71; // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name\n\n    let off = 65; // Internal first\n\n    let hasActiveWallet = false;\n    walletUID = res.slice(off, off + 32);\n    this.activeWallets.internal.uid = walletUID;\n    this.activeWallets.internal.capabilities = res.readUInt32BE(off + 32);\n    this.activeWallets.internal.name = res.slice(off + 36, off + walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID)) hasActiveWallet = true; // Offset the first item\n\n    off += walletDescriptorLen; // External\n\n    walletUID = res.slice(off, off + 32);\n    this.activeWallets.external.uid = walletUID;\n    this.activeWallets.external.capabilities = res.readUInt32BE(off + 32);\n    this.activeWallets.external.name = res.slice(off + 36, off + walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID)) hasActiveWallet = true;\n    if (hasActiveWallet === true) return null;else return 'No active wallet.';\n  }\n\n  _handleSign(encRes, currencyType, req = null) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);\n\n    if (decrypted.err !== null) return {\n      err: decrypted.err\n    };\n    const PUBKEY_PREFIX_LEN = 65;\n    const PKH_PREFIX_LEN = 20;\n    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix\n\n    const res = decrypted.data; // Get the change data if we are making a BTC transaction\n\n    let changeRecipient;\n\n    if (currencyType === 'BTC') {\n      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];\n      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN);\n      off += PKH_PREFIX_LEN;\n      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);\n    } // Start building return data\n\n\n    const returnData = {\n      err: null,\n      data: null\n    };\n    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long\n\n    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots\n\n    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;\n\n    if (currencyType === 'BTC') {\n      const compressedPubLength = 33; // Size of compressed public key\n\n      const pubkeys = [];\n      const sigs = [];\n      let n = 0; // Parse the signature for each output -- they are returned\n      // in the serialized payload in form [pubkey, sig]\n      // There is one signature per output\n\n      while (off < res.length) {\n        // Exit out if we have seen all the returned sigs and pubkeys\n        if (res[off] !== 0x30) break; // Otherwise grab another set\n        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also\n        // contain a length at off+1, which we use to parse the non-zero data.\n        // First get the signature from its slot\n\n        const sigStart = off;\n        const sigEnd = off + 2 + res[off + 1];\n        sigs.push(res.slice(sigStart, sigEnd)); // Next, shift by the full set of signatures to hit the respective pubkey\n        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]\n\n        const pubStart = n * compressedPubLength + PUBKEYS_OFFSET;\n        const pubEnd = (n + 1) * compressedPubLength + PUBKEYS_OFFSET;\n        pubkeys.push(res.slice(pubStart, pubEnd)); // Update offset to hit the next signature slot\n\n        off += DERLength;\n        n += 1;\n      } // Build the transaction data to be serialized\n\n\n      const preSerializedData = {\n        inputs: [],\n        outputs: [],\n        spenderScriptType: req.spenderScriptType,\n        network: req.origData.network,\n        crypto: this.crypto\n      }; // First output comes from request dta\n\n      preSerializedData.outputs.push({\n        value: req.origData.value,\n        recipient: req.origData.recipient\n      });\n\n      if (req.changeData.value > 0) {\n        // Second output comes from change data\n        preSerializedData.outputs.push({\n          value: req.changeData.value,\n          recipient: changeRecipient\n        });\n      } // Add the inputs\n\n\n      for (let i = 0; i < sigs.length; i++) {\n        preSerializedData.inputs.push({\n          hash: req.origData.prevOuts[i].txHash,\n          index: req.origData.prevOuts[i].index,\n          sig: sigs[i],\n          pubkey: pubkeys[i]\n        });\n      } // Finally, serialize the transaction\n\n\n      const serializedTx = bitcoin.serializeTx(preSerializedData); // Generate the transaction hash so the user can look this transaction up later\n\n      let preImageTxHash = serializedTx;\n\n      if (preSerializedData.isSegwitSpend === true) {\n        // Segwit transactions need to be re-serialized using legacy serialization\n        // before the transaction hash is calculated. This allows legacy clients\n        // to validate the transactions.\n        preSerializedData.isSegwitSpend = false;\n        preImageTxHash = bitcoin.serializeTx(preSerializedData);\n      }\n\n      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();\n      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex'); // Add extra data for debugging/lookup purposes\n\n      returnData.data = {\n        tx: serializedTx,\n        txHash,\n        changeRecipient,\n        sigs\n      };\n    } else if (currencyType === 'ETH') {\n      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));\n      off += DERLength;\n      const ethAddr = res.slice(off, off + 20); // Determine the `v` param and add it to the sig before returning\n\n      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr, req.useEIP155);\n      returnData.data = {\n        tx: `0x${rawTx}`,\n        txHash: `0x${ethereum.hashTransaction(rawTx)}`,\n        sig: {\n          v: sig.v,\n          r: sig.r.toString('hex'),\n          s: sig.s.toString('hex')\n        },\n        signer: ethAddr\n      };\n    } else if (currencyType === 'ETH_MSG') {\n      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));\n      off += DERLength;\n      const signer = res.slice(off, off + 20);\n      const validatedSig = ethereum.validateEthereumMsgResponse({\n        signer,\n        sig\n      }, req);\n      returnData.data = {\n        sig: {\n          v: validatedSig.v,\n          r: validatedSig.r.toString('hex'),\n          s: validatedSig.s.toString('hex')\n        },\n        signer\n      };\n    }\n\n    return returnData;\n  }\n\n  _resetActiveWallets() {\n    this.activeWallets.internal.uid = EMPTY_WALLET_UID;\n    this.activeWallets.internal.name = null;\n    this.activeWallets.internal.capabilities = null;\n    this.activeWallets.external.uid = EMPTY_WALLET_UID;\n    this.activeWallets.external.name = null;\n    this.activeWallets.external.capabilities = null;\n    return;\n  }\n\n  getActiveWallet() {\n    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {\n      return this.activeWallets.external;\n    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {\n      return this.activeWallets.internal;\n    } else {\n      return null;\n    }\n  }\n\n  hasActiveWallet() {\n    return this.getActiveWallet() !== null;\n  } // Get 64 bytes representing the public key\n  // This is the uncompressed key without the leading 04 byte\n\n\n  pubKeyBytes(LE = false) {\n    const k = this.key.getPublic();\n    const p = k.encode('hex');\n    const pb = Buffer.from(p, 'hex');\n\n    if (LE === true) {\n      // Need to flip X and Y components to little endian\n      const x = pb.slice(1, 33).reverse();\n      const y = pb.slice(33, 65).reverse();\n      return Buffer.concat([pb[0], x, y]);\n    } else {\n      return pb;\n    }\n  } // TODO: Find a better way to export this.\n\n\n  parseAbi(source, data, skipErrors = false) {\n    switch (source) {\n      case 'etherscan':\n        return abiParsers[source](data, skipErrors);\n\n      default:\n        return {\n          err: `No ${source} parser available.`\n        };\n    }\n  }\n\n}\n\nmodule.exports = Client;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/gridplus-sdk/src/client.js"],"names":["bitwise","require","superagent","bitcoin","ethereum","buildAddAbiPayload","abiParsers","MAX_ABI_DEFS","isValidAssetPath","isValidCoinType","signReqResolver","aes256_decrypt","aes256_encrypt","parseDER","checksum","ensureHexBuffer","getP256KeyPair","getP256KeyPairFromPub","parseLattice1Response","toPaddedDER","getFwVersionConst","ADDR_STR_LEN","ENC_MSG_LEN","decResLengths","deviceCodes","encReqCodes","responseCodes","REQUEST_TYPE_BYTE","VERSION_BYTE","messageConstants","BASE_URL","signingSchema","Buffer","EMPTY_WALLET_UID","alloc","Client","constructor","baseUrl","crypto","name","privKey","timeout","retryCount","length","Error","randomBytes","key","ephemeralPub","sharedSecret","deviceId","isPaired","activeWallets","internal","uid","capabilities","external","connect","cb","param","_buildRequest","CONNECT","pubKeyBytes","_request","err","res","_handleConnect","_getActiveWallet","pair","pairingSecret","pubKey","nameBuf","write","preImage","concat","from","hash","createHash","update","digest","sig","sign","derSig","payload","_buildEncRequest","FINALIZE_PAIRING","errStr","_handlePair","hasActiveWallet","test","data","TEST_DATA_SZ","writeUInt32BE","testID","writeUInt16BE","copy","TEST","decrypted","_handleEncResponse","slice","getAddresses","opts","SKIP_CACHE_FLAG","MAX_ADDR","startPath","n","skipCache","undefined","fwConstants","fwVersion","sz","varAddrPathSzAllowed","off","wallet","getActiveWallet","writeUInt8","i","val","addrFlagsAllowed","flag","nibble","read","count","byte","GET_ADDRESSES","parsedRes","_handleGetAddresses","cachedData","nextCode","currency","req","reqPayload","schema","extraDataPayloads","shift","EXTRA_DATA","reqMaxDataSz","hasExtraPayloads","Number","SIGN_TRANSACTION","responseCode","RESP_ERR_WALLET_NOT_PRESENT","_handleSign","addAbiDefs","defs","defsToAdd","abiPayload","writeUInt16LE","ADD_ABI_DEFS","RESP_SUCCESS","addPermissionV0","timeWindow","limit","decimals","asset","limitBuf","ADD_PERMISSION_V0","d","finalizePair","forceRefresh","GET_WALLETS","_resetActiveWallets","_handleGetWallets","_getSharedSecret","derive","getPublic","toArray","_getEphemId","secret","enc_request_code","ephemId","parseInt","toString","payloadPreCs","cs","payloadBuf","writeUInt32LE","newEncPayload","newPayload","ENCRYPTED_REQUEST","request_code","L","isBuffer","preReq","id","url","post","send","then","body","status","message","parsed","RESP_ERR_DEV_BUSY","RESP_ERR_GCE_TIMEOUT","setTimeout","catch","isTimeout","code","errno","pairingStatus","readUInt8","pub","PAIRED","encRes","len","encData","toCheck","csCheck","e","pairingSalt","addrData","addrs","addrBytes","indexOf","push","getWallets","walletUID","walletDescriptorLen","readUInt32BE","equals","currencyType","PUBKEY_PREFIX_LEN","PKH_PREFIX_LEN","changeRecipient","changeVersion","addressVersion","changeData","changePubkeyhash","getBitcoinAddress","returnData","DERLength","SIGS_OFFSET","PUBKEYS_OFFSET","compressedPubLength","pubkeys","sigs","sigStart","sigEnd","pubStart","pubEnd","preSerializedData","inputs","outputs","spenderScriptType","network","origData","value","recipient","prevOuts","txHash","index","pubkey","serializedTx","serializeTx","preImageTxHash","isSegwitSpend","reverse","tx","ethAddr","rawTx","buildEthRawTx","useEIP155","hashTransaction","v","r","s","signer","validatedSig","validateEthereumMsgResponse","LE","k","p","encode","pb","x","y","parseAbi","source","skipErrors","module","exports"],"mappings":"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","sourcesContent":["const bitwise = require('bitwise');\nconst superagent = require('superagent');\nconst bitcoin = require('./bitcoin');\nconst ethereum = require('./ethereum');\nconst { buildAddAbiPayload, abiParsers, MAX_ABI_DEFS } = require('./ethereumAbi');\nconst {\n  isValidAssetPath,\n  isValidCoinType,\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  ensureHexBuffer,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  parseLattice1Response,\n  toPaddedDER,\n} = require('./util');\nconst {\n  getFwVersionConst,\n  ADDR_STR_LEN,\n  ENC_MSG_LEN,\n  decResLengths,\n  deviceCodes,\n  encReqCodes,\n  responseCodes,\n  REQUEST_TYPE_BYTE,\n  VERSION_BYTE,\n  messageConstants,\n  BASE_URL,\n  signingSchema,\n} = require('./constants');\nconst Buffer = require('buffer/').Buffer;\nconst EMPTY_WALLET_UID = Buffer.alloc(32);\n\nclass Client {\n  constructor({ baseUrl, crypto, name, privKey, timeout, retryCount } = {}) {\n    // Definitions\n    // if (!baseUrl) throw new Error('baseUrl is required');\n    if (name && name.length > 24) throw new Error('name must be less than 24 characters');\n    if (!crypto) throw new Error('crypto provider is required');\n    this.baseUrl = baseUrl || BASE_URL;\n    this.crypto = crypto;\n    this.name = name || 'Unknown';\n    \n    // Derive an ECDSA keypair using the p256 curve. The public key will\n    // be used as an identifier\n    this.privKey = privKey || this.crypto.randomBytes(32);\n    this.key = getP256KeyPair(this.privKey);//.encode('hex');\n\n    // Stateful params\n    this.ephemeralPub = null;\n    this.sharedSecret = null;\n    this.timeout = timeout || 60000;\n    this.deviceId = null;\n    this.isPaired = false;\n    this.retryCount = retryCount || 3;\n\n    // Information about the current wallet. Should be null unless we know a wallet is present\n    this.activeWallets = {\n      internal: {\n        uid: EMPTY_WALLET_UID,           // 32 byte id\n        name: null,                      // 20 char (max) string\n        capabilities: null,              // 4 byte flag\n        external: false,\n      },\n      external: {\n        uid: EMPTY_WALLET_UID,           // 32 byte id\n        name: null,                      // 20 char (max) string\n        capabilities: null,              // 4 byte flag\n        external: true,\n      }\n    }\n  }\n  \n  //=======================================================================\n  // LATTICE FUNCTIONS\n  //=======================================================================\n\n  // `Connect` will attempt to contact a device based on its deviceId.\n  // The response should include an ephemeral public key, which is used to\n  // pair with the device in a later request\n  connect(deviceId, cb) {\n    // User may \"re-connect\" if a device ID has previously been stored\n    if (typeof deviceId === 'function') {\n      if (!this.deviceId) \n        return cb('No device ID has been stored. Please connect with your device ID first.')\n      cb = deviceId;\n    } else {\n      // If the user passes in a device ID, connect to that device and save\n      // the new ID for future use.\n      this.deviceId = deviceId;\n    }\n    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      this.isPaired = this._handleConnect(res) || false;\n      // Check for an active wallet. This will get bypassed if we are not paired.\n      if (this.isPaired) {\n        this._getActiveWallet((err) => {\n          return cb(err, this.isPaired);\n        }, true);\n      } else {\n        return cb(null);\n      }\n      \n    });\n  }\n\n  pair(pairingSecret, cb) {\n    // Build the secret hash from the salt\n    const pubKey = this.pubKeyBytes();\n    const nameBuf = Buffer.alloc(25);\n    if (this.name.length > 24) {\n      return cb('Name is too many characters. Please change it to <25 characters.');\n    }\n    nameBuf.write(this.name);\n    // Make sure we add a null termination byte to the pairing secret\n    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);\n    const hash = this.crypto.createHash('sha256').update(preImage).digest();\n    const sig = this.key.sign(hash); // returns an array, not a buffer\n    const derSig = toPaddedDER(sig);\n    const payload = Buffer.concat([nameBuf, derSig]);\n\n    // Build the request\n    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      // Recover the ephemeral key\n      const errStr = this._handlePair(res);\n      if (errStr) return cb(errStr);\n      // Try to get the active wallet once pairing is successful\n      this._getActiveWallet((err) => {\n        if (err) return cb(err);\n        return cb(null, this.hasActiveWallet());\n      }, true);\n    })  \n  }\n\n  test(data, cb) {\n    if (!data.payload)\n      return cb('First argument must contain `testID` and `payload` fields.');\n    const TEST_DATA_SZ = 500;\n    const payload = Buffer.alloc(TEST_DATA_SZ + 6);\n    payload.writeUInt32BE(data.testID, 0);\n    payload.writeUInt16BE(data.payload.length, 4);\n    data.payload.copy(payload, 6);\n    const param = this._buildEncRequest(encReqCodes.TEST, payload);\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      const decrypted = this._handleEncResponse(res, decResLengths.test);\n      if (decrypted.err !== null ) \n        return cb(decrypted.err);\n      return cb(null, decrypted.data.slice(65)); // remove ephem pub\n    })\n  }\n\n  getAddresses(opts, cb) {\n    const SKIP_CACHE_FLAG = 1;\n    const MAX_ADDR = 10;\n    const { startPath, n, skipCache=true } = opts;\n    if (startPath === undefined || n === undefined)\n      return cb('Please provide `startPath` and `n` options');\n    if (startPath.length < 2 || startPath.length > 5)\n      return cb('Path must include between 2 and 5 indices');\n    if (n > MAX_ADDR)\n      return cb(`You may only request ${MAX_ADDR} addresses at once.`);\n\n    if ((skipCache === false && false === isValidAssetPath(startPath)) ||\n        (skipCache === true && false === isValidCoinType(startPath)) )\n      return cb('Parent path is not supported');\n\n    const fwConstants = getFwVersionConst(this.fwVersion);\n    let sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag\n    if (fwConstants.varAddrPathSzAllowed) {\n      sz += 1;  // pathDepth\n    } else if (startPath.length !== 5) {\n      return cb('Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.')\n    }\n    const payload = Buffer.alloc(sz);\n    let off = 0;\n\n    // WalletUID\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off); off += 32;\n    // Build the start path (5x u32 indices)\n    if (fwConstants.varAddrPathSzAllowed) {\n      payload.writeUInt8(startPath.length, off);\n      off += 1;\n    }\n    for (let i = 0; i < 5; i++) {\n      if (i <= startPath.length)\n        payload.writeUInt32BE(startPath[i], off);\n      off += 4;\n    }\n    // Specify the number of subsequent addresses to request.\n    // We also allow the user to skip the cache and request any address related to the asset\n    // in the wallet.\n    let val;\n    if (true === fwConstants.addrFlagsAllowed) {\n      const flag = skipCache === true ? bitwise.nibble.read(SKIP_CACHE_FLAG) : bitwise.nibble.read(0);\n      const count = bitwise.nibble.read(n);\n      val = bitwise.byte.write(flag.concat(count));\n    } else {\n      val = n;\n    }\n    payload.writeUInt8(val, off); off++;\n    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);\n    return this._request(param, (err, res) => {\n      if (err) return cb(err);\n      const parsedRes = this._handleGetAddresses(res);\n      if (parsedRes.err) return cb(parsedRes.err);\n      return cb(null, parsedRes.data);\n    })\n  }\n\n  sign(opts, cb, cachedData=null, nextCode=null) {\n    const { currency } = opts;\n    let { data } = opts;\n    if (currency === undefined || data === undefined) {\n      return cb('Please provide `currency` and `data` options');\n    } else if (signReqResolver[currency] === undefined) {\n      return cb('Unsupported currency');\n    }\n    // All transaction requests must be put into the same sized buffer.\n    // This comes from sizeof(GpTransactionRequest_t), but note we remove\n    // the 2-byte schemaId since it is not returned from our resolver.\n    // Note that different firmware versions may have different data sizes.\n    const fwConstants = getFwVersionConst(this.fwVersion);\n    // Build the signing request payload to send to the device. If we catch\n    // bad params, return an error instead\n    data = { fwConstants, ...data};\n    let req, reqPayload;\n    let schema;\n    if (cachedData !== null && nextCode !== null) {\n      req = cachedData;\n      reqPayload = Buffer.concat([nextCode, req.extraDataPayloads.shift()])\n      schema = signingSchema.EXTRA_DATA;\n    } else {\n      req = signReqResolver[currency](data);\n      if (req.err !== undefined) return cb(req.err);\n      if (req.payload.length > fwConstants.reqMaxDataSz)\n        return cb('Transaction is too large');\n      reqPayload = req.payload;\n      schema = req.schema;\n    }\n\n    // Build the payload\n    const payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);\n    let off = 0;\n    // Whether there will be follow up requests\n    const hasExtraPayloads = req.extraDataPayloads && Number(req.extraDataPayloads.length > 0);\n    payload.writeUInt8(hasExtraPayloads, off); off += 1;  \n    // Copy request schema (e.g. ETH or BTC transfer)\n    payload.writeUInt8(schema, off); off += 1;\n    // Copy the wallet UID\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off); off += wallet.uid.length;\n    // Build data based on the type of request\n    // Copy the payload of the request\n    reqPayload.copy(payload, off);\n    // Construct the encrypted request and send it\n    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet((err) => {\n          if (err) return cb(err)\n          else     return this.sign(opts, cb, cachedData, nextCode);\n        })\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else if (hasExtraPayloads) {\n        const decrypted = this._handleEncResponse(res, decResLengths.sign);\n        nextCode = decrypted.data.slice(65, 73);\n        if (!cachedData)\n          cachedData = req;\n        return this.sign(opts, cb, cachedData, nextCode);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const parsedRes = this._handleSign(res, currency, req);\n        return cb(parsedRes.err, parsedRes.data);\n      }\n    })\n  }\n\n  addAbiDefs(defs, cb, nextCode=null) {\n    const defsToAdd = defs.slice(0, MAX_ABI_DEFS);\n    defs = defs.slice(MAX_ABI_DEFS);\n    let abiPayload;\n    try {\n      abiPayload = buildAddAbiPayload(defsToAdd);\n    } catch (err) {\n      return cb(err);\n    }\n    const payload = Buffer.alloc(abiPayload.length + 10);\n    // Let the firmware know how many defs are remaining *after this one*.\n    // If this is a positive number, firmware will send us a temporary code\n    // to bypass user authorization if the user has configured easy ABI loading.\n    payload.writeUInt16LE(defs.length);\n    // If this is a follow-up request, we don't need to ask for user authorization\n    // if we use the correct temporary u64\n    if (nextCode !== null)\n      nextCode.copy(payload, 2);\n    abiPayload.copy(payload, 10);\n    const param = this._buildEncRequest(encReqCodes.ADD_ABI_DEFS, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode && responseCode !== responseCodes.RESP_SUCCESS)\n        return cb('Error making request.');\n      else if (err)\n        return cb(err);\n      const decrypted = this._handleEncResponse(res, decResLengths.addAbiDefs);\n      // Grab the 8 byte code to fast track our next request, if needed\n      nextCode = decrypted.data.slice(65, 73); \n      // No defs left? Return success\n      if (defs.length === 0)\n        return cb(null);\n      // Add the next set\n      this.addAbiDefs(defs, cb, nextCode, defs);\n    })\n  }\n  \n  addPermissionV0(opts, cb) {\n    const { currency, timeWindow, limit, decimals, asset } = opts;\n    if (!currency || timeWindow === undefined || limit === undefined || decimals === undefined ||\n        timeWindow === null || limit === null || decimals === null)\n      return cb('currency, timeWindow, decimals, and limit are all required options.');\n    else if (timeWindow === 0 || limit === 0)\n      return cb('Time window and spending limit must be positive.');\n    // Build the name of the permission\n    let name = currency;\n    if (asset)\n      name += `_${asset}`;\n    // Start building the payload\n    const payload = Buffer.alloc(293);\n    // Copy the name\n    if (Buffer.from(name).length > 255)\n      return cb('Asset name too long.');\n    Buffer.from(name).copy(payload, 0);\n    // Convert the limit to a 32 byte hex buffer and copy it in\n    const limitBuf = ensureHexBuffer(limit)\n    if (limitBuf.length > 32)\n      return cb('Limit too large.');\n    limitBuf.copy(payload, 256 + (32 - limitBuf.length));\n    // Copy the time window (seconds)\n    payload.writeUInt32BE(timeWindow, 288);\n    payload.writeUInt8(decimals, 292);\n    // Encrypt the request and send it to the Lattice.\n    const param = this._buildEncRequest(encReqCodes.ADD_PERMISSION_V0, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet((err) => {\n          if (err) return cb(err)\n          else     return this.addPermissionV0(opts, cb);\n        })\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const d = this._handleEncResponse(res, decResLengths.finalizePair);\n        if (d.err)\n          return cb(d.err);\n        return cb(null);\n      }\n    })\n  }\n\n  //=======================================================================\n  // INTERNAL FUNCTIONS\n  // These handle the logic around building requests and consuming\n  // responses. They take into account the Lattice's serialization scheme\n  // among other protocols.\n  //=======================================================================\n\n  // Get the active wallet in the device. If we already have one recorded,\n  // we don't need to do anything\n  // returns cb(err) -- err is a string\n  _getActiveWallet(cb, forceRefresh=false) {\n    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {\n      // If the active wallet already exists, or if we are not paired, skip the request\n      return cb(null);\n    } else {\n      // No active wallet? Get it from the device\n      const payload = Buffer.alloc(0);\n      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);\n      return this._request(param, (err, res) => {\n        if (err) {\n          this._resetActiveWallets();\n          return cb(err);\n        }\n        return cb(this._handleGetWallets(res));\n      })\n    }\n  }\n\n  // Get the shared secret, derived via ECDH from the local private key\n  // and the ephemeral public key\n  // @returns Buffer\n  _getSharedSecret() {\n    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which\n    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.\n    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));\n  }\n\n  // Get the ephemeral id, which is the first 4 bytes of the shared secret\n  // generated from the local private key and the ephemeral public key from\n  // the device.\n  // @returns Buffer\n  _getEphemId() {\n    if (this.ephemeralPub === null) return null;\n    // EphemId is the first 4 bytes of the hash of the shared secret\n    const secret = this._getSharedSecret();\n    const hash = this.crypto.createHash('sha256').update(secret).digest();\n    return hash.slice(0, 4);\n  }\n\n  _buildEncRequest(enc_request_code, payload) {\n    // Get the ephemeral id - all encrypted requests require there to be an\n    // epehemeral public key in order to send\n    const ephemId = parseInt(this._getEphemId().toString('hex'), 16)\n    \n    // Build the payload and checksum\n    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);\n    const cs = checksum(payloadPreCs);\n    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4);\n\n    // Lattice validates checksums in little endian\n    payloadPreCs.copy(payloadBuf, 0);\n    payloadBuf.writeUInt32LE(cs, payloadPreCs.length);\n    // Encrypt this payload\n    const secret = this._getSharedSecret();\n    const newEncPayload = aes256_encrypt(payloadBuf, secret);\n\n    // Write to the overall payload. We must use the same length\n    // for every encrypted request and must include a 32-bit ephemId\n    // along with the encrypted data\n    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4);\n    // First 4 bytes are the ephemeral id (in little endian)\n    newPayload.writeUInt32LE(ephemId, 0);\n    // Next N bytes\n    newEncPayload.copy(newPayload, 4);\n    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);\n  \n  }\n\n  // Build a request to send to the device.\n  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code\n  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)\n  // @param [payload] {buffer} - serialized payload\n  // @returns {buffer}\n  _buildRequest(request_code, payload) {\n    // Length of payload;\n    // we add 1 to the payload length to account for the request_code byte\n    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;\n    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {\n      L = 1 + payload.length;\n    }\n    let i = 0;\n    const preReq = Buffer.alloc(L + 8);\n    // Build the header\n    i = preReq.writeUInt8(VERSION_BYTE, i);\n    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);\n    const id = this.crypto.randomBytes(4);\n    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);\n    i = preReq.writeUInt16BE(L, i);\n    // Build the payload\n    i = preReq.writeUInt8(request_code, i);\n    if (L > 1) i = payload.copy(preReq, i);\n    // Add the checksum\n    const cs = checksum(preReq);\n    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum\n    i = preReq.copy(req);\n    req.writeUInt32BE(cs, i);\n    return req;\n  }\n\n  _request(data, cb, retryCount=this.retryCount) {\n    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');\n    const url = `${this.baseUrl}/${this.deviceId}`;\n    superagent.post(url).timeout(this.timeout)\n    .send({data})\n    .then(res => {\n      if (!res || !res.body) return cb(`Invalid response: ${res}`)\n      else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`)\n      const parsed = parseLattice1Response(res.body.message);\n      // If the device is busy, retry if we can\n      if (( parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY ||\n            parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT ) \n            && (retryCount > 0)) {\n        return setTimeout(() => { this._request(data, cb, retryCount-1) }, 3000);\n      }\n      // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID\n      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) \n        this._resetActiveWallets();\n      // If there was an error in the response, return it\n      if (parsed.err) \n        return cb(parsed.err);\n      return cb(null, parsed.data, parsed.responseCode); \n    })\n    .catch((err) => {\n      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';\n      if (isTimeout)\n        return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.')\n      else\n        return cb('Failed to make request to device.');\n    });\n  }\n\n  // ----- Device response handlers -----\n\n  // Connect will call `StartPairingMode` on the device, which gives the\n  // user 60 seconds to finalize the pairing\n  // This will return an ephemeral public key, which is needed for the next\n  // request. If the device is already paired, this ephemPub is simply used\n  // to encrypt the next request. If the device is not paired, it is needed\n  // to pair the device within 60 seconds.\n  // @returns true if we are paired to the device already\n  _handleConnect(res) {\n    let off = 0;\n    const pairingStatus = res.readUInt8(off); off++;\n    // If we are already paired, we get the next ephemeral key\n    const pub = res.slice(off, off + 65).toString('hex'); off += 65;\n    // Grab the firmware version (will be 0-length for older fw versions)\n    // It is of format |fix|minor|major|reserved|\n    this.fwVersion = res.slice(off, off + 4);\n    // Set the public key\n    this.ephemeralPub = getP256KeyPairFromPub(pub);\n    // return the state of our pairing\n    return (pairingStatus === messageConstants.PAIRED);\n  }\n\n  // All encrypted responses must be decrypted with the previous shared secret. Per specification,\n  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the \n  // new ephemeralPub.\n  _handleEncResponse(encRes, len) {\n    // Decrypt response\n    const secret = this._getSharedSecret();\n    const encData = encRes.slice(0, ENC_MSG_LEN);\n    const res = aes256_decrypt(encData, secret);\n    // len does not include a 65-byte pubkey that prefies each encResponse\n    len += 65;\n    // Validate checksum. It will be the last 4 bytes of the decrypted payload.\n    // The length of the decrypted payload will be fixed for each given message type.\n    const toCheck = res.slice(0, len);\n    const cs = parseInt(`0x${res.slice(len, len+4).toString('hex')}`);\n    const csCheck = checksum(toCheck);\n    if (cs !== csCheck) return { err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})` };\n\n    // First 65 bytes is the next ephemeral pubkey\n    const pub = res.slice(0, 65).toString('hex');\n    try {\n      this.ephemeralPub = getP256KeyPairFromPub(pub);\n      return { err: null, data: res };\n    } catch (e) {\n      return { err: `Error handling getAddresses response: ${e.toString()}` };\n    }\n  }\n\n  // Pair will create a new pairing if the user successfully enters the secret\n  // into the device in time. If successful (status=0), the device will return\n  // a new ephemeral public key, which is used to derive a shared secret\n  // for the next request\n  // @returns error (or null)\n  _handlePair(encRes) {\n    const d = this._handleEncResponse(encRes, decResLengths.finalizePair);\n    if (d.err) return d.err;\n    // Remove the pairing salt - we're paired!\n    this.pairingSalt = null;\n    this.isPaired = true;\n    return null;\n  }\n\n  // GetAddresses will return an array of address strings\n  _handleGetAddresses(encRes) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);\n    if (decrypted.err !== null ) return decrypted;\n\n    const addrData = decrypted.data;\n    let off = 65; // Skip 65 byte pubkey prefix\n    // Look for addresses until we reach the end (a 4 byte checksum)\n    const addrs = [];\n    while (off + 4 < decResLengths.getAddresses) {\n      const addrBytes = addrData.slice(off, off+ADDR_STR_LEN); off += ADDR_STR_LEN;\n      // Return the UTF-8 representation\n      const len = addrBytes.indexOf(0); // First 0 is the null terminator\n      if (len > 0)\n        addrs.push(addrBytes.slice(0, len).toString());\n    }\n    return { data: addrs, err: null };\n  }\n\n  _handleGetWallets(encRes) {\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);\n    if (decrypted.err !== null) return decrypted;\n    const res = decrypted.data;\n    let walletUID;\n    // Read the external wallet data first. If it is non-null, the external wallet will\n    // be the active wallet of the device and we should save it.\n    // If the external wallet is blank, it means there is no card present and we should \n    // save and use the interal wallet.\n    // If both wallets are empty, it means the device still needs to be set up.\n    const walletDescriptorLen = 71;\n    // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name\n    let off = 65;\n    // Internal first\n    let hasActiveWallet = false;\n    walletUID = res.slice(off, off+32);\n    this.activeWallets.internal.uid = walletUID;\n    this.activeWallets.internal.capabilities = res.readUInt32BE(off+32);\n    this.activeWallets.internal.name = res.slice(off+36, off+walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID))\n      hasActiveWallet = true;\n\n    // Offset the first item\n    off += walletDescriptorLen;\n    \n    // External\n    walletUID = res.slice(off, off+32);\n    this.activeWallets.external.uid = walletUID;\n    this.activeWallets.external.capabilities = res.readUInt32BE(off+32);\n    this.activeWallets.external.name = res.slice(off+36, off+walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID))\n      hasActiveWallet = true;\n    if (hasActiveWallet === true)\n      return null;\n    else\n      return 'No active wallet.';\n  }\n\n  _handleSign(encRes, currencyType, req=null) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);\n    if (decrypted.err !== null ) return { err: decrypted.err };\n    const PUBKEY_PREFIX_LEN = 65;\n    const PKH_PREFIX_LEN = 20;\n    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix\n    const res = decrypted.data;\n\n    // Get the change data if we are making a BTC transaction\n    let changeRecipient;\n    if (currencyType === 'BTC') {\n      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];\n      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN); off += PKH_PREFIX_LEN;\n      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);\n    }\n    // Start building return data\n    const returnData = { err: null, data: null };\n    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long\n    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots\n    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;\n    \n    if (currencyType === 'BTC') {\n      const compressedPubLength = 33;  // Size of compressed public key\n      const pubkeys = [];\n      const sigs = [];\n      let n = 0;\n      // Parse the signature for each output -- they are returned\n      // in the serialized payload in form [pubkey, sig]\n      // There is one signature per output\n      while (off < res.length) {\n        // Exit out if we have seen all the returned sigs and pubkeys\n        if (res[off] !== 0x30) break;\n        // Otherwise grab another set\n        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also\n        // contain a length at off+1, which we use to parse the non-zero data.\n        // First get the signature from its slot\n        const sigStart = off;\n        const sigEnd = off + 2 + res[off + 1];\n        sigs.push(res.slice(sigStart, sigEnd));\n        // Next, shift by the full set of signatures to hit the respective pubkey\n        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]\n        const pubStart = (n * compressedPubLength) + PUBKEYS_OFFSET;\n        const pubEnd = ((n+1) * compressedPubLength) + PUBKEYS_OFFSET;\n        pubkeys.push(res.slice(pubStart, pubEnd));\n        // Update offset to hit the next signature slot\n        off += DERLength;\n        n += 1;\n      }\n      // Build the transaction data to be serialized\n      const preSerializedData = {\n        inputs: [],\n        outputs: [],\n        spenderScriptType: req.spenderScriptType,\n        network: req.origData.network,\n        crypto: this.crypto,\n      };\n\n      // First output comes from request dta\n      preSerializedData.outputs.push({\n        value: req.origData.value,\n        recipient: req.origData.recipient,\n      });\n      if (req.changeData.value > 0) {\n        // Second output comes from change data\n        preSerializedData.outputs.push({\n          value: req.changeData.value,\n          recipient: changeRecipient,\n        });\n      }\n      \n      // Add the inputs\n      for (let i = 0; i < sigs.length; i++) {\n        preSerializedData.inputs.push({\n          hash: req.origData.prevOuts[i].txHash,\n          index: req.origData.prevOuts[i].index,\n          sig: sigs[i],\n          pubkey: pubkeys[i],\n        });\n      }\n\n      // Finally, serialize the transaction\n      const serializedTx = bitcoin.serializeTx(preSerializedData);\n      // Generate the transaction hash so the user can look this transaction up later\n      let preImageTxHash = serializedTx;\n      if (preSerializedData.isSegwitSpend === true) {\n        // Segwit transactions need to be re-serialized using legacy serialization\n        // before the transaction hash is calculated. This allows legacy clients\n        // to validate the transactions.\n        preSerializedData.isSegwitSpend = false;\n        preImageTxHash = bitcoin.serializeTx(preSerializedData);\n      }  \n      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();\n      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex');\n      \n      // Add extra data for debugging/lookup purposes\n      returnData.data = {\n        tx: serializedTx,\n        txHash,\n        changeRecipient,\n        sigs,\n      }\n    } else if (currencyType === 'ETH') {\n      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;\n      const ethAddr = res.slice(off, off + 20);\n      // Determine the `v` param and add it to the sig before returning\n      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr, req.useEIP155);\n      returnData.data = {\n        tx: `0x${rawTx}`,\n        txHash: `0x${ethereum.hashTransaction(rawTx)}`,\n        sig: {\n          v: sig.v,\n          r: sig.r.toString('hex'),\n          s: sig.s.toString('hex'),\n        },\n        signer: ethAddr,\n      };\n    } else if (currencyType === 'ETH_MSG') {\n      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;\n      const signer = res.slice(off, off + 20);\n      const validatedSig = ethereum.validateEthereumMsgResponse({ signer, sig }, req);\n      returnData.data = {\n        sig: {\n          v: validatedSig.v,\n          r: validatedSig.r.toString('hex'),\n          s: validatedSig.s.toString('hex'),\n        },\n        signer,\n      }\n    }\n\n    return returnData;\n  }\n\n  _resetActiveWallets() {\n    this.activeWallets.internal.uid = EMPTY_WALLET_UID;\n    this.activeWallets.internal.name = null;\n    this.activeWallets.internal.capabilities = null;\n    this.activeWallets.external.uid = EMPTY_WALLET_UID;\n    this.activeWallets.external.name = null;\n    this.activeWallets.external.capabilities = null;\n    return;\n  }\n\n  getActiveWallet() {\n    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {\n      return this.activeWallets.external;\n    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {\n      return this.activeWallets.internal;\n    } else {\n      return null;\n    }\n  }\n\n  hasActiveWallet() {\n    return this.getActiveWallet() !== null;\n  }\n  \n  // Get 64 bytes representing the public key\n  // This is the uncompressed key without the leading 04 byte\n  pubKeyBytes(LE=false) {\n    const k = this.key.getPublic();\n    const p = k.encode('hex');\n    const pb = Buffer.from(p, 'hex');\n    if (LE === true) {\n      // Need to flip X and Y components to little endian\n      const x = pb.slice(1, 33).reverse();\n      const y = pb.slice(33, 65).reverse();\n      return Buffer.concat([pb[0], x, y]);\n    } else {\n      return pb;\n    }\n  }\n\n  // TODO: Find a better way to export this.\n  parseAbi(source, data, skipErrors=false) {\n    switch (source) {\n      case 'etherscan':\n        return abiParsers[source](data, skipErrors);\n      default:\n        return { err: `No ${source} parser available.` };\n\n    }\n  }\n}\n\nmodule.exports = Client;\n"]},"metadata":{},"sourceType":"script"}