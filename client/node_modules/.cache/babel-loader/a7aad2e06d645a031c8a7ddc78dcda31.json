{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.thorchainGetAddress = exports.thorchainSignTx = exports.thorchainGetAccountPaths = void 0;\n\nconst ThorchainMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-thorchain_pb\"));\n\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\n\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\n\nconst lodash_1 = __importDefault(require(\"lodash\"));\n\nfunction thorchainGetAccountPaths(msg) {\n  return [{\n    addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Thorchain\"), 0x80000000 + msg.accountIdx, 0, 0]\n  }];\n}\n\nexports.thorchainGetAccountPaths = thorchainGetAccountPaths;\n\nfunction thorchainSignTx(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n      const signTx = new ThorchainMessages.ThorchainSignTx();\n      signTx.setAddressNList(msg.addressNList);\n      signTx.setAccountNumber(msg.account_number);\n      signTx.setChainId(msg.chain_id);\n      signTx.setFeeAmount(parseInt(msg.tx.fee.amount[0].amount));\n      signTx.setGas(parseInt(msg.tx.fee.gas));\n      signTx.setSequence(msg.sequence);\n      if (msg.tx.memo !== undefined) signTx.setMemo(msg.tx.memo);\n      signTx.setMsgCount(1);\n      let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_THORCHAINSIGNTX, signTx, core.LONG_TIMEOUT,\n      /*omitLock=*/\n      true);\n      if (resp.message_type === core.Events.FAILURE) throw resp;\n\n      for (let m of msg.tx.msg) {\n        if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_THORCHAINMSGREQUEST) {\n          throw new Error(`THORChain: unexpected response ${resp.message_type}`);\n        }\n\n        let ack;\n\n        if (m.type === \"thorchain/MsgSend\") {\n          if (m.value.amount.length !== 1) {\n            throw new Error(\"THORChain: Multiple amounts per MsgSend not supported\");\n          }\n\n          const denom = m.value.amount[0].denom;\n\n          if (denom !== \"rune\") {\n            throw new Error(\"THORChain: Unsupported denomination: \" + denom);\n          }\n\n          const send = new ThorchainMessages.ThorchainMsgSend();\n          send.setFromAddress(m.value.from_address);\n          send.setToAddress(m.value.to_address);\n          send.setAmount(m.value.amount[0].amount);\n          ack = new ThorchainMessages.ThorchainMsgAck();\n          ack.setSend(send);\n        } else if (m.type === \"thorchain/MsgDeposit\") {\n          if (m.value.coins.length !== 1) {\n            throw new Error(\"THORChain: Multiple amounts per MsgDeposit not supported\");\n          }\n\n          const coinAsset = m.value.coins[0].asset;\n\n          if (coinAsset !== \"THOR.RUNE\") {\n            throw new Error(\"THORChain: Unsupported coin asset: \" + coinAsset);\n          }\n\n          const deposit = new ThorchainMessages.ThorchainMsgDeposit();\n          deposit.setAsset(m.value.coins[0].asset);\n          deposit.setAmount(m.value.coins[0].amount);\n          deposit.setMemo(m.value.memo);\n          deposit.setSigner(m.value.signer);\n          ack = new ThorchainMessages.ThorchainMsgAck();\n          ack.setDeposit(deposit);\n        } else {\n          throw new Error(`THORChain: Message ${m.type} is not yet supported`);\n        }\n\n        resp = yield transport.call(Messages.MessageType.MESSAGETYPE_THORCHAINMSGACK, ack, core.LONG_TIMEOUT,\n        /*omitLock=*/\n        true);\n        if (resp.message_type === core.Events.FAILURE) throw resp;\n      }\n\n      if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_THORCHAINSIGNEDTX) {\n        throw new Error(`THORChain: unexpected response ${resp.message_type}`);\n      }\n\n      const signedTx = resp.proto;\n      const signed = lodash_1.default.cloneDeep(msg.tx);\n      signed.signatures = [{\n        signature: signedTx.getSignature_asB64(),\n        pub_key: {\n          type: \"tendermint/PubKeySecp256k1\",\n          value: signedTx.getPublicKey_asB64()\n        }\n      }];\n      return signed;\n    }));\n  });\n}\n\nexports.thorchainSignTx = thorchainSignTx;\n\nfunction thorchainGetAddress(transport, msg) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const getAddr = new ThorchainMessages.ThorchainGetAddress();\n    getAddr.setAddressNList(msg.addressNList);\n    getAddr.setShowDisplay(msg.showDisplay !== false);\n    if (msg.testnet !== undefined) getAddr.setTestnet(msg.testnet);\n    const response = yield transport.call(Messages.MessageType.MESSAGETYPE_THORCHAINGETADDRESS, getAddr, core.LONG_TIMEOUT);\n    if (response.message_type === core.Events.FAILURE) throw response;\n    const thorchainAddress = response.proto;\n    return core.mustBeDefined(thorchainAddress.getAddress());\n  });\n}\n\nexports.thorchainGetAddress = thorchainGetAddress;","map":{"version":3,"sources":["../src/thorchain.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.thorchainGetAddress = exports.thorchainSignTx = exports.thorchainGetAccountPaths = void 0;\nconst ThorchainMessages = __importStar(require(\"@keepkey/device-protocol/lib/messages-thorchain_pb\"));\nconst Messages = __importStar(require(\"@keepkey/device-protocol/lib/messages_pb\"));\nconst core = __importStar(require(\"@shapeshiftoss/hdwallet-core\"));\nconst lodash_1 = __importDefault(require(\"lodash\"));\nfunction thorchainGetAccountPaths(msg) {\n    return [\n        {\n            addressNList: [0x80000000 + 44, 0x80000000 + core.slip44ByCoin(\"Thorchain\"), 0x80000000 + msg.accountIdx, 0, 0],\n        },\n    ];\n}\nexports.thorchainGetAccountPaths = thorchainGetAccountPaths;\nfunction thorchainSignTx(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return transport.lockDuring(() => __awaiter(this, void 0, void 0, function* () {\n            const signTx = new ThorchainMessages.ThorchainSignTx();\n            signTx.setAddressNList(msg.addressNList);\n            signTx.setAccountNumber(msg.account_number);\n            signTx.setChainId(msg.chain_id);\n            signTx.setFeeAmount(parseInt(msg.tx.fee.amount[0].amount));\n            signTx.setGas(parseInt(msg.tx.fee.gas));\n            signTx.setSequence(msg.sequence);\n            if (msg.tx.memo !== undefined)\n                signTx.setMemo(msg.tx.memo);\n            signTx.setMsgCount(1);\n            let resp = yield transport.call(Messages.MessageType.MESSAGETYPE_THORCHAINSIGNTX, signTx, core.LONG_TIMEOUT, \n            /*omitLock=*/ true);\n            if (resp.message_type === core.Events.FAILURE)\n                throw resp;\n            for (let m of msg.tx.msg) {\n                if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_THORCHAINMSGREQUEST) {\n                    throw new Error(`THORChain: unexpected response ${resp.message_type}`);\n                }\n                let ack;\n                if (m.type === \"thorchain/MsgSend\") {\n                    if (m.value.amount.length !== 1) {\n                        throw new Error(\"THORChain: Multiple amounts per MsgSend not supported\");\n                    }\n                    const denom = m.value.amount[0].denom;\n                    if (denom !== \"rune\") {\n                        throw new Error(\"THORChain: Unsupported denomination: \" + denom);\n                    }\n                    const send = new ThorchainMessages.ThorchainMsgSend();\n                    send.setFromAddress(m.value.from_address);\n                    send.setToAddress(m.value.to_address);\n                    send.setAmount(m.value.amount[0].amount);\n                    ack = new ThorchainMessages.ThorchainMsgAck();\n                    ack.setSend(send);\n                }\n                else if (m.type === \"thorchain/MsgDeposit\") {\n                    if (m.value.coins.length !== 1) {\n                        throw new Error(\"THORChain: Multiple amounts per MsgDeposit not supported\");\n                    }\n                    const coinAsset = m.value.coins[0].asset;\n                    if (coinAsset !== \"THOR.RUNE\") {\n                        throw new Error(\"THORChain: Unsupported coin asset: \" + coinAsset);\n                    }\n                    const deposit = new ThorchainMessages.ThorchainMsgDeposit();\n                    deposit.setAsset(m.value.coins[0].asset);\n                    deposit.setAmount(m.value.coins[0].amount);\n                    deposit.setMemo(m.value.memo);\n                    deposit.setSigner(m.value.signer);\n                    ack = new ThorchainMessages.ThorchainMsgAck();\n                    ack.setDeposit(deposit);\n                }\n                else {\n                    throw new Error(`THORChain: Message ${m.type} is not yet supported`);\n                }\n                resp = yield transport.call(Messages.MessageType.MESSAGETYPE_THORCHAINMSGACK, ack, core.LONG_TIMEOUT, /*omitLock=*/ true);\n                if (resp.message_type === core.Events.FAILURE)\n                    throw resp;\n            }\n            if (resp.message_enum !== Messages.MessageType.MESSAGETYPE_THORCHAINSIGNEDTX) {\n                throw new Error(`THORChain: unexpected response ${resp.message_type}`);\n            }\n            const signedTx = resp.proto;\n            const signed = lodash_1.default.cloneDeep(msg.tx);\n            signed.signatures = [\n                {\n                    signature: signedTx.getSignature_asB64(),\n                    pub_key: {\n                        type: \"tendermint/PubKeySecp256k1\",\n                        value: signedTx.getPublicKey_asB64(),\n                    },\n                },\n            ];\n            return signed;\n        }));\n    });\n}\nexports.thorchainSignTx = thorchainSignTx;\nfunction thorchainGetAddress(transport, msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const getAddr = new ThorchainMessages.ThorchainGetAddress();\n        getAddr.setAddressNList(msg.addressNList);\n        getAddr.setShowDisplay(msg.showDisplay !== false);\n        if (msg.testnet !== undefined)\n            getAddr.setTestnet(msg.testnet);\n        const response = yield transport.call(Messages.MessageType.MESSAGETYPE_THORCHAINGETADDRESS, getAddr, core.LONG_TIMEOUT);\n        if (response.message_type === core.Events.FAILURE)\n            throw response;\n        const thorchainAddress = response.proto;\n        return core.mustBeDefined(thorchainAddress.getAddress());\n    });\n}\nexports.thorchainGetAddress = thorchainGetAddress;\n//# sourceMappingURL=thorchain.js.map"]},"metadata":{},"sourceType":"script"}