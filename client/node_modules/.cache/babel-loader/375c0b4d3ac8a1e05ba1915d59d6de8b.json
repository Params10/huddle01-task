{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\n\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst ur_1 = __importDefault(require(\"./ur\"));\n\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\n\nclass URDecoder {\n  constructor(fountainDecoder = new fountainDecoder_1.default(), type = 'bytes') {\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n\n  static decodeBody(type, message) {\n    const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n    return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n  }\n\n  validatePart(type) {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!utils_1.isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n    return true;\n  }\n\n  static decode(message) {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const body = components[0];\n    return URDecoder.decodeBody(type, body);\n  }\n\n  static parse(message) {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new errors_1.InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/');\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    if (!utils_1.isURType(type)) {\n      throw new errors_1.InvalidTypeError();\n    }\n\n    return [type, components.slice(1)];\n  }\n\n  static parseSequenceComponent(s) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    const seqNum = utils_1.toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new errors_1.InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  receivePart(s) {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s);\n\n    if (!this.validatePart(type)) {\n      return false;\n    } // If this is a single-part UR then we're done\n\n\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0]);\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new errors_1.InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n    const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n    } else if (this.fountainDecoder.isFailure()) {\n      this.error = new errors_1.InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  resultUR() {\n    return this.result ? this.result : new ur_1.default(Buffer.from([]));\n  }\n\n  isComplete() {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  isSuccess() {\n    return !this.error && this.isComplete();\n  }\n\n  isError() {\n    return this.error !== undefined;\n  }\n\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n\n}\n\nexports.default = URDecoder;","map":{"version":3,"sources":["../src/urDecoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\nconst bytewords_1 = __importDefault(require(\"./bytewords\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst ur_1 = __importDefault(require(\"./ur\"));\nconst fountainEncoder_1 = require(\"./fountainEncoder\");\nclass URDecoder {\n    constructor(fountainDecoder = new fountainDecoder_1.default(), type = 'bytes') {\n        this.fountainDecoder = fountainDecoder;\n        this.type = type;\n        assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n        this.expected_type = '';\n    }\n    static decodeBody(type, message) {\n        const cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n        return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n    }\n    validatePart(type) {\n        if (this.expected_type) {\n            return this.expected_type === type;\n        }\n        if (!utils_1.isURType(type)) {\n            return false;\n        }\n        this.expected_type = type;\n        return true;\n    }\n    static decode(message) {\n        const [type, components] = this.parse(message);\n        if (components.length === 0) {\n            throw new errors_1.InvalidPathLengthError();\n        }\n        const body = components[0];\n        return URDecoder.decodeBody(type, body);\n    }\n    static parse(message) {\n        const lowercase = message.toLowerCase();\n        const prefix = lowercase.slice(0, 3);\n        if (prefix !== 'ur:') {\n            throw new errors_1.InvalidSchemeError();\n        }\n        const components = lowercase.slice(3).split('/');\n        const type = components[0];\n        if (components.length < 2) {\n            throw new errors_1.InvalidPathLengthError();\n        }\n        if (!utils_1.isURType(type)) {\n            throw new errors_1.InvalidTypeError();\n        }\n        return [type, components.slice(1)];\n    }\n    static parseSequenceComponent(s) {\n        const components = s.split('-');\n        if (components.length !== 2) {\n            throw new errors_1.InvalidSequenceComponentError();\n        }\n        const seqNum = utils_1.toUint32(Number(components[0]));\n        const seqLength = Number(components[1]);\n        if (seqNum < 1 || seqLength < 1) {\n            throw new errors_1.InvalidSequenceComponentError();\n        }\n        return [seqNum, seqLength];\n    }\n    receivePart(s) {\n        if (this.result !== undefined) {\n            return false;\n        }\n        const [type, components] = URDecoder.parse(s);\n        if (!this.validatePart(type)) {\n            return false;\n        }\n        // If this is a single-part UR then we're done\n        if (components.length === 1) {\n            this.result = URDecoder.decodeBody(type, components[0]);\n            return true;\n        }\n        if (components.length !== 2) {\n            throw new errors_1.InvalidPathLengthError();\n        }\n        const [seq, fragment] = components;\n        const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n        const cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n        const part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n        if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n            return false;\n        }\n        if (!this.fountainDecoder.receivePart(part)) {\n            return false;\n        }\n        if (this.fountainDecoder.isSuccess()) {\n            this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n        }\n        else if (this.fountainDecoder.isFailure()) {\n            this.error = new errors_1.InvalidSchemeError();\n        }\n        return true;\n    }\n    resultUR() {\n        return this.result ? this.result : new ur_1.default(Buffer.from([]));\n    }\n    isComplete() {\n        return this.result && this.result.cbor.length > 0;\n    }\n    isSuccess() {\n        return !this.error && this.isComplete();\n    }\n    isError() {\n        return this.error !== undefined;\n    }\n    resultError() {\n        return this.error ? this.error.message : '';\n    }\n    expectedPartCount() {\n        return this.fountainDecoder.expectedPartCount();\n    }\n    expectedPartIndexes() {\n        return this.fountainDecoder.getExpectedPartIndexes();\n    }\n    receivedPartIndexes() {\n        return this.fountainDecoder.getReceivedPartIndexes();\n    }\n    lastPartIndexes() {\n        return this.fountainDecoder.getLastPartIndexes();\n    }\n    estimatedPercentComplete() {\n        return this.fountainDecoder.estimatedPercentComplete();\n    }\n    getProgress() {\n        return this.fountainDecoder.getProgress();\n    }\n}\nexports.default = URDecoder;\n//# sourceMappingURL=urDecoder.js.map"]},"metadata":{},"sourceType":"script"}