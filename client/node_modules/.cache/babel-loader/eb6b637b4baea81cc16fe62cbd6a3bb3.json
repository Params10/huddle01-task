{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\n\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\n\nfunction extractRtpCapabilities({\n  sdpObject\n}) {\n  // Map of RtpCodecParameters indexed by payload type.\n  const codecsMap = new Map(); // Array of RtpHeaderExtensions.\n\n  const headerExtensions = []; // Whether a m=audio/video section has been already found.\n\n  let gotAudio = false;\n  let gotVideo = false;\n\n  for (const m of sdpObject.media) {\n    const kind = m.type;\n\n    switch (kind) {\n      case 'audio':\n        {\n          if (gotAudio) continue;\n          gotAudio = true;\n          break;\n        }\n\n      case 'video':\n        {\n          if (gotVideo) continue;\n          gotVideo = true;\n          break;\n        }\n\n      default:\n        {\n          continue;\n        }\n    } // Get codecs.\n\n\n    for (const rtp of m.rtp) {\n      const codec = {\n        kind: kind,\n        mimeType: `${kind}/${rtp.codec}`,\n        preferredPayloadType: rtp.payload,\n        clockRate: rtp.rate,\n        channels: rtp.encoding,\n        parameters: {},\n        rtcpFeedback: []\n      };\n      codecsMap.set(codec.preferredPayloadType, codec);\n    } // Get codec parameters.\n\n\n    for (const fmtp of m.fmtp || []) {\n      const parameters = sdpTransform.parseParams(fmtp.config);\n      const codec = codecsMap.get(fmtp.payload);\n      if (!codec) continue; // Specials case to convert parameter value to string.\n\n      if (parameters && parameters.hasOwnProperty('profile-level-id')) parameters['profile-level-id'] = String(parameters['profile-level-id']);\n      codec.parameters = parameters;\n    } // Get RTCP feedback for each codec.\n\n\n    for (const fb of m.rtcpFb || []) {\n      const codec = codecsMap.get(fb.payload);\n      if (!codec) continue;\n      const feedback = {\n        type: fb.type,\n        parameter: fb.subtype\n      };\n      if (!feedback.parameter) delete feedback.parameter;\n      codec.rtcpFeedback.push(feedback);\n    } // Get RTP header extensions.\n\n\n    for (const ext of m.ext || []) {\n      // Ignore encrypted extensions (not yet supported in mediasoup).\n      if (ext['encrypt-uri']) continue;\n      const headerExtension = {\n        kind: kind,\n        uri: ext.uri,\n        preferredId: ext.value\n      };\n      headerExtensions.push(headerExtension);\n    }\n  }\n\n  const rtpCapabilities = {\n    codecs: Array.from(codecsMap.values()),\n    headerExtensions: headerExtensions\n  };\n  return rtpCapabilities;\n}\n\nexports.extractRtpCapabilities = extractRtpCapabilities;\n\nfunction extractDtlsParameters({\n  sdpObject\n}) {\n  const mediaObject = (sdpObject.media || []).find(m => m.iceUfrag && m.port !== 0);\n  if (!mediaObject) throw new Error('no active media section found');\n  const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n  let role;\n\n  switch (mediaObject.setup) {\n    case 'active':\n      role = 'client';\n      break;\n\n    case 'passive':\n      role = 'server';\n      break;\n\n    case 'actpass':\n      role = 'auto';\n      break;\n  }\n\n  const dtlsParameters = {\n    role,\n    fingerprints: [{\n      algorithm: fingerprint.type,\n      value: fingerprint.hash\n    }]\n  };\n  return dtlsParameters;\n}\n\nexports.extractDtlsParameters = extractDtlsParameters;\n\nfunction getCname({\n  offerMediaObject\n}) {\n  const ssrcCnameLine = (offerMediaObject.ssrcs || []).find(line => line.attribute === 'cname');\n  if (!ssrcCnameLine) return '';\n  return ssrcCnameLine.value;\n}\n\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\n\nfunction applyCodecParameters({\n  offerRtpParameters,\n  answerMediaObject\n}) {\n  for (const codec of offerRtpParameters.codecs) {\n    const mimeType = codec.mimeType.toLowerCase(); // Avoid parsing codec parameters for unhandled codecs.\n\n    if (mimeType !== 'audio/opus') continue;\n    const rtp = (answerMediaObject.rtp || []).find(r => r.payload === codec.payloadType);\n    if (!rtp) continue; // Just in case.\n\n    answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n    let fmtp = answerMediaObject.fmtp.find(f => f.payload === codec.payloadType);\n\n    if (!fmtp) {\n      fmtp = {\n        payload: codec.payloadType,\n        config: ''\n      };\n      answerMediaObject.fmtp.push(fmtp);\n    }\n\n    const parameters = sdpTransform.parseParams(fmtp.config);\n\n    switch (mimeType) {\n      case 'audio/opus':\n        {\n          const spropStereo = codec.parameters['sprop-stereo'];\n          if (spropStereo !== undefined) parameters.stereo = spropStereo ? 1 : 0;\n          break;\n        }\n    } // Write the codec fmtp.config back.\n\n\n    fmtp.config = '';\n\n    for (const key of Object.keys(parameters)) {\n      if (fmtp.config) fmtp.config += ';';\n      fmtp.config += `${key}=${parameters[key]}`;\n    }\n  }\n}\n\nexports.applyCodecParameters = applyCodecParameters;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","exports","applyCodecParameters","getCname","extractDtlsParameters","extractRtpCapabilities","sdpTransform","require","sdpObject","codecsMap","Map","headerExtensions","gotAudio","gotVideo","media","kind","type","rtp","codec","mimeType","preferredPayloadType","payload","clockRate","rate","channels","encoding","parameters","rtcpFeedback","set","fmtp","parseParams","config","String","fb","rtcpFb","feedback","parameter","subtype","push","ext","headerExtension","uri","preferredId","rtpCapabilities","codecs","Array","from","values","mediaObject","find","iceUfrag","port","Error","fingerprint","role","setup","dtlsParameters","fingerprints","algorithm","hash","offerMediaObject","ssrcCnameLine","ssrcs","line","attribute","offerRtpParameters","answerMediaObject","toLowerCase","r","payloadType","f","spropStereo","stereo","key","keys"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,KAAmCC,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AAC5F,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtBJ,EAAAA,MAAM,CAACO,cAAP,CAAsBL,CAAtB,EAAyBG,EAAzB,EAA6B;AAAEG,IAAAA,UAAU,EAAE,IAAd;AAAoBC,IAAAA,GAAG,EAAE,YAAW;AAAE,aAAON,CAAC,CAACC,CAAD,CAAR;AAAc;AAApD,GAA7B;AACH,CAHwD,GAGnD,UAASF,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AACxB,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtBF,EAAAA,CAAC,CAACG,EAAD,CAAD,GAAQF,CAAC,CAACC,CAAD,CAAT;AACH,CANqB,CAAtB;;AAOA,IAAIM,kBAAkB,GAAI,QAAQ,KAAKA,kBAAd,KAAsCV,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYS,CAAZ,EAAe;AAC3FX,EAAAA,MAAM,CAACO,cAAP,CAAsBL,CAAtB,EAAyB,SAAzB,EAAoC;AAAEM,IAAAA,UAAU,EAAE,IAAd;AAAoBI,IAAAA,KAAK,EAAED;AAA3B,GAApC;AACH,CAF8D,GAE1D,UAAST,CAAT,EAAYS,CAAZ,EAAe;AAChBT,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAeS,CAAf;AACH,CAJwB,CAAzB;;AAKA,IAAIE,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;AAC7D,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B,OAAOD,GAAP;AAC3B,MAAIE,MAAM,GAAG,EAAb;AACA,MAAIF,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIV,CAAT,IAAcU,GAAd,EAAmB,IAAIV,CAAC,KAAK,SAAN,IAAmBJ,MAAM,CAACiB,cAAP,CAAsBC,IAAtB,CAA2BJ,GAA3B,EAAgCV,CAAhC,CAAvB,EAA2DL,eAAe,CAACiB,MAAD,EAASF,GAAT,EAAcV,CAAd,CAAf;;AAC/FM,EAAAA,kBAAkB,CAACM,MAAD,EAASF,GAAT,CAAlB;;AACA,SAAOE,MAAP;AACH,CAND;;AAOAhB,MAAM,CAACO,cAAP,CAAsBY,OAAtB,EAA+B,YAA/B,EAA6C;AAAEP,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAO,OAAO,CAACC,oBAAR,GAA+BD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,qBAAR,GAAgCH,OAAO,CAACI,sBAAR,GAAiC,KAAK,CAAxH;;AACA,MAAMC,YAAY,GAAGX,YAAY,CAACY,OAAO,CAAC,eAAD,CAAR,CAAjC;;AACA,SAASF,sBAAT,CAAgC;AAAEG,EAAAA;AAAF,CAAhC,EAA+C;AAC3C;AACA,QAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB,CAF2C,CAG3C;;AACA,QAAMC,gBAAgB,GAAG,EAAzB,CAJ2C,CAK3C;;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,QAAQ,GAAG,KAAf;;AACA,OAAK,MAAM5B,CAAX,IAAgBuB,SAAS,CAACM,KAA1B,EAAiC;AAC7B,UAAMC,IAAI,GAAG9B,CAAC,CAAC+B,IAAf;;AACA,YAAQD,IAAR;AACI,WAAK,OAAL;AACI;AACI,cAAIH,QAAJ,EACI;AACJA,UAAAA,QAAQ,GAAG,IAAX;AACA;AACH;;AACL,WAAK,OAAL;AACI;AACI,cAAIC,QAAJ,EACI;AACJA,UAAAA,QAAQ,GAAG,IAAX;AACA;AACH;;AACL;AACI;AACI;AACH;AAlBT,KAF6B,CAsB7B;;;AACA,SAAK,MAAMI,GAAX,IAAkBhC,CAAC,CAACgC,GAApB,EAAyB;AACrB,YAAMC,KAAK,GAAG;AACVH,QAAAA,IAAI,EAAEA,IADI;AAEVI,QAAAA,QAAQ,EAAG,GAAEJ,IAAK,IAAGE,GAAG,CAACC,KAAM,EAFrB;AAGVE,QAAAA,oBAAoB,EAAEH,GAAG,CAACI,OAHhB;AAIVC,QAAAA,SAAS,EAAEL,GAAG,CAACM,IAJL;AAKVC,QAAAA,QAAQ,EAAEP,GAAG,CAACQ,QALJ;AAMVC,QAAAA,UAAU,EAAE,EANF;AAOVC,QAAAA,YAAY,EAAE;AAPJ,OAAd;AASAlB,MAAAA,SAAS,CAACmB,GAAV,CAAcV,KAAK,CAACE,oBAApB,EAA0CF,KAA1C;AACH,KAlC4B,CAmC7B;;;AACA,SAAK,MAAMW,IAAX,IAAmB5C,CAAC,CAAC4C,IAAF,IAAU,EAA7B,EAAiC;AAC7B,YAAMH,UAAU,GAAGpB,YAAY,CAACwB,WAAb,CAAyBD,IAAI,CAACE,MAA9B,CAAnB;AACA,YAAMb,KAAK,GAAGT,SAAS,CAAClB,GAAV,CAAcsC,IAAI,CAACR,OAAnB,CAAd;AACA,UAAI,CAACH,KAAL,EACI,SAJyB,CAK7B;;AACA,UAAIQ,UAAU,IAAIA,UAAU,CAAC3B,cAAX,CAA0B,kBAA1B,CAAlB,EACI2B,UAAU,CAAC,kBAAD,CAAV,GAAiCM,MAAM,CAACN,UAAU,CAAC,kBAAD,CAAX,CAAvC;AACJR,MAAAA,KAAK,CAACQ,UAAN,GAAmBA,UAAnB;AACH,KA7C4B,CA8C7B;;;AACA,SAAK,MAAMO,EAAX,IAAiBhD,CAAC,CAACiD,MAAF,IAAY,EAA7B,EAAiC;AAC7B,YAAMhB,KAAK,GAAGT,SAAS,CAAClB,GAAV,CAAc0C,EAAE,CAACZ,OAAjB,CAAd;AACA,UAAI,CAACH,KAAL,EACI;AACJ,YAAMiB,QAAQ,GAAG;AACbnB,QAAAA,IAAI,EAAEiB,EAAE,CAACjB,IADI;AAEboB,QAAAA,SAAS,EAAEH,EAAE,CAACI;AAFD,OAAjB;AAIA,UAAI,CAACF,QAAQ,CAACC,SAAd,EACI,OAAOD,QAAQ,CAACC,SAAhB;AACJlB,MAAAA,KAAK,CAACS,YAAN,CAAmBW,IAAnB,CAAwBH,QAAxB;AACH,KA1D4B,CA2D7B;;;AACA,SAAK,MAAMI,GAAX,IAAkBtD,CAAC,CAACsD,GAAF,IAAS,EAA3B,EAA+B;AAC3B;AACA,UAAIA,GAAG,CAAC,aAAD,CAAP,EACI;AACJ,YAAMC,eAAe,GAAG;AACpBzB,QAAAA,IAAI,EAAEA,IADc;AAEpB0B,QAAAA,GAAG,EAAEF,GAAG,CAACE,GAFW;AAGpBC,QAAAA,WAAW,EAAEH,GAAG,CAAC7C;AAHG,OAAxB;AAKAiB,MAAAA,gBAAgB,CAAC2B,IAAjB,CAAsBE,eAAtB;AACH;AACJ;;AACD,QAAMG,eAAe,GAAG;AACpBC,IAAAA,MAAM,EAAEC,KAAK,CAACC,IAAN,CAAWrC,SAAS,CAACsC,MAAV,EAAX,CADY;AAEpBpC,IAAAA,gBAAgB,EAAEA;AAFE,GAAxB;AAIA,SAAOgC,eAAP;AACH;;AACD1C,OAAO,CAACI,sBAAR,GAAiCA,sBAAjC;;AACA,SAASD,qBAAT,CAA+B;AAAEI,EAAAA;AAAF,CAA/B,EAA8C;AAC1C,QAAMwC,WAAW,GAAG,CAACxC,SAAS,CAACM,KAAV,IAAmB,EAApB,EACfmC,IADe,CACThE,CAAD,IAAQA,CAAC,CAACiE,QAAF,IAAcjE,CAAC,CAACkE,IAAF,KAAW,CADvB,CAApB;AAEA,MAAI,CAACH,WAAL,EACI,MAAM,IAAII,KAAJ,CAAU,+BAAV,CAAN;AACJ,QAAMC,WAAW,GAAGL,WAAW,CAACK,WAAZ,IAA2B7C,SAAS,CAAC6C,WAAzD;AACA,MAAIC,IAAJ;;AACA,UAAQN,WAAW,CAACO,KAApB;AACI,SAAK,QAAL;AACID,MAAAA,IAAI,GAAG,QAAP;AACA;;AACJ,SAAK,SAAL;AACIA,MAAAA,IAAI,GAAG,QAAP;AACA;;AACJ,SAAK,SAAL;AACIA,MAAAA,IAAI,GAAG,MAAP;AACA;AATR;;AAWA,QAAME,cAAc,GAAG;AACnBF,IAAAA,IADmB;AAEnBG,IAAAA,YAAY,EAAE,CACV;AACIC,MAAAA,SAAS,EAAEL,WAAW,CAACrC,IAD3B;AAEItB,MAAAA,KAAK,EAAE2D,WAAW,CAACM;AAFvB,KADU;AAFK,GAAvB;AASA,SAAOH,cAAP;AACH;;AACDvD,OAAO,CAACG,qBAAR,GAAgCA,qBAAhC;;AACA,SAASD,QAAT,CAAkB;AAAEyD,EAAAA;AAAF,CAAlB,EAAwC;AACpC,QAAMC,aAAa,GAAG,CAACD,gBAAgB,CAACE,KAAjB,IAA0B,EAA3B,EACjBb,IADiB,CACXc,IAAD,IAAUA,IAAI,CAACC,SAAL,KAAmB,OADjB,CAAtB;AAEA,MAAI,CAACH,aAAL,EACI,OAAO,EAAP;AACJ,SAAOA,aAAa,CAACnE,KAArB;AACH;;AACDO,OAAO,CAACE,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;;AACA,SAASD,oBAAT,CAA8B;AAAE+D,EAAAA,kBAAF;AAAsBC,EAAAA;AAAtB,CAA9B,EAAyE;AACrE,OAAK,MAAMhD,KAAX,IAAoB+C,kBAAkB,CAACrB,MAAvC,EAA+C;AAC3C,UAAMzB,QAAQ,GAAGD,KAAK,CAACC,QAAN,CAAegD,WAAf,EAAjB,CAD2C,CAE3C;;AACA,QAAIhD,QAAQ,KAAK,YAAjB,EACI;AACJ,UAAMF,GAAG,GAAG,CAACiD,iBAAiB,CAACjD,GAAlB,IAAyB,EAA1B,EACPgC,IADO,CACDmB,CAAD,IAAOA,CAAC,CAAC/C,OAAF,KAAcH,KAAK,CAACmD,WADzB,CAAZ;AAEA,QAAI,CAACpD,GAAL,EACI,SARuC,CAS3C;;AACAiD,IAAAA,iBAAiB,CAACrC,IAAlB,GAAyBqC,iBAAiB,CAACrC,IAAlB,IAA0B,EAAnD;AACA,QAAIA,IAAI,GAAGqC,iBAAiB,CAACrC,IAAlB,CACNoB,IADM,CACAqB,CAAD,IAAOA,CAAC,CAACjD,OAAF,KAAcH,KAAK,CAACmD,WAD1B,CAAX;;AAEA,QAAI,CAACxC,IAAL,EAAW;AACPA,MAAAA,IAAI,GAAG;AAAER,QAAAA,OAAO,EAAEH,KAAK,CAACmD,WAAjB;AAA8BtC,QAAAA,MAAM,EAAE;AAAtC,OAAP;AACAmC,MAAAA,iBAAiB,CAACrC,IAAlB,CAAuBS,IAAvB,CAA4BT,IAA5B;AACH;;AACD,UAAMH,UAAU,GAAGpB,YAAY,CAACwB,WAAb,CAAyBD,IAAI,CAACE,MAA9B,CAAnB;;AACA,YAAQZ,QAAR;AACI,WAAK,YAAL;AACI;AACI,gBAAMoD,WAAW,GAAGrD,KAAK,CAACQ,UAAN,CAAiB,cAAjB,CAApB;AACA,cAAI6C,WAAW,KAAKnF,SAApB,EACIsC,UAAU,CAAC8C,MAAX,GAAoBD,WAAW,GAAG,CAAH,GAAO,CAAtC;AACJ;AACH;AAPT,KAlB2C,CA2B3C;;;AACA1C,IAAAA,IAAI,CAACE,MAAL,GAAc,EAAd;;AACA,SAAK,MAAM0C,GAAX,IAAkB3F,MAAM,CAAC4F,IAAP,CAAYhD,UAAZ,CAAlB,EAA2C;AACvC,UAAIG,IAAI,CAACE,MAAT,EACIF,IAAI,CAACE,MAAL,IAAe,GAAf;AACJF,MAAAA,IAAI,CAACE,MAAL,IAAgB,GAAE0C,GAAI,IAAG/C,UAAU,CAAC+C,GAAD,CAAM,EAAzC;AACH;AACJ;AACJ;;AACDxE,OAAO,CAACC,oBAAR,GAA+BA,oBAA/B","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;\nconst sdpTransform = __importStar(require(\"sdp-transform\"));\nfunction extractRtpCapabilities({ sdpObject }) {\n    // Map of RtpCodecParameters indexed by payload type.\n    const codecsMap = new Map();\n    // Array of RtpHeaderExtensions.\n    const headerExtensions = [];\n    // Whether a m=audio/video section has been already found.\n    let gotAudio = false;\n    let gotVideo = false;\n    for (const m of sdpObject.media) {\n        const kind = m.type;\n        switch (kind) {\n            case 'audio':\n                {\n                    if (gotAudio)\n                        continue;\n                    gotAudio = true;\n                    break;\n                }\n            case 'video':\n                {\n                    if (gotVideo)\n                        continue;\n                    gotVideo = true;\n                    break;\n                }\n            default:\n                {\n                    continue;\n                }\n        }\n        // Get codecs.\n        for (const rtp of m.rtp) {\n            const codec = {\n                kind: kind,\n                mimeType: `${kind}/${rtp.codec}`,\n                preferredPayloadType: rtp.payload,\n                clockRate: rtp.rate,\n                channels: rtp.encoding,\n                parameters: {},\n                rtcpFeedback: []\n            };\n            codecsMap.set(codec.preferredPayloadType, codec);\n        }\n        // Get codec parameters.\n        for (const fmtp of m.fmtp || []) {\n            const parameters = sdpTransform.parseParams(fmtp.config);\n            const codec = codecsMap.get(fmtp.payload);\n            if (!codec)\n                continue;\n            // Specials case to convert parameter value to string.\n            if (parameters && parameters.hasOwnProperty('profile-level-id'))\n                parameters['profile-level-id'] = String(parameters['profile-level-id']);\n            codec.parameters = parameters;\n        }\n        // Get RTCP feedback for each codec.\n        for (const fb of m.rtcpFb || []) {\n            const codec = codecsMap.get(fb.payload);\n            if (!codec)\n                continue;\n            const feedback = {\n                type: fb.type,\n                parameter: fb.subtype\n            };\n            if (!feedback.parameter)\n                delete feedback.parameter;\n            codec.rtcpFeedback.push(feedback);\n        }\n        // Get RTP header extensions.\n        for (const ext of m.ext || []) {\n            // Ignore encrypted extensions (not yet supported in mediasoup).\n            if (ext['encrypt-uri'])\n                continue;\n            const headerExtension = {\n                kind: kind,\n                uri: ext.uri,\n                preferredId: ext.value\n            };\n            headerExtensions.push(headerExtension);\n        }\n    }\n    const rtpCapabilities = {\n        codecs: Array.from(codecsMap.values()),\n        headerExtensions: headerExtensions\n    };\n    return rtpCapabilities;\n}\nexports.extractRtpCapabilities = extractRtpCapabilities;\nfunction extractDtlsParameters({ sdpObject }) {\n    const mediaObject = (sdpObject.media || [])\n        .find((m) => (m.iceUfrag && m.port !== 0));\n    if (!mediaObject)\n        throw new Error('no active media section found');\n    const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;\n    let role;\n    switch (mediaObject.setup) {\n        case 'active':\n            role = 'client';\n            break;\n        case 'passive':\n            role = 'server';\n            break;\n        case 'actpass':\n            role = 'auto';\n            break;\n    }\n    const dtlsParameters = {\n        role,\n        fingerprints: [\n            {\n                algorithm: fingerprint.type,\n                value: fingerprint.hash\n            }\n        ]\n    };\n    return dtlsParameters;\n}\nexports.extractDtlsParameters = extractDtlsParameters;\nfunction getCname({ offerMediaObject }) {\n    const ssrcCnameLine = (offerMediaObject.ssrcs || [])\n        .find((line) => line.attribute === 'cname');\n    if (!ssrcCnameLine)\n        return '';\n    return ssrcCnameLine.value;\n}\nexports.getCname = getCname;\n/**\n * Apply codec parameters in the given SDP m= section answer based on the\n * given RTP parameters of an offer.\n */\nfunction applyCodecParameters({ offerRtpParameters, answerMediaObject }) {\n    for (const codec of offerRtpParameters.codecs) {\n        const mimeType = codec.mimeType.toLowerCase();\n        // Avoid parsing codec parameters for unhandled codecs.\n        if (mimeType !== 'audio/opus')\n            continue;\n        const rtp = (answerMediaObject.rtp || [])\n            .find((r) => r.payload === codec.payloadType);\n        if (!rtp)\n            continue;\n        // Just in case.\n        answerMediaObject.fmtp = answerMediaObject.fmtp || [];\n        let fmtp = answerMediaObject.fmtp\n            .find((f) => f.payload === codec.payloadType);\n        if (!fmtp) {\n            fmtp = { payload: codec.payloadType, config: '' };\n            answerMediaObject.fmtp.push(fmtp);\n        }\n        const parameters = sdpTransform.parseParams(fmtp.config);\n        switch (mimeType) {\n            case 'audio/opus':\n                {\n                    const spropStereo = codec.parameters['sprop-stereo'];\n                    if (spropStereo !== undefined)\n                        parameters.stereo = spropStereo ? 1 : 0;\n                    break;\n                }\n        }\n        // Write the codec fmtp.config back.\n        fmtp.config = '';\n        for (const key of Object.keys(parameters)) {\n            if (fmtp.config)\n                fmtp.config += ';';\n            fmtp.config += `${key}=${parameters[key]}`;\n        }\n    }\n}\nexports.applyCodecParameters = applyCodecParameters;\n"]},"metadata":{},"sourceType":"script"}