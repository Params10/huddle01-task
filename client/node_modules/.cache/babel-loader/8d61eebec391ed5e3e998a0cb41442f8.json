{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compatibleBufferConcat = exports.checkBufferConcat = exports.untouchable = exports.mustBeDefined = exports.toArrayBuffer = exports.relativePath = exports.hardenedPath = exports.satsFromStr = exports.slip44ByCoin = exports.base64toHEX = exports.stripHexPrefixAndLower = exports.stripHexPrefix = exports.takeFirstOfManyEvents = exports.bip32Like = exports.addressNListToBIP32 = exports.bip32ToAddressNList = exports.arrayify = exports.toHexString = exports.fromHexString = exports.isArray = exports.LONG_TIMEOUT = exports.DEFAULT_TIMEOUT = void 0;\n\nconst Rx = __importStar(require(\"rxjs\"));\n\nconst RxOp = __importStar(require(\"rxjs/operators\"));\n\nexports.DEFAULT_TIMEOUT = 5000; // 5 seconds\n\nexports.LONG_TIMEOUT = 5 * 60 * 1000; // 5 minutes\n\nexports.isArray = Array.isArray || function (obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\";\n}; // These helper functions marshal hex into and out of UInt8Arrays which are consumed by protobuf js\n\n\nconst fromHexString = hexString => {\n  const match = hexString.match(/.{1,2}/g) || [];\n  return new Uint8Array(match.map(byte => parseInt(byte, 16)));\n};\n\nexports.fromHexString = fromHexString; // export const toHexString = (bytes: number[]) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')\n\nfunction toHexString(arr) {\n  return Array.prototype.map.call(arr, x => (\"00\" + x.toString(16)).slice(-2)).join(\"\");\n}\n\nexports.toHexString = toHexString; // Copying this from ethers.js until their elliptic dep stops being circular\n\nfunction arrayify(value) {\n  if (value === null) {\n    throw new Error(\"cannot convert null value to array\");\n  } else if (typeof value !== \"string\") {\n    throw new Error(\"can only convert hex strings\");\n  }\n\n  let match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n\n  if (!match) {\n    throw new Error(\"invalid hexadecimal string\");\n  }\n\n  if (match[1] !== \"0x\") {\n    throw new Error(\"hex string must have 0x prefix\");\n  }\n\n  value = value.substring(2);\n\n  if (value.length % 2) {\n    value = \"0\" + value;\n  }\n\n  const result = [];\n\n  for (let i = 0; i < value.length; i += 2) {\n    result.push(parseInt(value.substr(i, 2), 16));\n  }\n\n  return new Uint8Array(result);\n}\n\nexports.arrayify = arrayify;\nconst HARDENED = 0x80000000;\n\nfunction bip32ToAddressNList(path) {\n  if (!bip32Like(path)) {\n    throw new Error(`Not a bip32 path: '${path}'`);\n  }\n\n  if (/^m\\//i.test(path)) {\n    path = path.slice(2);\n  }\n\n  const segments = path.split(\"/\");\n  if (segments.length === 1 && segments[0] === \"\") return [];\n  const ret = new Array(segments.length);\n\n  for (let i = 0; i < segments.length; i++) {\n    const tmp = /(\\d+)([hH\\']?)/.exec(segments[i]);\n\n    if (tmp === null) {\n      throw new Error(\"Invalid input\");\n    }\n\n    ret[i] = parseInt(tmp[1], 10);\n\n    if (ret[i] >= HARDENED) {\n      throw new Error(\"Invalid child index\");\n    }\n\n    if (tmp[2] === \"h\" || tmp[2] === \"H\" || tmp[2] === \"'\") {\n      ret[i] += HARDENED;\n    } else if (tmp[2].length !== 0) {\n      throw new Error(\"Invalid modifier\");\n    }\n  }\n\n  return ret;\n}\n\nexports.bip32ToAddressNList = bip32ToAddressNList;\n\nfunction addressNListToBIP32(address) {\n  return `m/${address.map(num => num >= HARDENED ? `${num - HARDENED}'` : num).join(\"/\")}`;\n}\n\nexports.addressNListToBIP32 = addressNListToBIP32;\n\nfunction bip32Like(path) {\n  if (path == \"m/\") return true;\n  return /^m(((\\/[0-9]+h)+|(\\/[0-9]+H)+|(\\/[0-9]+')*)((\\/[0-9]+)*))$/.test(path);\n}\n\nexports.bip32Like = bip32Like;\n\nfunction takeFirstOfManyEvents(eventEmitter, events) {\n  return Rx.merge(...events.map(event => Rx.fromEvent(eventEmitter, event))).pipe(RxOp.first());\n}\n\nexports.takeFirstOfManyEvents = takeFirstOfManyEvents;\n\nfunction stripHexPrefix(value) {\n  return value.replace(\"0x\", \"\");\n}\n\nexports.stripHexPrefix = stripHexPrefix;\n\nfunction stripHexPrefixAndLower(value) {\n  return stripHexPrefix(value).toLowerCase();\n}\n\nexports.stripHexPrefixAndLower = stripHexPrefixAndLower;\n\nfunction base64toHEX(base64) {\n  var raw = atob(base64);\n  var HEX = \"\";\n\n  for (let i = 0; i < raw.length; i++) {\n    var _hex = raw.charCodeAt(i).toString(16);\n\n    HEX += _hex.length == 2 ? _hex : \"0\" + _hex;\n  }\n\n  return \"0x\" + HEX.toUpperCase();\n}\n\nexports.base64toHEX = base64toHEX; // https://github.com/satoshilabs/slips/blob/master/slip-0044.md\n\nconst slip44Table = Object.freeze({\n  Bitcoin: 0,\n  Testnet: 1,\n  BitcoinCash: 145,\n  BitcoinGold: 156,\n  Litecoin: 2,\n  Dash: 5,\n  DigiByte: 20,\n  Dogecoin: 3,\n  BitcoinSV: 236,\n  Ethereum: 60,\n  Atom: 118,\n  Binance: 714,\n  Ripple: 144,\n  Eos: 194,\n  Fio: 235,\n  Thorchain: 931,\n  Rune: 931,\n  Cardano: 1815,\n  Secret: 529,\n  Terra: 330,\n  Kava: 459\n});\n\nfunction slip44ByCoin(coin) {\n  return slip44Table[coin];\n}\n\nexports.slip44ByCoin = slip44ByCoin;\n\nfunction satsFromStr(coins) {\n  let index = coins.indexOf(\".\");\n  let exponent = index > 0 ? 8 - (coins.length - index - 1) : 8;\n  return Number(coins.replace(/\\./g, \"\")) * 10 ** exponent;\n}\n\nexports.satsFromStr = satsFromStr;\n\nfunction hardenedPath(path) {\n  return path.filter(segment => segment >= 0x80000000);\n}\n\nexports.hardenedPath = hardenedPath;\n\nfunction relativePath(path) {\n  return path.filter(segment => segment < 0x80000000);\n}\n\nexports.relativePath = relativePath;\n\nfunction toArrayBuffer(x) {\n  if (x instanceof ArrayBuffer) return x;\n  return x.buffer.slice(x.byteOffset, x.byteOffset + x.byteLength);\n}\n\nexports.toArrayBuffer = toArrayBuffer;\n\nfunction mustBeDefined(x) {\n  if (x === null || x === undefined) throw new Error(\"expected a value\");\n  return x;\n}\n\nexports.mustBeDefined = mustBeDefined; // Returns a copyable object which satisfies any type constraint but produces a runtime error if\n// accessed in any other way. Useful as dummy data for required parameters. (Probably a bad idea\n// in production.)\n\nfunction untouchable(message) {\n  const out = new Proxy({}, new Proxy({}, {\n    get(_, p) {\n      return (_, p2) => {\n        if (p === \"get\" && p2 === \"valueOf\") return () => out;\n        throw new Error(`${String(p)}(${String(p2)}): ${message}`);\n      };\n    }\n\n  }));\n  return out;\n}\n\nexports.untouchable = untouchable; // Webpack 4's Buffer.concat() polyfill requires Buffer[] instead of Uint8Array[]. This is a\n// kludgy compatibility hack until everything gets bumped to Webpack 5.\n\nlet needCompatibleBufferConcat = undefined;\n\nfunction checkBufferConcat() {\n  if (needCompatibleBufferConcat === undefined) {\n    try {\n      Buffer.concat([new Uint8Array()]);\n      needCompatibleBufferConcat = false;\n    } catch (_a) {\n      needCompatibleBufferConcat = true;\n    }\n  }\n\n  return needCompatibleBufferConcat;\n}\n\nexports.checkBufferConcat = checkBufferConcat;\n\nfunction compatibleBufferConcat(list) {\n  if (!checkBufferConcat()) return Buffer.concat(list);\n  return Buffer.concat(list.map(x => Buffer.isBuffer(x) ? x : Buffer.from(x)));\n}\n\nexports.compatibleBufferConcat = compatibleBufferConcat;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compatibleBufferConcat = exports.checkBufferConcat = exports.untouchable = exports.mustBeDefined = exports.toArrayBuffer = exports.relativePath = exports.hardenedPath = exports.satsFromStr = exports.slip44ByCoin = exports.base64toHEX = exports.stripHexPrefixAndLower = exports.stripHexPrefix = exports.takeFirstOfManyEvents = exports.bip32Like = exports.addressNListToBIP32 = exports.bip32ToAddressNList = exports.arrayify = exports.toHexString = exports.fromHexString = exports.isArray = exports.LONG_TIMEOUT = exports.DEFAULT_TIMEOUT = void 0;\nconst Rx = __importStar(require(\"rxjs\"));\nconst RxOp = __importStar(require(\"rxjs/operators\"));\nexports.DEFAULT_TIMEOUT = 5000; // 5 seconds\nexports.LONG_TIMEOUT = 5 * 60 * 1000; // 5 minutes\nexports.isArray = Array.isArray ||\n    function (obj) {\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\n    };\n// These helper functions marshal hex into and out of UInt8Arrays which are consumed by protobuf js\nconst fromHexString = (hexString) => {\n    const match = hexString.match(/.{1,2}/g) || [];\n    return new Uint8Array(match.map((byte) => parseInt(byte, 16)));\n};\nexports.fromHexString = fromHexString;\n// export const toHexString = (bytes: number[]) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')\nfunction toHexString(arr) {\n    return Array.prototype.map.call(arr, (x) => (\"00\" + x.toString(16)).slice(-2)).join(\"\");\n}\nexports.toHexString = toHexString;\n// Copying this from ethers.js until their elliptic dep stops being circular\nfunction arrayify(value) {\n    if (value === null) {\n        throw new Error(\"cannot convert null value to array\");\n    }\n    else if (typeof value !== \"string\") {\n        throw new Error(\"can only convert hex strings\");\n    }\n    let match = value.match(/^(0x)?[0-9a-fA-F]*$/);\n    if (!match) {\n        throw new Error(\"invalid hexadecimal string\");\n    }\n    if (match[1] !== \"0x\") {\n        throw new Error(\"hex string must have 0x prefix\");\n    }\n    value = value.substring(2);\n    if (value.length % 2) {\n        value = \"0\" + value;\n    }\n    const result = [];\n    for (let i = 0; i < value.length; i += 2) {\n        result.push(parseInt(value.substr(i, 2), 16));\n    }\n    return new Uint8Array(result);\n}\nexports.arrayify = arrayify;\nconst HARDENED = 0x80000000;\nfunction bip32ToAddressNList(path) {\n    if (!bip32Like(path)) {\n        throw new Error(`Not a bip32 path: '${path}'`);\n    }\n    if (/^m\\//i.test(path)) {\n        path = path.slice(2);\n    }\n    const segments = path.split(\"/\");\n    if (segments.length === 1 && segments[0] === \"\")\n        return [];\n    const ret = new Array(segments.length);\n    for (let i = 0; i < segments.length; i++) {\n        const tmp = /(\\d+)([hH\\']?)/.exec(segments[i]);\n        if (tmp === null) {\n            throw new Error(\"Invalid input\");\n        }\n        ret[i] = parseInt(tmp[1], 10);\n        if (ret[i] >= HARDENED) {\n            throw new Error(\"Invalid child index\");\n        }\n        if (tmp[2] === \"h\" || tmp[2] === \"H\" || tmp[2] === \"'\") {\n            ret[i] += HARDENED;\n        }\n        else if (tmp[2].length !== 0) {\n            throw new Error(\"Invalid modifier\");\n        }\n    }\n    return ret;\n}\nexports.bip32ToAddressNList = bip32ToAddressNList;\nfunction addressNListToBIP32(address) {\n    return `m/${address.map((num) => (num >= HARDENED ? `${num - HARDENED}'` : num)).join(\"/\")}`;\n}\nexports.addressNListToBIP32 = addressNListToBIP32;\nfunction bip32Like(path) {\n    if (path == \"m/\")\n        return true;\n    return /^m(((\\/[0-9]+h)+|(\\/[0-9]+H)+|(\\/[0-9]+')*)((\\/[0-9]+)*))$/.test(path);\n}\nexports.bip32Like = bip32Like;\nfunction takeFirstOfManyEvents(eventEmitter, events) {\n    return Rx.merge(...events.map((event) => Rx.fromEvent(eventEmitter, event))).pipe(RxOp.first());\n}\nexports.takeFirstOfManyEvents = takeFirstOfManyEvents;\nfunction stripHexPrefix(value) {\n    return value.replace(\"0x\", \"\");\n}\nexports.stripHexPrefix = stripHexPrefix;\nfunction stripHexPrefixAndLower(value) {\n    return stripHexPrefix(value).toLowerCase();\n}\nexports.stripHexPrefixAndLower = stripHexPrefixAndLower;\nfunction base64toHEX(base64) {\n    var raw = atob(base64);\n    var HEX = \"\";\n    for (let i = 0; i < raw.length; i++) {\n        var _hex = raw.charCodeAt(i).toString(16);\n        HEX += _hex.length == 2 ? _hex : \"0\" + _hex;\n    }\n    return \"0x\" + HEX.toUpperCase();\n}\nexports.base64toHEX = base64toHEX;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst slip44Table = Object.freeze({\n    Bitcoin: 0,\n    Testnet: 1,\n    BitcoinCash: 145,\n    BitcoinGold: 156,\n    Litecoin: 2,\n    Dash: 5,\n    DigiByte: 20,\n    Dogecoin: 3,\n    BitcoinSV: 236,\n    Ethereum: 60,\n    Atom: 118,\n    Binance: 714,\n    Ripple: 144,\n    Eos: 194,\n    Fio: 235,\n    Thorchain: 931,\n    Rune: 931,\n    Cardano: 1815,\n    Secret: 529,\n    Terra: 330,\n    Kava: 459,\n});\nfunction slip44ByCoin(coin) {\n    return slip44Table[coin];\n}\nexports.slip44ByCoin = slip44ByCoin;\nfunction satsFromStr(coins) {\n    let index = coins.indexOf(\".\");\n    let exponent = index > 0 ? 8 - (coins.length - index - 1) : 8;\n    return Number(coins.replace(/\\./g, \"\")) * 10 ** exponent;\n}\nexports.satsFromStr = satsFromStr;\nfunction hardenedPath(path) {\n    return path.filter((segment) => segment >= 0x80000000);\n}\nexports.hardenedPath = hardenedPath;\nfunction relativePath(path) {\n    return path.filter((segment) => segment < 0x80000000);\n}\nexports.relativePath = relativePath;\nfunction toArrayBuffer(x) {\n    if (x instanceof ArrayBuffer)\n        return x;\n    return x.buffer.slice(x.byteOffset, x.byteOffset + x.byteLength);\n}\nexports.toArrayBuffer = toArrayBuffer;\nfunction mustBeDefined(x) {\n    if (x === null || x === undefined)\n        throw new Error(\"expected a value\");\n    return x;\n}\nexports.mustBeDefined = mustBeDefined;\n// Returns a copyable object which satisfies any type constraint but produces a runtime error if\n// accessed in any other way. Useful as dummy data for required parameters. (Probably a bad idea\n// in production.)\nfunction untouchable(message) {\n    const out = new Proxy({}, new Proxy({}, { get(_, p) {\n            return (_, p2) => {\n                if (p === \"get\" && p2 === \"valueOf\")\n                    return () => out;\n                throw new Error(`${String(p)}(${String(p2)}): ${message}`);\n            };\n        } }));\n    return out;\n}\nexports.untouchable = untouchable;\n// Webpack 4's Buffer.concat() polyfill requires Buffer[] instead of Uint8Array[]. This is a\n// kludgy compatibility hack until everything gets bumped to Webpack 5.\nlet needCompatibleBufferConcat = undefined;\nfunction checkBufferConcat() {\n    if (needCompatibleBufferConcat === undefined) {\n        try {\n            Buffer.concat([new Uint8Array()]);\n            needCompatibleBufferConcat = false;\n        }\n        catch (_a) {\n            needCompatibleBufferConcat = true;\n        }\n    }\n    return needCompatibleBufferConcat;\n}\nexports.checkBufferConcat = checkBufferConcat;\nfunction compatibleBufferConcat(list) {\n    if (!checkBufferConcat())\n        return Buffer.concat(list);\n    return Buffer.concat(list.map(x => Buffer.isBuffer(x) ? x : Buffer.from(x)));\n}\nexports.compatibleBufferConcat = compatibleBufferConcat;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}