{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass AwaitQueue {\n  constructor({\n    ClosedErrorClass = Error,\n    StoppedErrorClass = Error\n  } = {\n    ClosedErrorClass: Error,\n    StoppedErrorClass: Error\n  }) {\n    // Closed flag.\n    this.closed = false; // Queue of pending tasks.\n\n    this.pendingTasks = []; // Error class used when rejecting a task due to AwaitQueue being closed.\n\n    this.ClosedErrorClass = Error; // Error class used when rejecting a task due to AwaitQueue being stopped.\n\n    this.StoppedErrorClass = Error;\n    this.ClosedErrorClass = ClosedErrorClass;\n    this.StoppedErrorClass = StoppedErrorClass;\n  }\n  /**\n   * The number of ongoing enqueued tasks.\n   */\n\n\n  get size() {\n    return this.pendingTasks.length;\n  }\n  /**\n   * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass\n   * error.\n   */\n\n\n  close() {\n    if (this.closed) return;\n    this.closed = true;\n\n    for (const pendingTask of this.pendingTasks) {\n      pendingTask.stopped = true;\n      pendingTask.reject(new this.ClosedErrorClass('AwaitQueue closed'));\n    } // Enpty the pending tasks array.\n\n\n    this.pendingTasks.length = 0;\n  }\n  /**\n   * Accepts a task as argument (and an optional task name) and enqueues it after\n   * pending tasks. Once processed, the push() method resolves (or rejects) with\n   * the result returned by the given task.\n   *\n   * The given task must return a Promise or directly a value.\n   */\n\n\n  push(task, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) throw new this.ClosedErrorClass('AwaitQueue closed');\n      if (typeof task !== 'function') throw new TypeError('given task is not a function');\n\n      if (!task.name && name) {\n        try {\n          Object.defineProperty(task, 'name', {\n            value: name\n          });\n        } catch (error) {}\n      }\n\n      return new Promise((resolve, reject) => {\n        const pendingTask = {\n          task,\n          name,\n          resolve,\n          reject,\n          stopped: false,\n          enqueuedAt: new Date(),\n          executedAt: undefined\n        }; // Append task to the queue.\n\n        this.pendingTasks.push(pendingTask); // And run it if this is the only task in the queue.\n\n        if (this.pendingTasks.length === 1) this.next();\n      });\n    });\n  }\n  /**\n   * Make ongoing pending tasks reject with the given StoppedErrorClass error.\n   * The AwaitQueue instance is still usable for future tasks added via push()\n   * method.\n   */\n\n\n  stop() {\n    if (this.closed) return;\n\n    for (const pendingTask of this.pendingTasks) {\n      pendingTask.stopped = true;\n      pendingTask.reject(new this.StoppedErrorClass('AwaitQueue stopped'));\n    } // Enpty the pending tasks array.\n\n\n    this.pendingTasks.length = 0;\n  }\n\n  dump() {\n    const now = new Date();\n    return this.pendingTasks.map(pendingTask => {\n      return {\n        task: pendingTask.task,\n        name: pendingTask.name,\n        enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt.getTime() - pendingTask.enqueuedAt.getTime() : now.getTime() - pendingTask.enqueuedAt.getTime(),\n        executingTime: pendingTask.executedAt ? now.getTime() - pendingTask.executedAt.getTime() : 0\n      };\n    });\n  }\n\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Take the first pending task.\n      const pendingTask = this.pendingTasks[0];\n      if (!pendingTask) return; // Execute it.\n\n      yield this.executeTask(pendingTask); // Remove the first pending task (the completed one) from the queue.\n\n      this.pendingTasks.shift(); // And continue.\n\n      this.next();\n    });\n  }\n\n  executeTask(pendingTask) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // If the task is stopped, ignore it.\n      if (pendingTask.stopped) return;\n      pendingTask.executedAt = new Date();\n\n      try {\n        const result = yield pendingTask.task(); // If the task is stopped, ignore it.\n\n        if (pendingTask.stopped) return; // Resolve the task with the returned result (if any).\n\n        pendingTask.resolve(result);\n      } catch (error) {\n        // If the task is stopped, ignore it.\n        if (pendingTask.stopped) return; // Reject the task with its own error.\n\n        pendingTask.reject(error);\n      }\n    });\n  }\n\n}\n\nexports.AwaitQueue = AwaitQueue;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/awaitqueue/lib/index.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","AwaitQueue","constructor","ClosedErrorClass","Error","StoppedErrorClass","closed","pendingTasks","size","length","close","pendingTask","stopped","push","task","name","TypeError","error","enqueuedAt","Date","executedAt","undefined","stop","dump","now","map","enqueuedTime","getTime","executingTime","executeTask","shift"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AwaitQueue {\n    constructor({ ClosedErrorClass = Error, StoppedErrorClass = Error } = {\n        ClosedErrorClass: Error,\n        StoppedErrorClass: Error\n    }) {\n        // Closed flag.\n        this.closed = false;\n        // Queue of pending tasks.\n        this.pendingTasks = [];\n        // Error class used when rejecting a task due to AwaitQueue being closed.\n        this.ClosedErrorClass = Error;\n        // Error class used when rejecting a task due to AwaitQueue being stopped.\n        this.StoppedErrorClass = Error;\n        this.ClosedErrorClass = ClosedErrorClass;\n        this.StoppedErrorClass = StoppedErrorClass;\n    }\n    /**\n     * The number of ongoing enqueued tasks.\n     */\n    get size() {\n        return this.pendingTasks.length;\n    }\n    /**\n     * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass\n     * error.\n     */\n    close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        for (const pendingTask of this.pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this.ClosedErrorClass('AwaitQueue closed'));\n        }\n        // Enpty the pending tasks array.\n        this.pendingTasks.length = 0;\n    }\n    /**\n     * Accepts a task as argument (and an optional task name) and enqueues it after\n     * pending tasks. Once processed, the push() method resolves (or rejects) with\n     * the result returned by the given task.\n     *\n     * The given task must return a Promise or directly a value.\n     */\n    push(task, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.closed)\n                throw new this.ClosedErrorClass('AwaitQueue closed');\n            if (typeof task !== 'function')\n                throw new TypeError('given task is not a function');\n            if (!task.name && name) {\n                try {\n                    Object.defineProperty(task, 'name', { value: name });\n                }\n                catch (error) { }\n            }\n            return new Promise((resolve, reject) => {\n                const pendingTask = {\n                    task,\n                    name,\n                    resolve,\n                    reject,\n                    stopped: false,\n                    enqueuedAt: new Date(),\n                    executedAt: undefined\n                };\n                // Append task to the queue.\n                this.pendingTasks.push(pendingTask);\n                // And run it if this is the only task in the queue.\n                if (this.pendingTasks.length === 1)\n                    this.next();\n            });\n        });\n    }\n    /**\n     * Make ongoing pending tasks reject with the given StoppedErrorClass error.\n     * The AwaitQueue instance is still usable for future tasks added via push()\n     * method.\n     */\n    stop() {\n        if (this.closed)\n            return;\n        for (const pendingTask of this.pendingTasks) {\n            pendingTask.stopped = true;\n            pendingTask.reject(new this.StoppedErrorClass('AwaitQueue stopped'));\n        }\n        // Enpty the pending tasks array.\n        this.pendingTasks.length = 0;\n    }\n    dump() {\n        const now = new Date();\n        return this.pendingTasks.map((pendingTask) => {\n            return {\n                task: pendingTask.task,\n                name: pendingTask.name,\n                enqueuedTime: pendingTask.executedAt\n                    ? pendingTask.executedAt.getTime() - pendingTask.enqueuedAt.getTime()\n                    : now.getTime() - pendingTask.enqueuedAt.getTime(),\n                executingTime: pendingTask.executedAt\n                    ? now.getTime() - pendingTask.executedAt.getTime()\n                    : 0\n            };\n        });\n    }\n    next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Take the first pending task.\n            const pendingTask = this.pendingTasks[0];\n            if (!pendingTask)\n                return;\n            // Execute it.\n            yield this.executeTask(pendingTask);\n            // Remove the first pending task (the completed one) from the queue.\n            this.pendingTasks.shift();\n            // And continue.\n            this.next();\n        });\n    }\n    executeTask(pendingTask) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If the task is stopped, ignore it.\n            if (pendingTask.stopped)\n                return;\n            pendingTask.executedAt = new Date();\n            try {\n                const result = yield pendingTask.task();\n                // If the task is stopped, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Resolve the task with the returned result (if any).\n                pendingTask.resolve(result);\n            }\n            catch (error) {\n                // If the task is stopped, ignore it.\n                if (pendingTask.stopped)\n                    return;\n                // Reject the task with its own error.\n                pendingTask.reject(error);\n            }\n        });\n    }\n}\nexports.AwaitQueue = AwaitQueue;\n"]},"metadata":{},"sourceType":"script"}