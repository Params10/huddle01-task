{"ast":null,"code":"var createKeccakHash = require('keccak');\n\nfunction encodeInternal(address, parsed, chainId) {\n  checkChainId(chainId);\n  parsed = parsed === undefined ? getHex(address) : parsed;\n  if (parsed === null) throw new TypeError('Bad address');\n  var addressHex = parsed[1].toLowerCase();\n  var forHash = chainId !== undefined ? chainId.toString(10) + '0x' + addressHex : addressHex;\n  var checksum = createKeccakHash('keccak256').update(forHash).digest();\n  var ret = '0x';\n\n  for (var i = 0; i < 20; ++i) {\n    var byte = checksum[i];\n    var ha = addressHex.charAt(i * 2);\n    var hb = addressHex.charAt(i * 2 + 1);\n    ret += (byte & 0xf0) >= 0x80 ? ha.toUpperCase() : ha;\n    ret += (byte & 0x0f) >= 0x08 ? hb.toUpperCase() : hb;\n  }\n\n  return ret;\n}\n\nfunction encode(address, chainId) {\n  return encodeInternal(address, undefined, chainId);\n}\n\nfunction verify(address, allowOneCase, chainId) {\n  checkChainId(chainId);\n  var parsed = getHex(address);\n\n  if (parsed !== null) {\n    if (address.indexOf('0x') !== 0) return false;\n    if (allowOneCase && isOneCase(parsed[1])) return true;\n    return encodeInternal(address, parsed, chainId) === address;\n  }\n\n  return false;\n}\n\nfunction checkChainId(n) {\n  if (n !== undefined && !isPositiveInteger(n)) {\n    throw new TypeError('Bad chainId');\n  }\n}\n\nfunction isPositiveInteger(n) {\n  return (typeof n === 'number' || n instanceof Number) && n > 0 && n + 0 === Math.floor(n);\n}\n\nfunction isOneCase(s) {\n  return s === s.toLowerCase() || s === s.toUpperCase();\n}\n\nfunction isString(data) {\n  return typeof data === 'string' || data instanceof String;\n}\n\nfunction getHex(data) {\n  return isString(data) ? data.match(/^(?:0x)?([0-9a-fA-F]{40})$/) : null;\n}\n\nmodule.exports = {\n  encode,\n  verify\n};","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/eip55/index.js"],"names":["createKeccakHash","require","encodeInternal","address","parsed","chainId","checkChainId","undefined","getHex","TypeError","addressHex","toLowerCase","forHash","toString","checksum","update","digest","ret","i","byte","ha","charAt","hb","toUpperCase","encode","verify","allowOneCase","indexOf","isOneCase","n","isPositiveInteger","Number","Math","floor","s","isString","data","String","match","module","exports"],"mappings":"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","sourcesContent":["var createKeccakHash = require('keccak')\n\nfunction encodeInternal (address, parsed, chainId) {\n  checkChainId(chainId)\n  parsed = parsed === undefined ? getHex(address) : parsed\n  if (parsed === null) throw new TypeError('Bad address')\n\n  var addressHex = parsed[1].toLowerCase()\n  var forHash = chainId !== undefined\n    ? chainId.toString(10) + '0x' + addressHex\n    : addressHex\n  var checksum = createKeccakHash('keccak256')\n    .update(forHash)\n    .digest()\n\n  var ret = '0x'\n  for (var i = 0; i < 20; ++i) {\n    var byte = checksum[i]\n    var ha = addressHex.charAt(i * 2)\n    var hb = addressHex.charAt(i * 2 + 1)\n    ret += (byte & 0xf0) >= 0x80 ? ha.toUpperCase() : ha\n    ret += (byte & 0x0f) >= 0x08 ? hb.toUpperCase() : hb\n  }\n\n  return ret\n}\n\nfunction encode (address, chainId) {\n  return encodeInternal(address, undefined, chainId)\n}\n\nfunction verify (address, allowOneCase, chainId) {\n  checkChainId(chainId)\n  var parsed = getHex(address)\n  if (parsed !== null) {\n    if (address.indexOf('0x') !== 0) return false\n    if (allowOneCase && isOneCase(parsed[1])) return true\n    return encodeInternal(address, parsed, chainId) === address\n  }\n  return false\n}\n\nfunction checkChainId (n) {\n  if (n !== undefined && !isPositiveInteger(n)) {\n    throw new TypeError('Bad chainId')\n  }\n}\n\nfunction isPositiveInteger (n) {\n  return (typeof n === 'number' || n instanceof Number) &&\n    n > 0 &&\n    n + 0 === Math.floor(n)\n}\n\nfunction isOneCase (s) {\n  return s === s.toLowerCase() || s === s.toUpperCase()\n}\n\nfunction isString (data) {\n  return typeof data === 'string' || data instanceof String\n}\n\nfunction getHex (data) {\n  return isString(data) ? data.match(/^(?:0x)?([0-9a-fA-F]{40})$/) : null\n}\n\nmodule.exports = { encode, verify }\n"]},"metadata":{},"sourceType":"script"}