{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bufferXOR = exports.setDifference = exports.arrayContains = exports.arraysEqual = exports.hasPrefix = exports.isURType = exports.intToBytes = exports.toUint32 = exports.getCRCHex = exports.getCRC = exports.split = exports.partition = exports.sha256Hash = void 0;\n\nconst sha_js_1 = __importDefault(require(\"sha.js\"));\n\nconst crc_1 = require(\"crc\");\n\nconst sha256Hash = data => sha_js_1.default('sha256').update(data).digest();\n\nexports.sha256Hash = sha256Hash;\n\nconst partition = (s, n) => s.match(new RegExp('.{1,' + n + '}', 'g')) || [s];\n\nexports.partition = partition;\n\nconst split = (s, length) => [s.slice(0, -length), s.slice(-length)];\n\nexports.split = split;\n\nconst getCRC = message => crc_1.crc32(message);\n\nexports.getCRC = getCRC;\n\nconst getCRCHex = message => crc_1.crc32(message).toString(16).padStart(8, '0');\n\nexports.getCRCHex = getCRCHex;\n\nconst toUint32 = number => number >>> 0;\n\nexports.toUint32 = toUint32;\n\nconst intToBytes = num => {\n  const arr = new ArrayBuffer(4); // an Int32 takes 4 bytes\n\n  const view = new DataView(arr);\n  view.setUint32(0, num, false); // byteOffset = 0; litteEndian = false\n\n  return Buffer.from(arr);\n};\n\nexports.intToBytes = intToBytes;\n\nconst isURType = type => {\n  return type.split('').every((_, index) => {\n    let c = type.charCodeAt(index);\n    if ('a'.charCodeAt(0) <= c && c <= 'z'.charCodeAt(0)) return true;\n    if ('0'.charCodeAt(0) <= c && c <= '9'.charCodeAt(0)) return true;\n    if (c === '-'.charCodeAt(0)) return true;\n    return false;\n  });\n};\n\nexports.isURType = isURType;\n\nconst hasPrefix = (s, prefix) => s.indexOf(prefix) === 0;\n\nexports.hasPrefix = hasPrefix;\n\nconst arraysEqual = (ar1, ar2) => {\n  if (ar1.length !== ar2.length) {\n    return false;\n  }\n\n  return ar1.every(el => ar2.includes(el));\n};\n\nexports.arraysEqual = arraysEqual;\n/**\n * Checks if ar1 contains all elements of ar2\n * @param ar1 the outer array\n * @param ar2 the array to be contained in ar1\n */\n\nconst arrayContains = (ar1, ar2) => {\n  return ar2.every(v => ar1.includes(v));\n};\n\nexports.arrayContains = arrayContains;\n/**\n * Returns the difference array of  `ar1` - `ar2`\n */\n\nconst setDifference = (ar1, ar2) => {\n  return ar1.filter(x => ar2.indexOf(x) < 0);\n};\n\nexports.setDifference = setDifference;\n\nconst bufferXOR = (a, b) => {\n  const length = Math.max(a.length, b.length);\n  const buffer = Buffer.allocUnsafe(length);\n\n  for (let i = 0; i < length; ++i) {\n    buffer[i] = a[i] ^ b[i];\n  }\n\n  return buffer;\n};\n\nexports.bufferXOR = bufferXOR;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bufferXOR = exports.setDifference = exports.arrayContains = exports.arraysEqual = exports.hasPrefix = exports.isURType = exports.intToBytes = exports.toUint32 = exports.getCRCHex = exports.getCRC = exports.split = exports.partition = exports.sha256Hash = void 0;\nconst sha_js_1 = __importDefault(require(\"sha.js\"));\nconst crc_1 = require(\"crc\");\nconst sha256Hash = (data) => sha_js_1.default('sha256').update(data).digest();\nexports.sha256Hash = sha256Hash;\nconst partition = (s, n) => s.match(new RegExp('.{1,' + n + '}', 'g')) || [s];\nexports.partition = partition;\nconst split = (s, length) => [s.slice(0, -length), s.slice(-length)];\nexports.split = split;\nconst getCRC = (message) => crc_1.crc32(message);\nexports.getCRC = getCRC;\nconst getCRCHex = (message) => crc_1.crc32(message).toString(16).padStart(8, '0');\nexports.getCRCHex = getCRCHex;\nconst toUint32 = (number) => number >>> 0;\nexports.toUint32 = toUint32;\nconst intToBytes = (num) => {\n    const arr = new ArrayBuffer(4); // an Int32 takes 4 bytes\n    const view = new DataView(arr);\n    view.setUint32(0, num, false); // byteOffset = 0; litteEndian = false\n    return Buffer.from(arr);\n};\nexports.intToBytes = intToBytes;\nconst isURType = (type) => {\n    return type.split('').every((_, index) => {\n        let c = type.charCodeAt(index);\n        if ('a'.charCodeAt(0) <= c && c <= 'z'.charCodeAt(0))\n            return true;\n        if ('0'.charCodeAt(0) <= c && c <= '9'.charCodeAt(0))\n            return true;\n        if (c === '-'.charCodeAt(0))\n            return true;\n        return false;\n    });\n};\nexports.isURType = isURType;\nconst hasPrefix = (s, prefix) => s.indexOf(prefix) === 0;\nexports.hasPrefix = hasPrefix;\nconst arraysEqual = (ar1, ar2) => {\n    if (ar1.length !== ar2.length) {\n        return false;\n    }\n    return ar1.every(el => ar2.includes(el));\n};\nexports.arraysEqual = arraysEqual;\n/**\n * Checks if ar1 contains all elements of ar2\n * @param ar1 the outer array\n * @param ar2 the array to be contained in ar1\n */\nconst arrayContains = (ar1, ar2) => {\n    return ar2.every(v => ar1.includes(v));\n};\nexports.arrayContains = arrayContains;\n/**\n * Returns the difference array of  `ar1` - `ar2`\n */\nconst setDifference = (ar1, ar2) => {\n    return ar1.filter(x => ar2.indexOf(x) < 0);\n};\nexports.setDifference = setDifference;\nconst bufferXOR = (a, b) => {\n    const length = Math.max(a.length, b.length);\n    const buffer = Buffer.allocUnsafe(length);\n    for (let i = 0; i < length; ++i) {\n        buffer[i] = a[i] ^ b[i];\n    }\n    return buffer;\n};\nexports.bufferXOR = bufferXOR;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}