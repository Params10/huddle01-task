{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Producer = void 0;\n\nconst Logger_1 = require(\"./Logger\");\n\nconst EnhancedEventEmitter_1 = require(\"./EnhancedEventEmitter\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger = new Logger_1.Logger('Producer');\n\nclass Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n  /**\n   * @emits transportclose\n   * @emits trackended\n   * @emits @replacetrack - (track: MediaStreamTrack | null)\n   * @emits @setmaxspatiallayer - (spatialLayer: string)\n   * @emits @setrtpencodingparameters - (params: any)\n   * @emits @getstats\n   * @emits @close\n   */\n  constructor({\n    id,\n    localId,\n    rtpSender,\n    track,\n    rtpParameters,\n    stopTracks,\n    disableTrackOnPause,\n    zeroRtpOnPause,\n    appData\n  }) {\n    super(); // Closed flag.\n\n    this._closed = false; // Observer instance.\n\n    this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n    logger.debug('constructor()');\n    this._id = id;\n    this._localId = localId;\n    this._rtpSender = rtpSender;\n    this._track = track;\n    this._kind = track.kind;\n    this._rtpParameters = rtpParameters;\n    this._paused = disableTrackOnPause ? !track.enabled : false;\n    this._maxSpatialLayer = undefined;\n    this._stopTracks = stopTracks;\n    this._disableTrackOnPause = disableTrackOnPause;\n    this._zeroRtpOnPause = zeroRtpOnPause;\n    this._appData = appData;\n    this._onTrackEnded = this._onTrackEnded.bind(this); // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n    // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n\n    this._handleTrack();\n  }\n  /**\n   * Producer id.\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * Local id.\n   */\n\n\n  get localId() {\n    return this._localId;\n  }\n  /**\n   * Whether the Producer is closed.\n   */\n\n\n  get closed() {\n    return this._closed;\n  }\n  /**\n   * Media kind.\n   */\n\n\n  get kind() {\n    return this._kind;\n  }\n  /**\n   * Associated RTCRtpSender.\n   */\n\n\n  get rtpSender() {\n    return this._rtpSender;\n  }\n  /**\n   * The associated track.\n   */\n\n\n  get track() {\n    return this._track;\n  }\n  /**\n   * RTP parameters.\n   */\n\n\n  get rtpParameters() {\n    return this._rtpParameters;\n  }\n  /**\n   * Whether the Producer is paused.\n   */\n\n\n  get paused() {\n    return this._paused;\n  }\n  /**\n   * Max spatial layer.\n   *\n   * @type {Number | undefined}\n   */\n\n\n  get maxSpatialLayer() {\n    return this._maxSpatialLayer;\n  }\n  /**\n   * App custom data.\n   */\n\n\n  get appData() {\n    return this._appData;\n  }\n  /**\n   * Invalid setter.\n   */\n\n\n  set appData(appData) {\n    throw new Error('cannot override appData object');\n  }\n  /**\n   * Observer.\n   *\n   * @emits close\n   * @emits pause\n   * @emits resume\n   * @emits trackended\n   */\n\n\n  get observer() {\n    return this._observer;\n  }\n  /**\n   * Closes the Producer.\n   */\n\n\n  close() {\n    if (this._closed) return;\n    logger.debug('close()');\n    this._closed = true;\n\n    this._destroyTrack();\n\n    this.emit('@close'); // Emit observer event.\n\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Transport was closed.\n   */\n\n\n  transportClosed() {\n    if (this._closed) return;\n    logger.debug('transportClosed()');\n    this._closed = true;\n\n    this._destroyTrack();\n\n    this.safeEmit('transportclose'); // Emit observer event.\n\n    this._observer.safeEmit('close');\n  }\n  /**\n   * Get associated RTCRtpSender stats.\n   */\n\n\n  async getStats() {\n    if (this._closed) throw new errors_1.InvalidStateError('closed');\n    return this.safeEmitAsPromise('@getstats');\n  }\n  /**\n   * Pauses sending media.\n   */\n\n\n  pause() {\n    logger.debug('pause()');\n\n    if (this._closed) {\n      logger.error('pause() | Producer closed');\n      return;\n    }\n\n    this._paused = true;\n\n    if (this._track && this._disableTrackOnPause) {\n      this._track.enabled = false;\n    }\n\n    if (this._zeroRtpOnPause) {\n      this.safeEmitAsPromise('@replacetrack', null).catch(() => {});\n    } // Emit observer event.\n\n\n    this._observer.safeEmit('pause');\n  }\n  /**\n   * Resumes sending media.\n   */\n\n\n  resume() {\n    logger.debug('resume()');\n\n    if (this._closed) {\n      logger.error('resume() | Producer closed');\n      return;\n    }\n\n    this._paused = false;\n\n    if (this._track && this._disableTrackOnPause) {\n      this._track.enabled = true;\n    }\n\n    if (this._zeroRtpOnPause) {\n      this.safeEmitAsPromise('@replacetrack', this._track).catch(() => {});\n    } // Emit observer event.\n\n\n    this._observer.safeEmit('resume');\n  }\n  /**\n   * Replaces the current track with a new one or null.\n   */\n\n\n  async replaceTrack({\n    track\n  }) {\n    logger.debug('replaceTrack() [track:%o]', track);\n\n    if (this._closed) {\n      // This must be done here. Otherwise there is no chance to stop the given\n      // track.\n      if (track && this._stopTracks) {\n        try {\n          track.stop();\n        } catch (error) {}\n      }\n\n      throw new errors_1.InvalidStateError('closed');\n    } else if (track && track.readyState === 'ended') {\n      throw new errors_1.InvalidStateError('track ended');\n    } // Do nothing if this is the same track as the current handled one.\n\n\n    if (track === this._track) {\n      logger.debug('replaceTrack() | same track, ignored');\n      return;\n    }\n\n    if (!this._zeroRtpOnPause || !this._paused) {\n      await this.safeEmitAsPromise('@replacetrack', track);\n    } // Destroy the previous track.\n\n\n    this._destroyTrack(); // Set the new track.\n\n\n    this._track = track; // If this Producer was paused/resumed and the state of the new\n    // track does not match, fix it.\n\n    if (this._track && this._disableTrackOnPause) {\n      if (!this._paused) this._track.enabled = true;else if (this._paused) this._track.enabled = false;\n    } // Handle the effective track.\n\n\n    this._handleTrack();\n  }\n  /**\n   * Sets the video max spatial layer to be sent.\n   */\n\n\n  async setMaxSpatialLayer(spatialLayer) {\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (this._kind !== 'video') throw new errors_1.UnsupportedError('not a video Producer');else if (typeof spatialLayer !== 'number') throw new TypeError('invalid spatialLayer');\n    if (spatialLayer === this._maxSpatialLayer) return;\n    await this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);\n    this._maxSpatialLayer = spatialLayer;\n  }\n  /**\n   * Sets the DSCP value.\n   */\n\n\n  async setRtpEncodingParameters(params) {\n    if (this._closed) throw new errors_1.InvalidStateError('closed');else if (typeof params !== 'object') throw new TypeError('invalid params');\n    await this.safeEmitAsPromise('@setrtpencodingparameters', params);\n  }\n\n  _onTrackEnded() {\n    logger.debug('track \"ended\" event');\n    this.safeEmit('trackended'); // Emit observer event.\n\n    this._observer.safeEmit('trackended');\n  }\n\n  _handleTrack() {\n    if (!this._track) return;\n\n    this._track.addEventListener('ended', this._onTrackEnded);\n  }\n\n  _destroyTrack() {\n    if (!this._track) return;\n\n    try {\n      this._track.removeEventListener('ended', this._onTrackEnded); // Just stop the track unless the app set stopTracks: false.\n\n\n      if (this._stopTracks) this._track.stop();\n    } catch (error) {}\n  }\n\n}\n\nexports.Producer = Producer;","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/mediasoup-client/lib/Producer.js"],"names":["Object","defineProperty","exports","value","Producer","Logger_1","require","EnhancedEventEmitter_1","errors_1","logger","Logger","EnhancedEventEmitter","constructor","id","localId","rtpSender","track","rtpParameters","stopTracks","disableTrackOnPause","zeroRtpOnPause","appData","_closed","_observer","debug","_id","_localId","_rtpSender","_track","_kind","kind","_rtpParameters","_paused","enabled","_maxSpatialLayer","undefined","_stopTracks","_disableTrackOnPause","_zeroRtpOnPause","_appData","_onTrackEnded","bind","_handleTrack","closed","paused","maxSpatialLayer","Error","observer","close","_destroyTrack","emit","safeEmit","transportClosed","getStats","InvalidStateError","safeEmitAsPromise","pause","error","catch","resume","replaceTrack","stop","readyState","setMaxSpatialLayer","spatialLayer","UnsupportedError","TypeError","setRtpEncodingParameters","params","addEventListener","removeEventListener"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Producer = void 0;\nconst Logger_1 = require(\"./Logger\");\nconst EnhancedEventEmitter_1 = require(\"./EnhancedEventEmitter\");\nconst errors_1 = require(\"./errors\");\nconst logger = new Logger_1.Logger('Producer');\nclass Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {\n    /**\n     * @emits transportclose\n     * @emits trackended\n     * @emits @replacetrack - (track: MediaStreamTrack | null)\n     * @emits @setmaxspatiallayer - (spatialLayer: string)\n     * @emits @setrtpencodingparameters - (params: any)\n     * @emits @getstats\n     * @emits @close\n     */\n    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {\n        super();\n        // Closed flag.\n        this._closed = false;\n        // Observer instance.\n        this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();\n        logger.debug('constructor()');\n        this._id = id;\n        this._localId = localId;\n        this._rtpSender = rtpSender;\n        this._track = track;\n        this._kind = track.kind;\n        this._rtpParameters = rtpParameters;\n        this._paused = disableTrackOnPause ? !track.enabled : false;\n        this._maxSpatialLayer = undefined;\n        this._stopTracks = stopTracks;\n        this._disableTrackOnPause = disableTrackOnPause;\n        this._zeroRtpOnPause = zeroRtpOnPause;\n        this._appData = appData;\n        this._onTrackEnded = this._onTrackEnded.bind(this);\n        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the\n        // '@replacetrack' event here, so RTCRtpSender.track won't be null.\n        this._handleTrack();\n    }\n    /**\n     * Producer id.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Local id.\n     */\n    get localId() {\n        return this._localId;\n    }\n    /**\n     * Whether the Producer is closed.\n     */\n    get closed() {\n        return this._closed;\n    }\n    /**\n     * Media kind.\n     */\n    get kind() {\n        return this._kind;\n    }\n    /**\n     * Associated RTCRtpSender.\n     */\n    get rtpSender() {\n        return this._rtpSender;\n    }\n    /**\n     * The associated track.\n     */\n    get track() {\n        return this._track;\n    }\n    /**\n     * RTP parameters.\n     */\n    get rtpParameters() {\n        return this._rtpParameters;\n    }\n    /**\n     * Whether the Producer is paused.\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Max spatial layer.\n     *\n     * @type {Number | undefined}\n     */\n    get maxSpatialLayer() {\n        return this._maxSpatialLayer;\n    }\n    /**\n     * App custom data.\n     */\n    get appData() {\n        return this._appData;\n    }\n    /**\n     * Invalid setter.\n     */\n    set appData(appData) {\n        throw new Error('cannot override appData object');\n    }\n    /**\n     * Observer.\n     *\n     * @emits close\n     * @emits pause\n     * @emits resume\n     * @emits trackended\n     */\n    get observer() {\n        return this._observer;\n    }\n    /**\n     * Closes the Producer.\n     */\n    close() {\n        if (this._closed)\n            return;\n        logger.debug('close()');\n        this._closed = true;\n        this._destroyTrack();\n        this.emit('@close');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Transport was closed.\n     */\n    transportClosed() {\n        if (this._closed)\n            return;\n        logger.debug('transportClosed()');\n        this._closed = true;\n        this._destroyTrack();\n        this.safeEmit('transportclose');\n        // Emit observer event.\n        this._observer.safeEmit('close');\n    }\n    /**\n     * Get associated RTCRtpSender stats.\n     */\n    async getStats() {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        return this.safeEmitAsPromise('@getstats');\n    }\n    /**\n     * Pauses sending media.\n     */\n    pause() {\n        logger.debug('pause()');\n        if (this._closed) {\n            logger.error('pause() | Producer closed');\n            return;\n        }\n        this._paused = true;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = false;\n        }\n        if (this._zeroRtpOnPause) {\n            this.safeEmitAsPromise('@replacetrack', null)\n                .catch(() => { });\n        }\n        // Emit observer event.\n        this._observer.safeEmit('pause');\n    }\n    /**\n     * Resumes sending media.\n     */\n    resume() {\n        logger.debug('resume()');\n        if (this._closed) {\n            logger.error('resume() | Producer closed');\n            return;\n        }\n        this._paused = false;\n        if (this._track && this._disableTrackOnPause) {\n            this._track.enabled = true;\n        }\n        if (this._zeroRtpOnPause) {\n            this.safeEmitAsPromise('@replacetrack', this._track)\n                .catch(() => { });\n        }\n        // Emit observer event.\n        this._observer.safeEmit('resume');\n    }\n    /**\n     * Replaces the current track with a new one or null.\n     */\n    async replaceTrack({ track }) {\n        logger.debug('replaceTrack() [track:%o]', track);\n        if (this._closed) {\n            // This must be done here. Otherwise there is no chance to stop the given\n            // track.\n            if (track && this._stopTracks) {\n                try {\n                    track.stop();\n                }\n                catch (error) { }\n            }\n            throw new errors_1.InvalidStateError('closed');\n        }\n        else if (track && track.readyState === 'ended') {\n            throw new errors_1.InvalidStateError('track ended');\n        }\n        // Do nothing if this is the same track as the current handled one.\n        if (track === this._track) {\n            logger.debug('replaceTrack() | same track, ignored');\n            return;\n        }\n        if (!this._zeroRtpOnPause || !this._paused) {\n            await this.safeEmitAsPromise('@replacetrack', track);\n        }\n        // Destroy the previous track.\n        this._destroyTrack();\n        // Set the new track.\n        this._track = track;\n        // If this Producer was paused/resumed and the state of the new\n        // track does not match, fix it.\n        if (this._track && this._disableTrackOnPause) {\n            if (!this._paused)\n                this._track.enabled = true;\n            else if (this._paused)\n                this._track.enabled = false;\n        }\n        // Handle the effective track.\n        this._handleTrack();\n    }\n    /**\n     * Sets the video max spatial layer to be sent.\n     */\n    async setMaxSpatialLayer(spatialLayer) {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (this._kind !== 'video')\n            throw new errors_1.UnsupportedError('not a video Producer');\n        else if (typeof spatialLayer !== 'number')\n            throw new TypeError('invalid spatialLayer');\n        if (spatialLayer === this._maxSpatialLayer)\n            return;\n        await this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);\n        this._maxSpatialLayer = spatialLayer;\n    }\n    /**\n     * Sets the DSCP value.\n     */\n    async setRtpEncodingParameters(params) {\n        if (this._closed)\n            throw new errors_1.InvalidStateError('closed');\n        else if (typeof params !== 'object')\n            throw new TypeError('invalid params');\n        await this.safeEmitAsPromise('@setrtpencodingparameters', params);\n    }\n    _onTrackEnded() {\n        logger.debug('track \"ended\" event');\n        this.safeEmit('trackended');\n        // Emit observer event.\n        this._observer.safeEmit('trackended');\n    }\n    _handleTrack() {\n        if (!this._track)\n            return;\n        this._track.addEventListener('ended', this._onTrackEnded);\n    }\n    _destroyTrack() {\n        if (!this._track)\n            return;\n        try {\n            this._track.removeEventListener('ended', this._onTrackEnded);\n            // Just stop the track unless the app set stopTracks: false.\n            if (this._stopTracks)\n                this._track.stop();\n        }\n        catch (error) { }\n    }\n}\nexports.Producer = Producer;\n"]},"metadata":{},"sourceType":"script"}