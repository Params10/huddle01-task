{"ast":null,"code":"const Buffer = require('buffer/').Buffer;\n\nconst keccak256 = require('js-sha3').keccak256;\n\nconst {\n  ETH_ABI_LATTICE_FW_TYPE_MAP\n} = require('./constants');\n\nconst NAME_MAX_SZ = 100;\nconst HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count\n\nconst CATEGORY_SZ = 32;\nconst PARAM_SZ = 26; // 20 byte name + 6 byte def\n\nconst MAX_PARAMS = 18;\nconst MAX_ABI_DEFS = 2;\nexports.MAX_ABI_DEFS = MAX_ABI_DEFS; // Build a request to add ABI data\n\nexports.buildAddAbiPayload = function (defs) {\n  if (!defs || !Array.isArray(defs)) throw new Error('Missing definitions.');\n  if (defs.length > exports.MAX_ABI_DEFS) throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);\n  const b = Buffer.alloc(1 + MAX_ABI_DEFS * (HEADER_SZ + CATEGORY_SZ + PARAM_SZ * MAX_PARAMS));\n  let off = 0;\n  b.writeUInt8(defs.length, off);\n  off++;\n  defs.forEach(def => {\n    if (!def.sig || !def.name || !def.params) throw new Error('name, sig, and params must be present for every ABI definition.'); // -- Header data --\n\n    const sig = Buffer.from(def.sig, 'hex');\n    if (sig.length !== 4) throw new Error('Function signatures must always be four bytes.');\n    sig.copy(b, off);\n    off += sig.length;\n    const name = Buffer.from(def.name);\n    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator\n      throw new Error(`Only function names shorter than ${NAME_MAX_SZ - 1} characters are supported.`);\n    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off);\n    off += NAME_MAX_SZ; // Number of parameters\n\n    const numParams = Array.isArray(def.params) ? def.params.length : 0;\n    b.writeUInt8(numParams, off);\n    off++; // -- (optional) Category name --\n\n    if (def.category && typeof def.category === 'string') {\n      const category = Buffer.from(def.category);\n      if (category.length > CATEGORY_SZ - 1) // -1 accounts for null terminator\n        throw new Error(`Category name must be shorter than ${CATEGORY_SZ - 1}. Got ${category.length}`);\n      category.copy(b, off);\n    }\n\n    off += CATEGORY_SZ; // -- Param data --\n\n    if (numParams > MAX_PARAMS) throw new Error('Currently only ABI defintions with <=10 parameters are supported.');\n\n    if (numParams > 0) {\n      // First copy param names (first 20 bytes)\n      def.params.forEach(param => {\n        if (param.name === undefined || param.latticeTypeIdx === undefined || param.isArray === undefined || param.arraySz === undefined) throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');\n        Buffer.from(param.name).slice(0, 20).copy(b, off);\n        off += 20;\n      }); // Bump offset to account for blank param slots\n\n      off += 20 * (MAX_PARAMS - numParams); // Next copy the definitions\n\n      def.params.forEach(param => {\n        b.writeUInt8(param.latticeTypeIdx, off);\n        off++;\n        b.writeUInt8(param.isArray === true, off);\n        off++;\n        b.writeUInt32LE(param.arraySz, off);\n        off += 4;\n      }); // Bump offset again\n\n      off += 6 * (MAX_PARAMS - numParams);\n    } else {\n      // If there are no params, just bump the offset\n      off += PARAM_SZ * MAX_PARAMS;\n    }\n  });\n  return b;\n}; // Get the 4-byte function identifier based on the canonical name\n\n\nexports.getFuncSig = function (f) {\n  // Canonical name is:\n  // funcName(paramType0, ..., paramTypeN)\n  let canonicalName = `${f.name}(`;\n  f.inputs.forEach(input => {\n    if (input.type.indexOf('tuple') > -1) {\n      const arrSuffix = input.type.slice(input.type.indexOf('tuple') + 5);\n      canonicalName += '(';\n      input.components.forEach((c, i) => {\n        canonicalName += `${c.type}${i === input.components.length - 1 ? '' : ','}`;\n      });\n      canonicalName += `)${arrSuffix},`;\n    } else {\n      canonicalName += `${input.type},`;\n    }\n  });\n  if (f.inputs.length > 0) canonicalName = canonicalName.slice(0, canonicalName.length - 1);\n  canonicalName += ')';\n  return keccak256(canonicalName).slice(0, 8);\n}; //--------------------------------------\n// PARSERS\n//--------------------------------------\n\n\nfunction parseEtherscanAbiDefs(_defs, skipErrors = false) {\n  // `_defs` are `result` of the parsed response\n  const defs = [];\n\n  _defs.forEach(d => {\n    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view' && d.constant !== true) {\n      try {\n        const sig = exports.getFuncSig(d);\n        const params = parseEtherscanAbiInputs(d.inputs);\n        defs.push({\n          name: d.name,\n          sig,\n          params\n        });\n      } catch (err) {\n        if (skipErrors === true) console.error('Failed to load def:', d.name, err.toString());else throw new Error(err);\n      }\n    }\n  });\n\n  return defs;\n}\n\nexports.abiParsers = {\n  etherscan: parseEtherscanAbiDefs\n}; //--------------------------------------\n// HELPERS\n//--------------------------------------\n// Parse the ABI param data into structs Lattice firmware will recognize.\n\nfunction parseEtherscanAbiInputs(inputs, data = [], isNestedTuple = false) {\n  let tupleParams = [];\n  inputs.forEach(input => {\n    const typeName = input.type;\n    const d = {\n      isArray: false,\n      arraySz: 0,\n      name: input.name\n    };\n    const openBracketIdx = typeName.indexOf('[');\n    const closeBracketIdx = typeName.indexOf(']');\n    const isMultiDim = typeName.split('[').length > 2;\n\n    if (isMultiDim) {\n      throw new Error('Skipping function with unsupported multidimensional array type');\n    } else {\n      if (openBracketIdx > -1 && closeBracketIdx > -1) {\n        if (openBracketIdx >= closeBracketIdx) {\n          ; // not a valid param -- skip it\n        } else if (openBracketIdx + 1 === closeBracketIdx) {\n          d.isArray = true;\n        } else {\n          // Parse the array size if applicable\n          const number = parseInt(typeName.slice(openBracketIdx, closeBracketIdx));\n\n          if (isNaN(number)) {\n            return d;\n          }\n\n          d.isArray = true;\n          d.arraySz = number;\n        }\n      }\n\n      let singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;\n\n      if (singularTypeName === 'tuple') {\n        if (isNestedTuple === true) throw new Error('Nested tuples are not supported');\n        singularTypeName = `tuple${input.components.length}`;\n        tupleParams = parseEtherscanAbiInputs(input.components, tupleParams, true);\n      }\n\n      d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName);\n      if (!d.latticeTypeIdx) throw new Error(`Unsupported type: ${typeName}`);\n      data.push(d);\n    }\n  });\n  const params = data.concat(tupleParams);\n  if (params.length > 18) throw new Error('Function has too many parameters for Lattice firmware (18 max)');\n  return data.concat(tupleParams);\n} // Enum values from inside Lattice firmware\n\n\nfunction getTypeIdxLatticeFw(type) {\n  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];\n}","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/gridplus-sdk/src/ethereumAbi.js"],"names":["Buffer","require","keccak256","ETH_ABI_LATTICE_FW_TYPE_MAP","NAME_MAX_SZ","HEADER_SZ","CATEGORY_SZ","PARAM_SZ","MAX_PARAMS","MAX_ABI_DEFS","exports","buildAddAbiPayload","defs","Array","isArray","Error","length","b","alloc","off","writeUInt8","forEach","def","sig","name","params","from","copy","slice","numParams","category","param","undefined","latticeTypeIdx","arraySz","writeUInt32LE","getFuncSig","f","canonicalName","inputs","input","type","indexOf","arrSuffix","components","c","i","parseEtherscanAbiDefs","_defs","skipErrors","d","stateMutability","constant","parseEtherscanAbiInputs","push","err","console","error","toString","abiParsers","etherscan","data","isNestedTuple","tupleParams","typeName","openBracketIdx","closeBracketIdx","isMultiDim","split","number","parseInt","isNaN","singularTypeName","getTypeIdxLatticeFw","concat"],"mappings":"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","sourcesContent":["const Buffer = require('buffer/').Buffer\nconst keccak256 = require('js-sha3').keccak256;\nconst { ETH_ABI_LATTICE_FW_TYPE_MAP } = require('./constants');\nconst NAME_MAX_SZ = 100;\nconst HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count\nconst CATEGORY_SZ = 32;\nconst PARAM_SZ = 26; // 20 byte name + 6 byte def\nconst MAX_PARAMS = 18;\nconst MAX_ABI_DEFS = 2;\nexports.MAX_ABI_DEFS = MAX_ABI_DEFS;\n\n// Build a request to add ABI data\nexports.buildAddAbiPayload = function(defs) {\n  if (!defs || !Array.isArray(defs))\n    throw new Error('Missing definitions.');\n  if (defs.length > exports.MAX_ABI_DEFS)\n    throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);\n  const b = Buffer.alloc(1 + (MAX_ABI_DEFS * (HEADER_SZ + CATEGORY_SZ + (PARAM_SZ * MAX_PARAMS))));\n  let off = 0;\n  b.writeUInt8(defs.length, off); off++;\n  defs.forEach((def) => {\n    if (!def.sig || !def.name || !def.params)\n      throw new Error('name, sig, and params must be present for every ABI definition.')\n    // -- Header data --\n    const sig = Buffer.from(def.sig, 'hex');\n    if (sig.length !== 4)\n      throw new Error('Function signatures must always be four bytes.');\n    sig.copy(b, off); off += sig.length;\n    const name = Buffer.from(def.name);\n    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator\n      throw new Error(`Only function names shorter than ${NAME_MAX_SZ-1} characters are supported.`);\n    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off); off += NAME_MAX_SZ;\n    // Number of parameters\n    const numParams = Array.isArray(def.params) ? def.params.length : 0;\n    b.writeUInt8(numParams, off); off++;\n    // -- (optional) Category name --\n    if (def.category && typeof def.category === 'string') {\n      const category = Buffer.from(def.category);\n      if (category.length > CATEGORY_SZ - 1) // -1 accounts for null terminator\n        throw new Error(`Category name must be shorter than ${CATEGORY_SZ - 1}. Got ${category.length}`);\n      category.copy(b, off);\n    }\n    off += CATEGORY_SZ;\n    // -- Param data --\n    if (numParams > MAX_PARAMS)\n      throw new Error('Currently only ABI defintions with <=10 parameters are supported.');\n    if (numParams > 0) {\n      // First copy param names (first 20 bytes)\n      def.params.forEach((param) => {\n        if (param.name === undefined || param.latticeTypeIdx === undefined || param.isArray === undefined || param.arraySz === undefined)\n          throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');\n        Buffer.from(param.name).slice(0, 20).copy(b, off); off += 20;\n      })\n      // Bump offset to account for blank param slots\n      off += 20 * (MAX_PARAMS - numParams);\n      // Next copy the definitions\n      def.params.forEach((param) => {\n        b.writeUInt8(param.latticeTypeIdx, off); off++;\n        b.writeUInt8(param.isArray === true, off); off++;\n        b.writeUInt32LE(param.arraySz, off); off += 4;\n      })\n      // Bump offset again\n      off += 6 * (MAX_PARAMS - numParams);\n    } else {\n      // If there are no params, just bump the offset\n      off += PARAM_SZ * MAX_PARAMS;\n    }\n  })\n  return b;\n}\n\n// Get the 4-byte function identifier based on the canonical name\nexports.getFuncSig = function(f) {\n  // Canonical name is:\n  // funcName(paramType0, ..., paramTypeN)\n  let canonicalName = `${f.name}(`;\n  f.inputs.forEach((input) => {\n    if (input.type.indexOf('tuple') > -1) {\n      const arrSuffix = input.type.slice(input.type.indexOf('tuple') + 5);\n      canonicalName += '('\n      input.components.forEach((c, i) => {\n        canonicalName += `${c.type}${i === input.components.length - 1 ? '' : ','}`;\n      })\n      canonicalName += `)${arrSuffix},`\n    } else {\n      canonicalName += `${input.type},`\n    }\n  })\n  if (f.inputs.length > 0)\n    canonicalName = canonicalName.slice(0, canonicalName.length - 1)\n  canonicalName += ')'\n  return keccak256(canonicalName).slice(0, 8);\n}\n\n//--------------------------------------\n// PARSERS\n//--------------------------------------\nfunction parseEtherscanAbiDefs(_defs, skipErrors=false) { // `_defs` are `result` of the parsed response\n  const defs = [];\n  _defs.forEach((d) => {\n    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view' && d.constant !== true) {\n      try {\n        const sig = exports.getFuncSig(d);\n        const params = parseEtherscanAbiInputs(d.inputs);\n        defs.push({\n          name: d.name,\n          sig,\n          params,\n        })\n      } catch (err) {\n        if (skipErrors === true)\n          console.error('Failed to load def:', d.name, err.toString())\n        else\n          throw new Error(err)\n      }\n    }\n  })\n  return defs;\n}\n\nexports.abiParsers = {\n  etherscan: parseEtherscanAbiDefs,\n}\n\n//--------------------------------------\n// HELPERS\n//--------------------------------------\n// Parse the ABI param data into structs Lattice firmware will recognize.\nfunction parseEtherscanAbiInputs(inputs, data=[], isNestedTuple=false) {\n  let tupleParams = [];\n  inputs.forEach((input) => {\n    const typeName = input.type;\n    const d = { isArray: false, arraySz: 0, name: input.name, };\n    const openBracketIdx = typeName.indexOf('[');\n    const closeBracketIdx = typeName.indexOf(']');\n    const isMultiDim = typeName.split('[').length > 2;\n    if (isMultiDim) {\n      throw new Error('Skipping function with unsupported multidimensional array type')\n    } else {\n      if (openBracketIdx > -1 && closeBracketIdx > -1) {\n        if (openBracketIdx >= closeBracketIdx) {\n          ; // not a valid param -- skip it\n        } else if ((openBracketIdx + 1) === closeBracketIdx) {\n          d.isArray = true;\n        } else {\n          // Parse the array size if applicable\n          const number = parseInt(typeName.slice(openBracketIdx, closeBracketIdx))\n          if (isNaN(number)) {\n            return d;\n          }\n          d.isArray = true;\n          d.arraySz = number;\n        }\n      }\n      let singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;\n      if (singularTypeName === 'tuple') {\n        if (isNestedTuple === true)\n          throw new Error('Nested tuples are not supported')\n        singularTypeName = `tuple${input.components.length}`;\n        tupleParams = parseEtherscanAbiInputs(input.components, tupleParams, true);\n      }\n      d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName)\n      if (!d.latticeTypeIdx)\n        throw new Error(`Unsupported type: ${typeName}`)\n      data.push(d)\n    }\n  })\n  const params = data.concat(tupleParams)\n  if (params.length > 18)\n    throw new Error('Function has too many parameters for Lattice firmware (18 max)')\n  return data.concat(tupleParams);\n}\n\n// Enum values from inside Lattice firmware\nfunction getTypeIdxLatticeFw(type) {\n  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];\n}\n"]},"metadata":{},"sourceType":"script"}