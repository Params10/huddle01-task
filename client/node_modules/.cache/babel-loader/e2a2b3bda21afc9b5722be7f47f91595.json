{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst xoshiro_1 = __importDefault(require(\"./xoshiro\"));\n\nconst randomSampler = require('@apocentre/alias-sampling');\n\nconst chooseDegree = (seqLenth, rng) => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n  return degreeChooser.next() + 1;\n};\n\nexports.chooseDegree = chooseDegree;\n\nconst shuffle = (items, rng) => {\n  let remaining = [...items];\n  let result = [];\n\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index]; // remaining.erase(remaining.begin() + index);\n\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n\n  return result;\n};\n\nexports.shuffle = shuffle;\n\nconst chooseFragments = (seqNum, seqLength, checksum) => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([utils_1.intToBytes(seqNum), utils_1.intToBytes(checksum)]);\n    const rng = new xoshiro_1.default(seed);\n    const degree = exports.chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = exports.shuffle(indexes, rng);\n    return shuffledIndexes.slice(0, degree);\n  }\n};\n\nexports.chooseFragments = chooseFragments;","map":{"version":3,"sources":["../src/fountainUtils.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAM,aAAa,GAAG,OAAO,CAAC,2BAAD,CAA7B;;AAEO,MAAM,YAAY,GAAG,CAAC,QAAD,EAAmB,GAAnB,KAA2C;AACrE,QAAM,mBAAmB,GAAG,CAAC,GAAG,IAAI,KAAJ,CAAU,QAAV,CAAJ,EAAyB,GAAzB,CAA6B,CAAC,CAAD,EAAI,KAAJ,KAAc,KAAK,KAAK,GAAG,CAAb,CAA3C,CAA5B;AACA,QAAM,aAAa,GAAG,aAAa,CAAC,mBAAD,EAAsB,IAAtB,EAA4B,GAAG,CAAC,UAAhC,CAAnC;AAEA,SAAO,aAAa,CAAC,IAAd,KAAuB,CAA9B;AACD,CALM;;AAAM,OAAA,CAAA,YAAA,GAAY,YAAZ;;AAQN,MAAM,OAAO,GAAG,CAAC,KAAD,EAAe,GAAf,KAAsC;AAC3D,MAAI,SAAS,GAAG,CAAC,GAAG,KAAJ,CAAhB;AACA,MAAI,MAAM,GAAG,EAAb;;AAEA,SAAO,SAAS,CAAC,MAAV,GAAmB,CAA1B,EAA6B;AAC3B,QAAI,KAAK,GAAG,GAAG,CAAC,OAAJ,CAAY,CAAZ,EAAe,SAAS,CAAC,MAAV,GAAmB,CAAlC,CAAZ;AACA,QAAI,IAAI,GAAG,SAAS,CAAC,KAAD,CAApB,CAF2B,CAG3B;;AACA,IAAA,SAAS,CAAC,MAAV,CAAiB,KAAjB,EAAwB,CAAxB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,IAAZ;AACD;;AAED,SAAO,MAAP;AACD,CAbM;;AAAM,OAAA,CAAA,OAAA,GAAO,OAAP;;AAgBN,MAAM,eAAe,GAAG,CAAC,MAAD,EAAiB,SAAjB,EAAoC,QAApC,KAAkE;AAC/F;AACA;AACA;AACA,MAAI,MAAM,IAAI,SAAd,EAAyB;AACvB,WAAO,CAAC,MAAM,GAAG,CAAV,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,OAAA,CAAA,UAAA,CAAW,MAAX,CAAD,EAAqB,OAAA,CAAA,UAAA,CAAW,QAAX,CAArB,CAAd,CAAb;AACA,UAAM,GAAG,GAAG,IAAI,SAAA,CAAA,OAAJ,CAAY,IAAZ,CAAZ;AACA,UAAM,MAAM,GAAG,OAAA,CAAA,YAAA,CAAa,SAAb,EAAwB,GAAxB,CAAf;AACA,UAAM,OAAO,GAAG,CAAC,GAAG,IAAI,KAAJ,CAAU,SAAV,CAAJ,EAA0B,GAA1B,CAA8B,CAAC,CAAD,EAAI,KAAJ,KAAc,KAA5C,CAAhB;AACA,UAAM,eAAe,GAAG,OAAA,CAAA,OAAA,CAAQ,OAAR,EAAiB,GAAjB,CAAxB;AAEA,WAAO,eAAe,CAAC,KAAhB,CAAsB,CAAtB,EAAyB,MAAzB,CAAP;AACD;AACF,CAfM;;AAAM,OAAA,CAAA,eAAA,GAAe,eAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;\nconst utils_1 = require(\"./utils\");\nconst xoshiro_1 = __importDefault(require(\"./xoshiro\"));\nconst randomSampler = require('@apocentre/alias-sampling');\nconst chooseDegree = (seqLenth, rng) => {\n    const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n    const degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n    return degreeChooser.next() + 1;\n};\nexports.chooseDegree = chooseDegree;\nconst shuffle = (items, rng) => {\n    let remaining = [...items];\n    let result = [];\n    while (remaining.length > 0) {\n        let index = rng.nextInt(0, remaining.length - 1);\n        let item = remaining[index];\n        // remaining.erase(remaining.begin() + index);\n        remaining.splice(index, 1);\n        result.push(item);\n    }\n    return result;\n};\nexports.shuffle = shuffle;\nconst chooseFragments = (seqNum, seqLength, checksum) => {\n    // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n    // others. This means that if you only generate the first `seqLenth` parts,\n    // then you have all the parts you need to decode the message.\n    if (seqNum <= seqLength) {\n        return [seqNum - 1];\n    }\n    else {\n        const seed = Buffer.concat([utils_1.intToBytes(seqNum), utils_1.intToBytes(checksum)]);\n        const rng = new xoshiro_1.default(seed);\n        const degree = exports.chooseDegree(seqLength, rng);\n        const indexes = [...new Array(seqLength)].map((_, index) => index);\n        const shuffledIndexes = exports.shuffle(indexes, rng);\n        return shuffledIndexes.slice(0, degree);\n    }\n};\nexports.chooseFragments = chooseFragments;\n//# sourceMappingURL=fountainUtils.js.map"]},"metadata":{},"sourceType":"script"}