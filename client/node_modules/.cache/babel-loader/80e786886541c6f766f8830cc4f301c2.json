{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiKey = void 0;\n\nconst CryptoECKey_1 = require(\"./CryptoECKey\");\n\nconst CryptoHDKey_1 = require(\"./CryptoHDKey\");\n\nconst DataItem_1 = require(\"./lib/DataItem\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"threshold\"] = 1] = \"threshold\";\n  Keys[Keys[\"keys\"] = 2] = \"keys\";\n})(Keys || (Keys = {}));\n\nclass MultiKey extends RegistryItem_1.RegistryItem {\n  constructor(threshold, ecKeys, hdKeys) {\n    super();\n    this.threshold = threshold;\n    this.ecKeys = ecKeys;\n    this.hdKeys = hdKeys;\n\n    this.getThreshold = () => this.threshold;\n\n    this.getEcKeys = () => this.ecKeys;\n\n    this.getHdKeys = () => this.hdKeys;\n\n    this.toDataItem = () => {\n      const map = {};\n      map[Keys.threshold] = this.threshold;\n      const keys = [...this.ecKeys, ...this.hdKeys].map(k => {\n        const dataItem = k.toDataItem();\n        dataItem.setTag(k.getRegistryType().getTag());\n        return dataItem;\n      });\n      map[Keys.keys] = keys;\n      return new DataItem_1.DataItem(map);\n    };\n  }\n\n}\n\nexports.MultiKey = MultiKey;\n\nMultiKey.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const threshold = map[Keys.threshold];\n  const keys = map[Keys.keys];\n  const ecKeys = [];\n  const hdKeys = [];\n  keys.forEach(k => {\n    if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {\n      hdKeys.push(CryptoHDKey_1.CryptoHDKey.fromDataItem(k));\n    } else if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getTag()) {\n      ecKeys.push(CryptoECKey_1.CryptoECKey.fromDataItem(k));\n    }\n  });\n  return new MultiKey(threshold, ecKeys, hdKeys);\n};","map":{"version":3,"sources":["../src/MultiKey.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAK,IAAL;;AAAA,CAAA,UAAK,IAAL,EAAS;AACP,EAAA,IAAA,CAAA,IAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,EAAA,IAAA,CAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACD,CAHD,EAAK,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAT;;AAKA,MAAa,QAAb,SAA8B,cAAA,CAAA,YAA9B,CAA0C;AAGxC,EAAA,WAAA,CACU,SADV,EAEU,MAFV,EAGU,MAHV,EAG+B;AAE7B;AAJQ,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,MAAA,GAAA,MAAA;;AAKV,SAAA,YAAA,GAAe,MAAM,KAAK,SAA1B;;AACA,SAAA,SAAA,GAAY,MAAM,KAAK,MAAvB;;AACA,SAAA,SAAA,GAAY,MAAM,KAAK,MAAvB;;AAEA,SAAA,UAAA,GAAa,MAAK;AAChB,YAAM,GAAG,GAAG,EAAZ;AACA,MAAA,GAAG,CAAC,IAAI,CAAC,SAAN,CAAH,GAAsB,KAAK,SAA3B;AACA,YAAM,IAAI,GAAe,CAAC,GAAG,KAAK,MAAT,EAAiB,GAAG,KAAK,MAAzB,EAAiC,GAAjC,CAAsC,CAAD,IAAM;AAClE,cAAM,QAAQ,GAAG,CAAC,CAAC,UAAF,EAAjB;AACA,QAAA,QAAQ,CAAC,MAAT,CAAgB,CAAC,CAAC,eAAF,GAAoB,MAApB,EAAhB;AACA,eAAO,QAAP;AACD,OAJwB,CAAzB;AAKA,MAAA,GAAG,CAAC,IAAI,CAAC,IAAN,CAAH,GAAiB,IAAjB;AACA,aAAO,IAAI,UAAA,CAAA,QAAJ,CAAa,GAAb,CAAP;AACD,KAVD;AANC;;AATuC;;AAA1C,OAAA,CAAA,QAAA,GAAA,QAAA;;AA2BS,QAAA,CAAA,YAAA,GAAgB,QAAD,IAAuB;AAC3C,QAAM,GAAG,GAAG,QAAQ,CAAC,OAAT,EAAZ;AACA,QAAM,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,SAAN,CAArB;AACA,QAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAN,CAAhB;AACA,QAAM,MAAM,GAAG,EAAf;AACA,QAAM,MAAM,GAAG,EAAf;AACA,EAAA,IAAI,CAAC,OAAL,CAAc,CAAD,IAAM;AACjB,QAAI,CAAC,CAAC,MAAF,OAAe,cAAA,CAAA,aAAA,CAAc,YAAd,CAA2B,MAA3B,EAAnB,EAAwD;AACtD,MAAA,MAAM,CAAC,IAAP,CAAY,aAAA,CAAA,WAAA,CAAY,YAAZ,CAAyB,CAAzB,CAAZ;AACD,KAFD,MAEO,IAAI,CAAC,CAAC,MAAF,OAAe,cAAA,CAAA,aAAA,CAAc,YAAd,CAA2B,MAA3B,EAAnB,EAAwD;AAC7D,MAAA,MAAM,CAAC,IAAP,CAAY,aAAA,CAAA,WAAA,CAAY,YAAZ,CAAyB,CAAzB,CAAZ;AACD;AACF,GAND;AAOA,SAAO,IAAI,QAAJ,CAAa,SAAb,EAAwB,MAAxB,EAAgC,MAAhC,CAAP;AACD,CAdM","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiKey = void 0;\nconst CryptoECKey_1 = require(\"./CryptoECKey\");\nconst CryptoHDKey_1 = require(\"./CryptoHDKey\");\nconst DataItem_1 = require(\"./lib/DataItem\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"threshold\"] = 1] = \"threshold\";\n    Keys[Keys[\"keys\"] = 2] = \"keys\";\n})(Keys || (Keys = {}));\nclass MultiKey extends RegistryItem_1.RegistryItem {\n    constructor(threshold, ecKeys, hdKeys) {\n        super();\n        this.threshold = threshold;\n        this.ecKeys = ecKeys;\n        this.hdKeys = hdKeys;\n        this.getThreshold = () => this.threshold;\n        this.getEcKeys = () => this.ecKeys;\n        this.getHdKeys = () => this.hdKeys;\n        this.toDataItem = () => {\n            const map = {};\n            map[Keys.threshold] = this.threshold;\n            const keys = [...this.ecKeys, ...this.hdKeys].map((k) => {\n                const dataItem = k.toDataItem();\n                dataItem.setTag(k.getRegistryType().getTag());\n                return dataItem;\n            });\n            map[Keys.keys] = keys;\n            return new DataItem_1.DataItem(map);\n        };\n    }\n}\nexports.MultiKey = MultiKey;\nMultiKey.fromDataItem = (dataItem) => {\n    const map = dataItem.getData();\n    const threshold = map[Keys.threshold];\n    const keys = map[Keys.keys];\n    const ecKeys = [];\n    const hdKeys = [];\n    keys.forEach((k) => {\n        if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {\n            hdKeys.push(CryptoHDKey_1.CryptoHDKey.fromDataItem(k));\n        }\n        else if (k.getTag() === RegistryType_1.RegistryTypes.CRYPTO_ECKEY.getTag()) {\n            ecKeys.push(CryptoECKey_1.CryptoECKey.fromDataItem(k));\n        }\n    });\n    return new MultiKey(threshold, ecKeys, hdKeys);\n};\n//# sourceMappingURL=MultiKey.js.map"]},"metadata":{},"sourceType":"script"}