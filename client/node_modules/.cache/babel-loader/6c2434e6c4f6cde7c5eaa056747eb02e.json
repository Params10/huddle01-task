{"ast":null,"code":"/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random;\n  this.precomputeAlias(probabilities);\n}\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\n\n\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n = numOfSamples || 1,\n      out = [],\n      i = 0;\n\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[this.rng() < this.prob[c] ? c : this.alias[c]];\n  } while (++i < n);\n\n  return n > 1 ? out : out[0];\n};\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\n\n\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n = p.length,\n      sum = 0,\n      nS = 0,\n      nL = 0,\n      P = [],\n      S = [],\n      L = [],\n      g,\n      i,\n      a; // Normalize probabilities\n\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n\n    sum += p[i];\n  }\n\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  } // Set separate index lists for small and large probabilities:\n\n\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1) S[nS++] = i;else L[nL++] = i;\n  } // Work through index lists\n\n\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1) S[nS++] = g;else L[nL++] = g;\n  }\n\n  while (nL) this.prob[L[--nL]] = 1;\n\n  while (nS) // can only happen through numeric instability\n  this.prob[S[--nS]] = 1;\n};\n\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n\n  for (var i = 0; i < n; i++) o[i] = i;\n\n  return o;\n};\n\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\n\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};","map":{"version":3,"sources":["/home/param/Desktop/huddle01-task/client/node_modules/@apocentre/alias-sampling/index.js"],"names":["Sample","probabilities","outcomes","rng","alias","prob","indexedOutcomes","length","Math","random","precomputeAlias","prototype","next","numOfSamples","n","out","i","c","floor","p","sum","nS","nL","P","S","L","g","a","o","randomInt","min","max","module","exports"],"mappings":"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","sourcesContent":["/* global module */\n\n/**\n * Library for sampling of random values from a discrete probability distribution, \n * using the Walker-Vose alias method.\n *\n * Creates a new Sample instance for the given probabilities and outcomes.\n *\n * @param {Array} the probabilities.\n * @param {Array} the outcomes. Index is assumed as outcome if not provided.\n */\nfunction Sample(probabilities, outcomes, rng) {\n  'use strict';\n\n  this.alias = [];\n  this.prob  = [];\n  this.outcomes = outcomes || this.indexedOutcomes(probabilities.length);\n  this.rng = rng || Math.random\n  this.precomputeAlias(probabilities);\n}\n\n/**\n * Samples outcomes from the underlying probability distribution.\n *\n * @param {int} the number of samples. Optional parameter, defaults to 1.\n * @return {Object} a random outcome according to the underlying probability distribution \n *                  and the requested number of samples. If the requested number of samples \n *                  is greater than 1 this method returns an array.\n */\nSample.prototype.next = function (numOfSamples) {\n  'use strict';\n\n  var n   = numOfSamples || 1,\n      out = [],\n      i   = 0;\n\n  do {\n    var c = Math.floor(this.rng() * this.prob.length);\n    out[i] = this.outcomes[(this.rng() < this.prob[c]) ? c : this.alias[c]];\n  } while (++i < n);\n\n  return (n > 1) ? out : out[0];\n};\n\n/**\n * Ported from ransampl.c\n * Scientific Computing Group of JCNS at MLZ Garching.\n * http://apps.jcns.fz-juelich.de/doku/sc/ransampl\n */\nSample.prototype.precomputeAlias = function (p) {\n  'use strict';\n\n  var n   = p.length,\n      sum = 0,\n      nS  = 0,\n      nL  = 0,\n      P   = [],\n      S   = [],\n      L   = [],\n      g, i, a;\n\n  // Normalize probabilities\n  for (i = 0; i < n; ++i) {\n    if (p[i] < 0) {\n      throw 'Probability must be a positive: p[' + i + ']=' + p[i];\n    }\n    sum += p[i];\n  }\n\n  if (sum === 0) {\n    throw 'Probability cannot be zero.';\n  }\n\n  for (i = 0; i < n; ++i) {\n    P[i] = p[i] * n / sum;\n  }\n\n  // Set separate index lists for small and large probabilities:\n  for (i = n - 1; i >= 0; --i) {\n    // at variance from Schwarz, we revert the index order\n    if (P[i] < 1)\n      S[nS++] = i;\n    else\n      L[nL++] = i;\n  }\n\n  // Work through index lists\n  while (nS && nL) {\n    a = S[--nS]; // Schwarz's l\n    g = L[--nL]; // Schwarz's g\n\n    this.prob[a] = P[a];\n    this.alias[a] = g;\n\n    P[g] = P[g] + P[a] - 1;\n    if (P[g] < 1)\n      S[nS++] = g;\n    else\n      L[nL++] = g;\n  }\n\n  while (nL)\n    this.prob[L[--nL]] = 1;\n\n  while (nS)\n    // can only happen through numeric instability\n    this.prob[S[--nS]] = 1;\n};\n\nSample.prototype.indexedOutcomes = function (n) {\n  'use strict';\n\n  var o = [];\n  for (var i = 0; i < n; i++) o[i] = i;\n  return o;\n};\n\nSample.prototype.randomInt = function (min, max) {\n  'use strict';\n\n  return Math.floor(this.rng() * (max - min)) + min;\n};\n\nmodule.exports = function (probabilities, outcomes, rng) {\n  'use strict';\n\n  return new Sample(probabilities, outcomes, rng);\n};\n"]},"metadata":{},"sourceType":"script"}