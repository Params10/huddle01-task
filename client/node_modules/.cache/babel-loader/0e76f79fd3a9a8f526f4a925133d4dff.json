{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoCoinInfo = exports.Network = exports.Type = void 0;\n\nconst lib_1 = require(\"./lib\");\n\nconst RegistryItem_1 = require(\"./RegistryItem\");\n\nconst RegistryType_1 = require(\"./RegistryType\");\n\nvar Keys;\n\n(function (Keys) {\n  Keys[\"type\"] = \"1\";\n  Keys[\"network\"] = \"2\";\n})(Keys || (Keys = {}));\n\nvar Type;\n\n(function (Type) {\n  Type[Type[\"bitcoin\"] = 0] = \"bitcoin\";\n})(Type = exports.Type || (exports.Type = {}));\n\nvar Network;\n\n(function (Network) {\n  Network[Network[\"mainnet\"] = 0] = \"mainnet\";\n  Network[Network[\"testnet\"] = 1] = \"testnet\";\n})(Network = exports.Network || (exports.Network = {}));\n\nclass CryptoCoinInfo extends RegistryItem_1.RegistryItem {\n  constructor(type, network) {\n    super();\n    this.type = type;\n    this.network = network;\n\n    this.getRegistryType = () => {\n      return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;\n    };\n\n    this.getType = () => {\n      return this.type || Type.bitcoin;\n    };\n\n    this.getNetwork = () => {\n      return this.network || Network.mainnet;\n    };\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.type) {\n        map[Keys.type] = this.type;\n      }\n\n      if (this.network) {\n        map[Keys.network] = this.network;\n      }\n\n      return new lib_1.DataItem(map);\n    };\n  }\n\n}\n\nexports.CryptoCoinInfo = CryptoCoinInfo;\n\nCryptoCoinInfo.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const type = map[Keys.type];\n  const network = map[Keys.network];\n  return new CryptoCoinInfo(type, network);\n};\n\nCryptoCoinInfo.fromCBOR = _cborPayload => {\n  const dataItem = lib_1.decodeToDataItem(_cborPayload);\n  return CryptoCoinInfo.fromDataItem(dataItem);\n};","map":{"version":3,"sources":["../src/CryptoCoinInfo.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,KAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAK,IAAL;;AAAA,CAAA,UAAK,IAAL,EAAS;AACP,EAAA,IAAA,CAAA,MAAA,CAAA,GAAA,GAAA;AACA,EAAA,IAAA,CAAA,SAAA,CAAA,GAAA,GAAA;AACD,CAHD,EAAK,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAT;;AAKA,IAAY,IAAZ;;AAAA,CAAA,UAAY,IAAZ,EAAgB;AACd,EAAA,IAAA,CAAA,IAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACD,CAFD,EAAY,IAAI,GAAJ,OAAA,CAAA,IAAA,KAAA,OAAA,CAAA,IAAA,GAAI,EAAJ,CAAZ;;AAIA,IAAY,OAAZ;;AAAA,CAAA,UAAY,OAAZ,EAAmB;AACjB,EAAA,OAAA,CAAA,OAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,OAAA,CAAA,OAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACD,CAHD,EAAY,OAAO,GAAP,OAAA,CAAA,OAAA,KAAA,OAAA,CAAA,OAAA,GAAO,EAAP,CAAZ;;AAKA,MAAa,cAAb,SAAoC,cAAA,CAAA,YAApC,CAAgD;AAK9C,EAAA,WAAA,CAAoB,IAApB,EAAyC,OAAzC,EAA0D;AACxD;AADkB,SAAA,IAAA,GAAA,IAAA;AAAqB,SAAA,OAAA,GAAA,OAAA;;AAJzC,SAAA,eAAA,GAAkB,MAAK;AACrB,aAAO,cAAA,CAAA,aAAA,CAAc,gBAArB;AACD,KAFD;;AAQO,SAAA,OAAA,GAAU,MAAK;AACpB,aAAO,KAAK,IAAL,IAAa,IAAI,CAAC,OAAzB;AACD,KAFM;;AAIA,SAAA,UAAA,GAAa,MAAK;AACvB,aAAO,KAAK,OAAL,IAAgB,OAAO,CAAC,OAA/B;AACD,KAFM;;AAIA,SAAA,UAAA,GAAa,MAAK;AACvB,YAAM,GAAG,GAAG,EAAZ;;AACA,UAAI,KAAK,IAAT,EAAe;AACb,QAAA,GAAG,CAAC,IAAI,CAAC,IAAN,CAAH,GAAiB,KAAK,IAAtB;AACD;;AACD,UAAI,KAAK,OAAT,EAAkB;AAChB,QAAA,GAAG,CAAC,IAAI,CAAC,OAAN,CAAH,GAAoB,KAAK,OAAzB;AACD;;AACD,aAAO,IAAI,KAAA,CAAA,QAAJ,CAAa,GAAb,CAAP;AACD,KATM;AAVN;;AAP6C;;AAAhD,OAAA,CAAA,cAAA,GAAA,cAAA;;AA4BgB,cAAA,CAAA,YAAA,GAAgB,QAAD,IAAuB;AAClD,QAAM,GAAG,GAAG,QAAQ,CAAC,OAAT,EAAZ;AACA,QAAM,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAN,CAAhB;AACA,QAAM,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC,OAAN,CAAnB;AACA,SAAO,IAAI,cAAJ,CAAmB,IAAnB,EAAyB,OAAzB,CAAP;AACD,CALa;;AAOA,cAAA,CAAA,QAAA,GAAY,YAAD,IAAyB;AAChD,QAAM,QAAQ,GAAG,KAAA,CAAA,gBAAA,CAAiB,YAAjB,CAAjB;AACA,SAAO,cAAc,CAAC,YAAf,CAA4B,QAA5B,CAAP;AACD,CAHa","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoCoinInfo = exports.Network = exports.Type = void 0;\nconst lib_1 = require(\"./lib\");\nconst RegistryItem_1 = require(\"./RegistryItem\");\nconst RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n    Keys[\"type\"] = \"1\";\n    Keys[\"network\"] = \"2\";\n})(Keys || (Keys = {}));\nvar Type;\n(function (Type) {\n    Type[Type[\"bitcoin\"] = 0] = \"bitcoin\";\n})(Type = exports.Type || (exports.Type = {}));\nvar Network;\n(function (Network) {\n    Network[Network[\"mainnet\"] = 0] = \"mainnet\";\n    Network[Network[\"testnet\"] = 1] = \"testnet\";\n})(Network = exports.Network || (exports.Network = {}));\nclass CryptoCoinInfo extends RegistryItem_1.RegistryItem {\n    constructor(type, network) {\n        super();\n        this.type = type;\n        this.network = network;\n        this.getRegistryType = () => {\n            return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;\n        };\n        this.getType = () => {\n            return this.type || Type.bitcoin;\n        };\n        this.getNetwork = () => {\n            return this.network || Network.mainnet;\n        };\n        this.toDataItem = () => {\n            const map = {};\n            if (this.type) {\n                map[Keys.type] = this.type;\n            }\n            if (this.network) {\n                map[Keys.network] = this.network;\n            }\n            return new lib_1.DataItem(map);\n        };\n    }\n}\nexports.CryptoCoinInfo = CryptoCoinInfo;\nCryptoCoinInfo.fromDataItem = (dataItem) => {\n    const map = dataItem.getData();\n    const type = map[Keys.type];\n    const network = map[Keys.network];\n    return new CryptoCoinInfo(type, network);\n};\nCryptoCoinInfo.fromCBOR = (_cborPayload) => {\n    const dataItem = lib_1.decodeToDataItem(_cborPayload);\n    return CryptoCoinInfo.fromDataItem(dataItem);\n};\n//# sourceMappingURL=CryptoCoinInfo.js.map"]},"metadata":{},"sourceType":"script"}