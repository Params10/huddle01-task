{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_1 = __importDefault(require(\"assert\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n\n(function (STYLES) {\n  STYLES[\"STANDARD\"] = \"standard\";\n  STYLES[\"URI\"] = \"uri\";\n  STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\n\nconst getWord = index => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);\n};\n\nconst getMinimalWord = index => {\n  const byteword = getWord(index);\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;\n};\n\nconst addCRC = string => {\n  const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n  return `${string}${crc}`;\n};\n\nconst encodeWithSeparator = (word, separator) => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => [...result, getWord(w)], []);\n  return result.join(separator);\n};\n\nconst encodeMinimal = word => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n  return result;\n};\n\nconst decodeWord = (word, wordLength) => {\n  assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n  const dim = 26; // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);\n\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  } // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n\n\n  let x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n  assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table'); // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value);\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n    assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  } // Successful decode.\n\n\n  return Buffer.from([value]).toString('hex');\n};\n\nconst _decode = (string, separator, wordLength) => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n  const decodedString = words.map(word => decodeWord(word, wordLength)).join('');\n  assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n  const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);\n  const checksum = utils_1.getCRCHex(body); // convert to hex\n\n  assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n  return body.toString('hex');\n};\n\nconst decode = (string, style = STYLES.MINIMAL) => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\n\nconst encode = (string, style = STYLES.MINIMAL) => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n\n    default:\n      throw new Error(`Invalid style ${style}`);\n  }\n};\n\nexports.default = {\n  decode,\n  encode,\n  STYLES\n};","map":{"version":3,"sources":["../src/bytewords.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_1 = __importDefault(require(\"assert\"));\nconst utils_1 = require(\"./utils\");\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n(function (STYLES) {\n    STYLES[\"STANDARD\"] = \"standard\";\n    STYLES[\"URI\"] = \"uri\";\n    STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\nconst getWord = (index) => {\n    return bytewords.slice(index * BYTEWORD_LENGTH, (index * BYTEWORD_LENGTH) + BYTEWORD_LENGTH);\n};\nconst getMinimalWord = (index) => {\n    const byteword = getWord(index);\n    return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`;\n};\nconst addCRC = (string) => {\n    const crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n    return `${string}${crc}`;\n};\nconst encodeWithSeparator = (word, separator) => {\n    const crcAppendedWord = addCRC(word);\n    const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n    const result = crcWordBuff.reduce((result, w) => ([...result, getWord(w)]), []);\n    return result.join(separator);\n};\nconst encodeMinimal = (word) => {\n    const crcAppendedWord = addCRC(word);\n    const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n    const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n    return result;\n};\nconst decodeWord = (word, wordLength) => {\n    assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n    const dim = 26;\n    // Since the first and last letters of each Byteword are unique,\n    // we can use them as indexes into a two-dimensional lookup table.\n    // This table is generated lazily.\n    if (bytewordsLookUpTable.length === 0) {\n        const array_len = dim * dim;\n        bytewordsLookUpTable = [...new Array(array_len)].map(() => -1);\n        for (let i = 0; i < BYTEWORDS_NUM; i++) {\n            const byteword = getWord(i);\n            let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n            let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n            let offset = y * dim + x;\n            bytewordsLookUpTable[offset] = i;\n        }\n    }\n    // If the coordinates generated by the first and last letters are out of bounds,\n    // or the lookup table contains -1 at the coordinates, then the word is not valid.\n    let x = (word[0]).toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n    let y = (word[wordLength == 4 ? 3 : 1]).toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n    assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n    let offset = y * dim + x;\n    let value = bytewordsLookUpTable[offset];\n    assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table');\n    // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n    if (wordLength == BYTEWORD_LENGTH) {\n        const byteword = getWord(value);\n        let c1 = word[1].toLowerCase();\n        let c2 = word[2].toLowerCase();\n        assert_1.default(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n    }\n    // Successful decode.\n    return Buffer.from([value]).toString('hex');\n};\nconst _decode = (string, separator, wordLength) => {\n    const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n    const decodedString = words.map((word) => decodeWord(word, wordLength)).join('');\n    assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n    const [body, bodyChecksum] = utils_1.split(Buffer.from(decodedString, 'hex'), 4);\n    const checksum = utils_1.getCRCHex(body); // convert to hex\n    assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n    return body.toString('hex');\n};\nconst decode = (string, style = STYLES.MINIMAL) => {\n    switch (style) {\n        case STYLES.STANDARD:\n            return _decode(string, ' ', BYTEWORD_LENGTH);\n        case STYLES.URI:\n            return _decode(string, '-', BYTEWORD_LENGTH);\n        case STYLES.MINIMAL:\n            return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n        default:\n            throw new Error(`Invalid style ${style}`);\n    }\n};\nconst encode = (string, style = STYLES.MINIMAL) => {\n    switch (style) {\n        case STYLES.STANDARD:\n            return encodeWithSeparator(string, ' ');\n        case STYLES.URI:\n            return encodeWithSeparator(string, '-');\n        case STYLES.MINIMAL:\n            return encodeMinimal(string);\n        default:\n            throw new Error(`Invalid style ${style}`);\n    }\n};\nexports.default = {\n    decode,\n    encode,\n    STYLES\n};\n//# sourceMappingURL=bytewords.js.map"]},"metadata":{},"sourceType":"script"}